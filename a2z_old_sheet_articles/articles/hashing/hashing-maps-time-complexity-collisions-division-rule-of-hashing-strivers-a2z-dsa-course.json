{
    "dislikes": 19,
    "video": "KEs5UyBJ39g",
    "publishedOn": "Sun Mar 24 2024 22:11:56 GMT+0530 (India Standard Time)",
    "slug": "hashing-maps-time-complexity-collisions-division-rule-of-hashing-strivers-a2z-dsa-course",
    "aid": "2202",
    "title": "Hashing | Maps | Time Complexity | Collisions | Division Rule of Hashing | Strivers A2Z DSA Course",
    "tuf_plus": "",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        }
    ],
    "content": "<!-- wp:heading -->\n<h2><strong>Hashing:</strong></h2>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s first try to understand the importance of hashing using an example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given an array of integers: [1, 2, 1, 3, 2] and we are given some queries: [1, 3, 4, 2, 10]. For each query, we need to find out how many times the number appears in the array. For example, if the query is 1 our answer would be 2, and if the query is 4 the answer will be 0.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Similarly, the following will be the answers to the given queries:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7330,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-183332.png\" alt=\"\" class=\"wp-image-7330\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Brute Force approach:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>As we have learned the \u2018for loop\u2019, the first approach that should come to our mind is to use it to solve this problem. For each query, we will iterate over the array using a loop. We will count the number of times the query number appears in that array i.e. increment the counter variable if the array element at that index equals the query number. In terms of function, it will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7331,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-183537.png\" alt=\"\" class=\"wp-image-7331\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now, for each query, we will call the function and it will return the number of times the given query appears in the array.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Time Complexity analysis of the function:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We have learned how to compute the time complexity of any code. The above function contains a for loop that runs for N times. So,<strong> the time complexity of the function will be O(N)</strong> ignoring the other constant operations.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, for each query, we are calling this function. So, if the query contains 5 numbers and we call the function 5 times, the total time complexity will be O(5*N). <strong>If the number of queries is Q, the time complexity will be O(Q*N)</strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, if the length of the query becomes large like 10<sup>5</sup> and the array size also becomes large like 10<sup>5</sup>, the time complexity will be O(10<sup>10</sup>).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We know from our previous knowledge that 10<sup>8</sup> operations take 1 second to get executed. So, 10<sup>10</sup> operations will take around 100 seconds(10<sup>10</sup>/10<sup>8</sup>). We cannot say a code is good if it takes 100 seconds to get executed.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Optimized approach using Hashing:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Definition of Hashing:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In order to optimize this approach, we need to use hashing. If we say <strong>the definition of hashing in a naive way</strong>, it is nothing but <strong>the combination of the steps, pre-storing, and fetching</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, let\u2019s understand how to solve the given problem using the two steps:<br><strong>Assumption: </strong>We are assuming that the maximum element in the given array can be 12.<br><br><strong>Step 1 - Pre-storing: </strong>In this step, we will create an array(named hash array) of size 13(so that we can get the index 12) initialized with 0. In this hash array, we are going to store the frequency of each element(i.e. The number of times each element appears in the array) of the given array. To do so, we will iterate over the given array, and for each element arr[i], we will do hash[arr[i]] += 1. After completing this process the hash array will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7332,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-183817.png\" alt=\"\" class=\"wp-image-7332\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>This step is named pre-storing as we are pre-calculating the information about the element of the array before answering the queries.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 2 - Fetching: </strong>In this step, we will select each query i.e. the number and for the query, we will just fetch the value of hash[number] and return it instead of running a \u2018for loop\u2019 every time.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The implementation is given below:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    int n;\n    cin &gt;&gt; n;\n    int arr[n];\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    //precompute:\n    int hash[13] = {0};\n    for (int i = 0; i &lt; n; i++) {\n        hash[arr[i]] += 1;\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int number;\n        cin &gt;&gt; number;\n        // fetching:\n        cout &lt;&lt; hash[number] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>5<br>1 3 2 1 3<br>5<br>1 4 2 3 12</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>2<br>0<br>1<br>2<br>0</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass tUf {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n;\n        n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i &lt; n; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        //precompute:\n        int[] hash = new int[13];\n        for (int i = 0; i &lt; n; i++) {\n            hash[arr[i]] += 1;\n        }\n\n        int q;\n        q = sc.nextInt();\n        while (q-- != 0) {\n            int number;\n            number = sc.nextInt();\n            // fetching:\n            System.out.println(hash[number]);\n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>5<br>1 3 2 1 3<br>5<br>1 4 2 3 12</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>2<br>0<br>1<br>2<br>0</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Point to remember:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We may encounter a problem where the maximum array element may be very large like 10<sup>9</sup>. In that case, theoretically, we should declare an array of size 10<sup>9</sup>+1. But we cannot do so. The maximum size of an array can be the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7333,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-184950.png\" alt=\"\" class=\"wp-image-7333\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>So, with this method, we can solve the problems where the array is within a specific size. We are going to discuss later in the article, how we can overcome this limitation of the specific size.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Until now, we have learned the <strong>number hashing</strong>. Now, let\u2019s discuss the character hashing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Character Hashing:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Given the string: \u201cabcdabefc\u201d we are given some queries: [a, c, z]. For each query, we need to find out how many times the character appears in the string. For example, if the query is \u2018a\u2019 our answer would be 2, and if the query is \u2018z\u2019 the answer will be 0.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Similarly, the following will be the answers to the given queries:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7334,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-185103.png\" alt=\"\" class=\"wp-image-7334\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Brute Force approach:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>It is similar to the previous problem. Here, for each query, we will iterate over the string using a for loop and will count the number of times the character appears in that string i.e. increment the counter variable if the character at that index of the string equals the given character. In terms of function, it will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7335,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-185316.png\" alt=\"\" class=\"wp-image-7335\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now, for each query, we will call the function and it will return the number of times the given character appears in the string.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Time Complexity analysis of the function:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>It is as same as the one we calculated for the previous problem. <strong>If the number of queries is Q, the time complexity will be O(Q*N) where N = size of the string</strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Optimized approach using Hashing:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In number hashing, each index of the hash array represents an element in the given array. So, somehow, we need to map the characters of the string to an integer so that we can represent them using the indices of the hash array. So, let\u2019s discuss the mapping technique:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Mapping characters to integers:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In order to map the characters we need to use the <a href=\"https://www.w3schools.com/charsets/ref_html_ascii.asp#:~:text=ASCII%20is%20a%207%2Dbit,are%20all%20based%20on%20ASCII.\" target=\"_blank\" rel=\"noopener\" title=\"\">ASCII values</a> of the respective characters. The ASCII value of lowercase a is 97. So, if we write int x = \u2018a\u2019, it will typecast the character, \u2018a\u2019, into the ASCII value, 97, and store it in the variable x instead of throwing an error. So, similarly, if we write hash[\u2018a\u2019], it will signify hash[97].&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, we can do the mapping more efficiently for specific cases like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Case 1 - If the string contains only lowercase letters: </strong>In this case, we can map the characters like: </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">\u2018a\u2019 -&gt; 0, \u2018b\u2019 -&gt; 1, \u2018c\u2019 -&gt; 2,....., \u2018z\u2019 -&gt; 25. </pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>In order to get the corresponding value for a character, we will use the following formula:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>corresponding value = given character - 'a'</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For example, if the given character is \u2018f\u2019, we will get the value as (\u2018f\u2019 - \u2018a\u2019) = (102-97) = 5.&nbsp; Here, we can easily observe that the maximum value can be 25.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>So, for character hashing in this case, we need a hash array of size 26. And while pre-storing we will do hash[s[i]-\u2019a\u2019] += 1 instead of hash[arr[i]] += 1, and while fetching we will do hash[character-\u2019a\u2019] instead of hash[number]. The rest of the methods will be as same as in the case of number hashing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Case 2 -&nbsp; If the string contains only uppercase letters: </strong>In this case, we can map the characters like: </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">\u2018A\u2019 -&gt; 0, \u2018B\u2019 -&gt; 1, \u2018C\u2019 -&gt; 2,....., \u2018Z\u2019 -&gt; 25. </pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>In order to get the corresponding value for a character, we will use the following formula:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>corresponding value = given character - 'A'</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Then the process will be similar to case 1.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Case 3 - If the string contains both uppercase and lowercase letters: </strong>We have 256 characters in total in this case. So, we will create a hash array of size 256. We will not subtract anything from the given character and will use the character as it is, to access the hash array while pre-storing and fetching. For pre-storing hash[s[i]] += 1 and for fetching we will use hash[character] only. The rest of the process will be exactly the same as in the number hashing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>The case 3 method also applies to case 1 and case 2. In character hashing, the limit will not cross 256 and so we will always use this method.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The implementation is given below:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code if the string contains only lowercase</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    string s;\n    cin &gt;&gt; s;\n\n    //precompute:\n    int hash[26] = {0};\n    for (int i = 0; i &lt; s.size(); i++) {\n        hash[s[i] - 'a']++;\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        char c;\n        cin &gt;&gt; c;\n        // fetch:\n        cout &lt;&lt; hash[c - 'a'] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>abcdabehf<br>5<br>a<br>g<br>h<br>b<br>c</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong>2<br>0<br>1<br>2<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass tUf {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String s;\n        s = sc.next();\n\n        //precompute:\n        int[] hash = new int[26];\n        for (int i = 0; i &lt; s.length(); i++) {\n            hash[s.charAt(i) - 'a']++;\n        }\n\n        int q;\n        q = sc.nextInt();\n        while (q-- &gt; 0) {\n            char c;\n            c = sc.next().charAt(0);\n            // fetch:\n            System.out.println(hash[c - 'a']);\n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>abcdabehf<br>5<br>a<br>g<br>h<br>b<br>c</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong>2<br>0<br>1<br>2<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code if the string contains both uppercase and lowercase</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    string s;\n    cin &gt;&gt; s;\n\n    //precompute:\n    int hash[256] = {0};\n    for (int i = 0; i &lt; s.size(); i++) {\n        hash[s[i]]++;\n    }\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        char c;\n        cin &gt;&gt; c;\n        // fetch:\n        cout &lt;&lt; hash[c] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong><br>abcdabehf<br>5<br>a<br>g<br>h<br>b<br>c</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong><br>2<br>0<br>1<br>2<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\"> import java.util.*;\n\nclass tUf {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String s;\n        s = sc.next();\n\n        //precompute:\n        int[] hash = new int[256];\n        for (int i = 0; i &lt; s.length(); i++) {\n            hash[s.charAt(i)]++;\n        }\n\n        int q;\n        q = sc.nextInt();\n        while (q-- &gt; 0) {\n            char c;\n            c = sc.next().charAt(0);\n            // fetch:\n            System.out.println(hash[c]);\n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong><br>abcdabehf<br>5<br>a<br>g<br>h<br>b<br>c</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong><br>2<br>0<br>1<br>2<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>How to hash large numbers like 10</strong><strong><sup>9</sup></strong><strong> or higher:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Until now, we have learned the method of number hashing but using this method we cannot hash large numbers like 10<sup>9</sup> or higher. We can solve this problem using the STL map and unordered_map in C++ or the HashMap in Java collection. Now, we are going to discuss these concepts in detail and most of the concepts are the same in map/unordered_map(in C++) and HashMap(in Java).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>map and unordered_map in C++ / HashMap in Java:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand the concepts considering the same example, we have used before, in the case of number hashing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The data structure looks like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7336,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-190526.png\" alt=\"\" class=\"wp-image-7336\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Key: </strong>In a map, a key refers to the element, for which we want to store information. We can access the value of a key using the key itself like mp[key].</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Value: </strong>Value refers to the information stored corresponding to a key.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In our example, we want to store the frequency(i.e. How many times an element appears in the array) of each element of the given array. So, here each element of the array will be the key of the map and frequencies will be the value corresponding to the keys. In terms of code, it will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7337,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-190616.png\" alt=\"\" class=\"wp-image-7337\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Difference between map and unordered_map in C++:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7338,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-190701.png\" alt=\"\" class=\"wp-image-7338\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Difference between array hashing and hashing using the map:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand the difference considering the array: [1, 2, 3, 1, 3, 2, 12]. Here, the maximum element of the array is 12. So, if we apply array hashing, we need an array of size 13. But if we apply the map data structure, it will be the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7339,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-190746.png\" alt=\"\" class=\"wp-image-7339\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>If we want to fetch the value of a key that does not exist in the map, the map will always return 0 in C++ and null in Java.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n\n    int n;\n    cin &gt;&gt; n;\n    int arr[n];\n    for (int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; arr[i];\n    }\n\n    //precompute:\n    map&lt;int, int&gt; mp;\n    for (int i = 0; i &lt; n; i++) {\n        mp[arr[i]]++;\n    }\n\n    // iterate over the map:\n    /* for(auto it : mp){\n            cout &lt;&lt; it.first &lt;&lt; \"-&gt;\" &lt;&lt; it.second &lt;&lt; endl;\n        }\n    */\n\n    int q;\n    cin &gt;&gt; q;\n    while (q--) {\n        int number;\n        cin &gt;&gt; number;\n        // fetch:\n        cout &lt;&lt; mp[number] &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;<br>7<br>1 2 3 1 3 2 12<br>5<br>1 2 3 4 12</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong><br>2<br>2<br>2<br>0<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass tUf {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n;\n        n = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i &lt; n; i++) {\n            arr[i] = sc.nextInt();\n        }\n\n        //precompute:\n        HashMap&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            int key = arr[i];\n            int freq = 0;\n            if (mp.containsKey(key)) freq = mp.get(key); // fetching from the map\n            freq++;\n            mp.put(key, freq); // inserting into the map\n        }\n\n        // Iterate over the map:\n        /*\n        for (Map.Entry&lt;Integer, Integer&gt; it : mp.entrySet()) {\n            System.out.println(it.getKey() + \"-&gt;\" + it.getValue());\n        }\n        */\n\n        int q;\n        q = sc.nextInt();\n        while (q-- &gt; 0) {\n            int number;\n            number = sc.nextInt();\n            // fetch:\n            if (mp.containsKey(number)) System.out.println(mp.get(number));\n            else System.out.println(0);\n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong>&nbsp;<br>7<br>1 2 3 1 3 2 12<br>5<br>1 2 3 4 12</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:&nbsp;</strong><br>2<br>2<br>2<br>0<br>1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>We can similarly perform <strong>character hashing</strong> using the map data structure. </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The syntax will be the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7340,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-191223.png\" alt=\"\" class=\"wp-image-7340\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Time complexity of map data structure:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The total time complexity will be O(N * time taken by map data structure).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Storing(i.e. insertion) and fetching(i.e. retrieval) in a C++ map, both take always O(logN) time complexity, where N = the size of the map.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>But the unordered_map in C++ and HashMap in Java, both take O(1) time complexity to perform storing(i.e. insertion) and fetching(i.e. retrieval). Now, it is valid for the best case and the average case.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>But in the worst case, this time complexity will be O(N) for unordered_map. Now, the worst case occurs very very rarely. It almost never happens and most of the time, we will be using unordered_map.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:</strong> <em>Our first priority will be always to use unordered_map and then map.</em> <em>If unordered_map gives a time limit exceeded error(TLE), we will then use the map.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The time complexity in the worst case is O(N) because of the internal collision.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In order to understand collision properly, we need to understand the concept of how the hashing work with an optimized space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>What is collision &amp; How the hashing works:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Hashing is done using several methods. Among them, the three most common ones are</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li><strong>Division method</strong></li><li><strong>Folding method</strong></li><li><strong>Mid-Square method</strong></li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Here, we are only interested to discuss the division method. The rest two methods may be important for college exams but not much important in terms of interviews or coding rounds.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The map data structures in the C++ STL or in Java are implemented using different and complex methods. We need not know about them. But here we are going to discuss the <strong>division method</strong> so that we can understand the collision properly.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Division Method:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s discuss it considering the following example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Assume, we are given an array: <strong>[2, 5, 16, 28, 139]</strong>. Here, we can apply array hashing, and to use that, we need to create an array of size 140. Now, what to do if we are given a constraint that <strong>we cannot use an array whose length is greater than 10</strong>?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In order to solve this we will use the division method. We will simply consider the modulo 10 of each element of the array(element % 10) and we will hash(pre-store and fetch) the elements on the basis of the modulo value i.e. the remainder. The steps will look like the following:<br>Pre storing: hash[arr[i]%10] += 1 and Fetching: hash[number%10]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now if we apply this method to the given array, the hash array will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7341,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-191448.png\" alt=\"\" class=\"wp-image-7341\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>This is how the division method works. We simply reduce the array elements and apply array hashing.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s discuss the questions that come up in the mind:<br></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Question: What if two or more array elements give the same remainder for modulo 10?</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In this case, we apply the <strong>linear chaining</strong> method. This method is implemented using Linked List which will be discussed later in another article. Here, we just need to understand the logic. While storing the elements we will maintain a chain(i.e. inserting the element itself to the corresponding index instead of just keeping the count) for each index(i.e. the remainder we get). And in that chains, we will store the elements in a sorted fashion.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand it considering the following example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given array: <strong>[2, 5, 16, 28, 139, 38, 48, 28, 18]</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In this array 28, 38, 48, and 18 are giving the same value for modulo 10. So, we will apply linear chaining. The hash array will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7342,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-191630.png\" alt=\"\" class=\"wp-image-7342\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now to get the frequency of a number, we will first go to (number % 10) indexed chain and count the frequency of that number.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:</strong> <em>We can choose to take modulo of any number as per our need. Here for example we have taken the number 10.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Collision:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Now, if we are applying linear chaining and division rule and we find that all elements of an array get stored in a single index, then we will call it a case of collision.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">Given array: [8, 18, 28, 38, 48, 58, 68, \u2026.., 1008]</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>If we apply the methods and take modulo 10 for every number, the hash array will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7343,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-28-192940.png\" alt=\"\" class=\"wp-image-7343\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now, while fetching we have to traverse N times(N = size of the given array) to find the frequency of an element. This is when the worst case happens and the time complexity becomes O(N). But this happens very very rarely.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Whatever method the map is using, if all the elements go to the same hash index, we will call it a case of collision.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>In the map data structure, the data type of key can be anything like int, double, pair&lt;int, int&gt;, etc. But for unordered_map the data type is limited to integer, double, string, etc. We cannot have an unordered_map whose key is pair&lt;int, int&gt;.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "hashing",
    "likes": 830,
    "preview": "HASHING: Let\u2019s first try to understand the importance of hashing using an example: Given an array of integers: [1, 2, 1, 3, 2] and we are given some queries: [1, 3, 4, 2, 10]. For each query, we ne..."
}