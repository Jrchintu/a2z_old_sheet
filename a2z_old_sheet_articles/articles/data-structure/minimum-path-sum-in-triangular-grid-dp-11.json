{
    "dislikes": 3,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:59 GMT+0530 (India Standard Time)",
    "slug": "minimum-path-sum-in-triangular-grid-dp-11",
    "aid": "1641",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/triangle",
    "title": "Minimum path sum in Triangular Grid (DP 11)",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "category_tag": "data-structure",
    "likes": 73,
    "preview": "In this article, we will solve the most asked coding interview problem: Minimum path sum in Triangular Grid Problem Link: Fixed Starting and Ending Point Problem Description: We are given a Triangu...",
    "content": "<!-- wp:paragraph -->\n<p>In this article, we will solve the most asked coding interview problem: Minimum path sum in Triangular Grid</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Link: </strong><a href=\"https://www.codingninjas.com/codestudio/problems/triangle_1229398?source=youtube&amp;campaign=striver_dp_videos&amp;utm_source=youtube&amp;utm_medium=affiliate&amp;utm_campaign=striver_dp_videos\"><strong>Fixed Starting and Ending Point</strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Description:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given a Triangular matrix. We need to find the minimum path sum from the first row to the last row.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>At every cell we can move in only two directions: either to the bottom cell (\u2193) or to the bottom-right cell(\u2198)</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example:</strong>\n\n<img width=\"654\" height=\"368\" src=\"https://lh3.googleusercontent.com/EIm_osUvLQDqDWEZ0AkumtyDzfn8TEefpZ-ZpIVIh1ITEKl2rnu_yLdXqZolvrqYkKNsGjicgLtS2gr9py0uCp89tu15PoROUcDj3wT9RQi3dIe4Cwb9ricoxjFEFOsu4rDVY1Yn\"></pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/triangle_1229398?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nMemorization approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nTabulation approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nSpace Optimization\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemorization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<p>This question is a slight modification of the question discussed in <a href=\"https://takeuforward.org/data-structure/minimum-path-sum-in-a-grid-dp-10/\">Minimum Path Sum in a Grid</a>. In the previous problem, we were given a rectangular matrix whereas here the matrix is in the form of a triangle. Moreover, we don\u2019t have a fixed destination, we need to return the minimum sum path from the top cell to any cell of the bottom row.</p>\n<h2><strong>Why a Greedy Solution doesn\u2019t work?</strong></h2>\n<p>As we have to return the minimum path sum, the first approach that comes to our mind is to take a greedy approach and always form a path by locally choosing the cheaper option.</p>\n<p>This approach will not give us the correct answer. Let us look at this example to understand:</p>\n<p><img width=\"320\" height=\"286\" src=\"https://lh3.googleusercontent.com/-AydSy7tExkGzBSb5OQKtlB6R7gz7CIGId1Zfp45UurEUl1u175cEU4qQxuavBo9J3o0xUrfiV0lHXSn6BNFbNqwLNsnC0WNdQ_UOCjd8Zc5zzOvyogTq-OjBHIXjpy60A5G53ZF\"></p>\n<p>At every cell, we have two choices: to move to the bottom cell or move to the bottom-right cell. Our ultimate aim is to provide a path that provides us the least path sum. Therefore at every cell, we will make the choice to move which costs us less.</p>\n<figure class=\"wp-block-image size-large\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/01/Caculate-1024x576.jpg\" alt=\"\" class=\"wp-image-6588\"></figure>\n<ul><li>Figure on the left gives us a greedy solution, where we move by taking the local best choice.</li><li>Figure on the right gives us a non-greedy solution.</li></ul>\n<p>We can clearly see the problem with the greedy solution. Whenever we are making a local choice, we may tend to choose a path that may cost us way more later.</p>\n<p>Therefore, the other alternative left to us is to generate all the possible paths and see which is the path with the minimum path sum. To generate all paths we will use <strong>recursion</strong>.</p>\n<h2><strong>Steps to form the recursive solution:&nbsp;</strong></h2>\n<p>We will first form the recursive solution by the three points mentioned in <a href=\"https://takeuforward.org/data-structure/dynamic-programming-introduction/\">Dynamic Programming Introduction</a>.&nbsp;</p>\n<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>\n<p>We are given a triangular matrix with the number of rows equal to N.</p>\n<p>We can define the function with two parameters i and j, where i and j represent the row and column of the matrix.</p>\n<p>Now our ultimate aim is to reach the last row. We can define f(i,j) such that it gives us the minimum path sum from the cell [i][j] to the last row.</p>\n<p><img width=\"584\" height=\"124\" src=\"https://lh6.googleusercontent.com/4SY_tfeEPxW5lHQrqgmTTUac3_0IrikUnNk-TblF_P95y5EVz3V0a2fq6Ih3s5rwwcIE51uzy-emzUav9j14mZAS89lhIZWZNRgV2pDoz0R7Vqn1FrUdenmf7CLBsikw-6X5RZU9\"></p>\n<p>We want to find f(0,0) and return it as our answer.</p>\n<p><strong>Base Case:</strong></p>\n<p>There will be a single base case:</p>\n<ul><li>When i == N-1, that is when we have reached the last row, so the min path from that cell to the last row will be the value of that cell itself, hence we return mat[i][j].</li></ul>\n<p>At every cell, we have two options to move to the bottom cell(\u2193) or to the bottom-right cell(\u2198). If we closely observe the triangular grid, at max we can reach the last row from where we return so we will not be able to go move out of the index of the grid. Therefore only one base condition is required.</p>\n<p><img width=\"651\" height=\"366\" src=\"https://lh4.googleusercontent.com/w05BDzig0lXum6GG5VAtBHzZI1j0kO6awSGThCsI-ZjDEk798W7rvo5BbhFK6IZgn3eVfCpBWCSZqkyNGk_t7AuEbH_X5-3uXnCNsLu7KMCklcDn6q97MJd3-wJb_Jy_KcH4pppf\"></p>\n<p>The pseudocode till this step will be:</p>\n<p><img width=\"330\" height=\"230\" src=\"https://lh4.googleusercontent.com/hd7vM8z8TFxcexVWdEMngkwE9qcJSoDXjaX_rCHsHThGULGW3YJ4FfQ6wUyUtqErgbCjuuXnAywgBLeX5KOS7OJDnuJEZS4NBMbNKx7j12e5FvCIIfZn-OXJJgRdnVM1hzI7IWI2\"></p>\n<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>\n<p>At every index we have two choices, one to go to the bottom cell(\u2193) other to the bottom-right cell(\u2198). To go to the bottom, we will increase i by 1, and to move towards the bottom-right we will increase both i and j by 1.</p>\n<p>Now when we get our answer for the recursive call (f(i+1,j) or f(i+1,j+1)), we need to also add the current cell value to it as we have to include it too for the current path sum.</p>\n<p><img width=\"367\" height=\"343\" src=\"https://lh6.googleusercontent.com/0qW3LNb065RTIVBXkKnv7dtnhyWhLrKD-sXeojUjRG79j-Z0j9FYeyRzixzQ1P85RSYpfBjo1qEP0aoUpBkqS1EuEGRgyRJqwPcH1WF_NLXG3VJQ4dug7xmteJ-qXaEC-99SIK5A\"></p>\n<p><strong>Step 3:&nbsp; Take the maximum of all choices</strong></p>\n<p>As we have to find the<strong> minimum path sum </strong>of<strong> </strong>all the possible unique paths, we will return the <strong>minimum</strong> of the choices(down and diagonal)&nbsp;</p>\n<p>The final pseudocode after steps 1, 2, and 3:</p>\n<p><img width=\"422\" height=\"397\" src=\"https://lh5.googleusercontent.com/QEevo5iwqrlunXO2yeIeYOuv7ue5N260SnYen5-LmE4D0NhM_eRDZdZ73PMDGOc411M7clbAX7oe837HF6sh31y7G6JvRSKBrKSvGnJOz0BkGsdvfb9NNxXwsQ8NEOSg-LQAPWPY\"></p>\n<h2><strong>Steps to memoize a recursive solution:</strong></h2>\n<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>\n<ol><li>Create a dp array of size [N][N]</li><li>Whenever we want to find the answer of a particular row and column (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the minimum path sum recursively with memoization\nint minimumPathSumUtil(int i, int j, vector&lt;vector&lt;int&gt; &gt; &amp;triangle, int n,\n                       vector&lt;vector&lt;int&gt; &gt; &amp;dp) {\n    // If the result for this cell is already calculated, return it\n    if (dp[i][j] != -1)\n        return dp[i][j];\n\n    // If we're at the bottom row, return the value of the current cell\n    if (i == n - 1)\n        return triangle[i][j];\n\n    // Calculate the sum of two possible paths: going down and going diagonally\n    int down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp);\n    int diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp);\n\n    // Store the minimum of the two paths in the dp table and return it\n    return dp[i][j] = min(down, diagonal);\n}\n\n// Function to find the minimum path sum in the given triangle\nint minimumPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;triangle, int n) {\n    // Create a memoization table to store computed results\n    vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, -1));\n    // Call the recursive function to find the minimum path sum\n    return minimumPathSumUtil(0, 0, triangle, n, dp);\n}\n\nint main() {\n    // Define the triangle as a 2D vector\n    vector&lt;vector&lt;int&gt; &gt; triangle{{1},\n                                   {2, 3},\n                                   {3, 6, 7},\n                                   {8, 9, 6, 10}};\n\n    // Get the number of rows in the triangle\n    int n = triangle.size();\n\n    // Call the minimumPathSum function and print the result\n    cout &lt;&lt; minimumPathSum(triangle, n);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    // Function to find the minimum path sum in the triangle using dynamic programming\n    static int minimumPathSumUtil(int i, int j, int[][] triangle, int n, int[][] dp) {\n        // Check if the result for the current position (i, j) is already calculated\n        if (dp[i][j] != -1)\n            return dp[i][j];\n\n        // If we are at the bottom row, return the value in the triangle\n        if (i == n - 1)\n            return triangle[i][j];\n\n        // Calculate the minimum path sum by recursively considering two possible paths: down and diagonal\n        int down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp);\n        int diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp);\n\n        // Store the result in the dp array and return the minimum of the two paths\n        return dp[i][j] = Math.min(down, diagonal);\n    }\n\n    // Function to find the minimum path sum in the triangle\n    static int minimumPathSum(int[][] triangle, int n) {\n        // Create a 2D array to store computed results, initialize with -1\n        int dp[][] = new int[n][n];\n        for (int row[] : dp)\n            Arrays.fill(row, -1);\n\n        // Call the utility function to find the minimum path sum starting from the top\n        return minimumPathSumUtil(0, 0, triangle, n, dp);\n    }\n\n    public static void main(String args[]) {\n        int triangle[][] = {{1},\n                            {2, 3},\n                            {3, 6, 7},\n                            {8, 9, 6, 10}};\n\n        int n = triangle.length;\n\n        // Call the minimumPathSum function and print the result\n        System.out.println(minimumPathSum(triangle, n));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef minimumPathSumUtil(i, j, triangle, n, dp):\n    # Check if we have already computed the minimum path sum for this cell\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    # If we are at the bottom of the triangle, return the value in the current cell\n    if i == n - 1:\n        return triangle[i][j]\n\n    # Calculate the minimum path sum by considering two possible moves: down and diagonal\n    down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp)\n    diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp)\n\n    # Store the computed minimum path sum in the memoization table\n    dp[i][j] = min(down, diagonal)\n    return dp[i][j]\n\n# Define a wrapper function to initialize memoization table and start the computation\ndef minimumPathSum(triangle, n):\n    dp = [[-1 for j in range(n)] for i in range(n)]  # Initialize a memoization table with -1\n    return minimumPathSumUtil(0, 0, triangle, n, dp)  # Start the recursive computation\n\n# Define the main function where you set up the triangle and call the minimumPathSum function\ndef main():\n    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]\n    n = len(triangle)\n\n    # Call the minimumPathSum function and print the result\n    print(minimumPathSum(triangle, n))\n\n# Check if this script is the main program entry point\nif __name__ == \"__main__\":\n    main()  # Call the main function to start the program\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction minimumPathSumUtil(i, j, triangle, n, dp) {\n  // If the result is already computed, return it\n  if (dp[i][j] !== -1) {\n    return dp[i][j];\n  }\n\n  // If we are at the last row, return the value in the triangle\n  if (i === n - 1) {\n    return triangle[i][j];\n  }\n\n  // Calculate the minimum path sum by moving down and diagonally\n  const down = triangle[i][j] + minimumPathSumUtil(i + 1, j, triangle, n, dp);\n  const diagonal = triangle[i][j] + minimumPathSumUtil(i + 1, j + 1, triangle, n, dp);\n\n  // Store the result in the DP array and return it\n  dp[i][j] = Math.min(down, diagonal);\n  return dp[i][j];\n}\n\nfunction minimumPathSum(triangle, n) {\n  // Initialize the DP array with -1 values\n  const dp = new Array(n).fill().map(() =&gt; new Array(n).fill(-1));\n  return minimumPathSumUtil(0, 0, triangle, n, dp);\n}\n\nfunction main() {\n  const triangle = [\n    [1],\n    [2, 3],\n    [3, 6, 7],\n    [8, 9, 6, 10]\n  ];\n\n  const n = triangle.length;\n\n  console.log(minimumPathSum(triangle, n));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Brute Force Here -->\n</p><p><strong>Output:</strong> 14\n\n</p>\n<p></p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n</p><p><strong>Time Complexity: O(N*N)</strong></p>\n<p>Reason: There are two nested loops</p>\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<p>Reason: We are using an external array of size \u2018N*N\u2019. The stack space will be eliminated.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<h2><strong>Steps to convert Recursive Solution to Tabulation one.</strong></h2>\n<p>Recursion/Memoization is a top-down approach whereas tabulation is a bottom-up approach. As in recursion/memoization, we have moved from 0 to N-1, in tabulation we move from N-1 to 0, i.e the last row to the first one.</p>\n<p>The steps to convert to the tabular solution are given below:</p>\n<ul><li>Declare a dp[] array of size [N][N].</li><li>First initialize the base condition values, i.e the last row of the dp matrix to the last row of the triangle matrix.</li><li>Our answer should get stored in dp[0][0]. We want to move from the last row to the first row. So that whenever we compute values for a cell, we have all the values required to calculate it.</li><li>If we see the memoized code, the values required for dp[i][j] are dp[i+1][j] and dp[i+1][j+1]. So we only need the values from the \u2018i+1\u2019 row.</li><li>We have already filled the last row (i=N-1), if we start from row \u2018N-2\u2019 and move upwards we will find the values correctly.</li><li>We can use two nested loops to have this traversal.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the minimum path sum in the given triangle using dynamic programming\nint minimumPathSum(vector&lt;vector&lt;int&gt; &gt; &amp;triangle, int n) {\n    // Create a 2D DP (dynamic programming) array to store minimum path sums\n    vector&lt;vector&lt;int&gt; &gt; dp(n, vector&lt;int&gt;(n, 0));\n\n    // Initialize the bottom row of dp with the values from the triangle\n    for (int j = 0; j &lt; n; j++) {\n        dp[n - 1][j] = triangle[n - 1][j];\n    }\n\n    // Iterate through the triangle rows in reverse order\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j = i; j &gt;= 0; j--) {\n            // Calculate the minimum path sum for the current cell\n            int down = triangle[i][j] + dp[i + 1][j];\n            int diagonal = triangle[i][j] + dp[i + 1][j + 1];\n\n            // Store the minimum of the two possible paths in dp\n            dp[i][j] = min(down, diagonal);\n        }\n    }\n\n    // The top-left cell of dp now contains the minimum path sum\n    return dp[0][0];\n}\n\nint main() {\n    // Define the triangle as a 2D vector\n    vector&lt;vector&lt;int&gt; &gt; triangle{{1},\n                                   {2, 3},\n                                   {3, 6, 7},\n                                   {8, 9, 6, 10}};\n\n    // Get the number of rows in the triangle\n    int n = triangle.size();\n\n    // Call the minimumPathSum function and print the result\n    cout &lt;&lt; minimumPathSum(triangle, n);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    // Function to find the minimum path sum in the triangle using dynamic programming\n    static int minimumPathSum(int[][] triangle, int n) {\n        // Create a 2D array to store intermediate results\n        int dp[][] = new int[n][n];\n\n        // Initialize the bottom row of dp with the values from the bottom row of the triangle\n        for (int j = 0; j &lt; n; j++) {\n            dp[n - 1][j] = triangle[n - 1][j];\n        }\n\n        // Starting from the second to last row, calculate the minimum path sum for each element\n        for (int i = n - 2; i &gt;= 0; i--) {\n            for (int j = i; j &gt;= 0; j--) {\n                // Calculate the two possible paths: moving down or moving diagonally\n                int down = triangle[i][j] + dp[i + 1][j];\n                int diagonal = triangle[i][j] + dp[i + 1][j + 1];\n\n                // Store the minimum of the two paths in dp\n                dp[i][j] = Math.min(down, diagonal);\n            }\n        }\n\n        // The result is stored at the top of dp array\n        return dp[0][0];\n    }\n\n    public static void main(String args[]) {\n        int triangle[][] = {{1},\n                            {2, 3},\n                            {3, 6, 7},\n                            {8, 9, 6, 10}};\n\n        int n = triangle.length;\n\n        // Call the minimumPathSum function and print the result\n        System.out.println(minimumPathSum(triangle, n));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef minimum_path_sum(triangle, n):\n    # Create a 2D array dp to store minimum path sums\n    dp = [[0 for j in range(n)] for i in range(n)]\n    \n    # Initialize the bottom row of dp with the values from the last row of the triangle\n    for j in range(n):\n        dp[n - 1][j] = triangle[n - 1][j]\n    \n    # Start from the second-to-last row and work upwards\n    for i in range(n - 2, -1, -1):\n        for j in range(i, -1, -1):\n            # Calculate the minimum path sum for the current cell by considering two possible moves: down and diagonal\n            down = triangle[i][j] + dp[i + 1][j]\n            diagonal = triangle[i][j] + dp[i + 1][j + 1]\n            \n            # Store the minimum of the two possible moves in dp\n            dp[i][j] = min(down, diagonal)\n    \n    # The minimum path sum will be stored in dp[0][0] after the loops\n    return dp[0][0]\n\ndef main():\n    # Define the input triangle and its size\n    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]\n    n = len(triangle)\n    \n    # Call the minimum_path_sum function and print the result\n    print(minimum_path_sum(triangle, n))\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction minimumPathSum(triangle, n) {\n  // Initialize the DP array with all zeros\n  const dp = new Array(n).fill().map(() =&gt; new Array(n).fill(0));\n\n  // Initialize the bottom row of the DP array with the values from the triangle\n  for (let j = 0; j &lt; n; j++) {\n    dp[n - 1][j] = triangle[n - 1][j];\n  }\n\n  // Start from the second-to-last row and work upwards\n  for (let i = n - 2; i &gt;= 0; i--) {\n    for (let j = 0; j &lt;= i; j++) {\n      // Calculate the minimum path sum by considering the down and diagonal moves\n      const down = triangle[i][j] + dp[i + 1][j];\n      const diagonal = triangle[i][j] + dp[i + 1][j + 1];\n\n      // Store the minimum of down and diagonal in the DP array\n      dp[i][j] = Math.min(down, diagonal);\n    }\n  }\n\n  // The minimum path sum will be stored in the top-left corner of the DP array\n  return dp[0][0];\n}\n\nfunction main() {\n  const triangle = [\n    [1],\n    [2, 3],\n    [3, 6, 7],\n    [8, 9, 6, 10]\n  ];\n\n  const n = triangle.length;\n\n  console.log(minimumPathSum(triangle, n));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\n<strong>Output:</strong> 14\n\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n</p><p><strong>Time Complexity: O(N*N)</strong></p>\n<p>Reason: There are two nested loops</p>\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<p>Reason: We are using an external array of size \u2018N*N\u2019. The stack space will be eliminated.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nSpace Optimization Approach \n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Better Approach Here -->\n<p>If we closely look the relation,</p>\n<p><strong>dp[i][j] = matrix[i][j] + min(dp[i+1][j] + dp[i+1][j+1]))</strong></p>\n<p>We see that we only need the next row, in order to calculate dp[i][j]. Therefore we can space optimize it.</p>\n<p>Initially we can take a dummy row ( say front). We initialize this row to the triangle matrix's last row( as done in tabulation).</p>\n<p>Now the current row(say cur) only needs the front<strong> row\u2019s</strong> value in order to calculate dp[i][j].</p>\n<p><img width=\"624\" height=\"351\" src=\"https://lh3.googleusercontent.com/jf7ZmCUoOZrmDkMOLP9YWB6hrQxDa_iPgfpp-lzK-ZlzefAlxTbwjaqwuc8DsVCdtVjNkEw9aT7gwJVBef68qpZrscdlxv6gYDrZOPH-Q7NzpspC6sEXjQr5lBruCDkZcupOa6nT\"></p>\n<p>At last, front [0] will give us the required answer.</p>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the minimum path sum in the given triangle using dynamic programming\nint minimumPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;triangle, int n) {\n    // Create two arrays to store the current and previous row values\n    vector&lt;int&gt; front(n, 0); // Represents the previous row\n    vector&lt;int&gt; cur(n, 0);   // Represents the current row\n    \n    // Initialize the front array with values from the last row of the triangle\n    for (int j = 0; j &lt; n; j++) {\n        front[j] = triangle[n - 1][j];\n    }\n    \n    // Iterate through the triangle rows in reverse order\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j = i; j &gt;= 0; j--) {\n            // Calculate the minimum path sum for the current cell\n            int down = triangle[i][j] + front[j];\n            int diagonal = triangle[i][j] + front[j + 1];\n            \n            // Store the minimum of the two possible paths in the current row\n            cur[j] = min(down, diagonal);\n        }\n        // Update the front array with the values from the current row\n        front = cur;\n    }\n    \n    // The front array now contains the minimum path sum from the top to the bottom of the triangle\n    return front[0];\n}\n\nint main() {\n    // Define the triangle as a 2D vector\n    vector&lt;vector&lt;int&gt;&gt; triangle{{1},\n                                  {2, 3},\n                                  {3, 6, 7},\n                                  {8, 9, 6, 10}};\n\n    // Get the number of rows in the triangle\n    int n = triangle.size();\n\n    // Call the minimumPathSum function and print the result\n    cout &lt;&lt; minimumPathSum(triangle, n);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    // Function to find the minimum path sum in the triangle using dynamic programming\n    static int minimumPathSum(int[][] triangle, int n) {\n        // Create two arrays to store intermediate results: front and cur\n        int[] front = new int[n]; // Stores the results for the current row\n        int[] cur = new int[n];   // Stores the results for the next row\n\n        // Initialize the front array with the values from the bottom row of the triangle\n        for (int j = 0; j &lt; n; j++) {\n            front[j] = triangle[n - 1][j];\n        }\n\n        // Starting from the second to last row, calculate the minimum path sum for each element\n        for (int i = n - 2; i &gt;= 0; i--) {\n            for (int j = i; j &gt;= 0; j--) {\n                // Calculate the two possible paths: moving down or moving diagonally\n                int down = triangle[i][j] + front[j];\n                int diagonal = triangle[i][j] + front[j + 1];\n\n                // Store the minimum of the two paths in the cur array\n                cur[j] = Math.min(down, diagonal);\n            }\n            \n            // Update the front array with the values from the cur array for the next row\n            front = cur.clone();\n        }\n\n        // The result is stored at the top of the front array\n        return front[0];\n    }\n\n    public static void main(String args[]) {\n        int triangle[][] = {{1},\n                            {2, 3},\n                            {3, 6, 7},\n                            {8, 9, 6, 10}};\n\n        int n = triangle.length;\n\n        // Call the minimumPathSum function and print the result\n        System.out.println(minimumPathSum(triangle, n));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef minimumPathSum(triangle, n):\n    # Initialize two lists: front and cur to represent the current and previous rows in dp\n    front = [0] * n  # This represents the previous row\n    cur = [0] * n    # This represents the current row\n    \n    # Initialize the bottom row of dp (front) with the values from the last row of the triangle\n    for j in range(n):\n        front[j] = triangle[n - 1][j]\n    \n    # Start from the second-to-last row and work upwards\n    for i in range(n - 2, -1, -1):\n        for j in range(i, -1, -1):\n            # Calculate the minimum path sum for the current cell by considering two possible moves: down and diagonal\n            down = triangle[i][j] + front[j]\n            diagonal = triangle[i][j] + front[j + 1]\n            \n            # Store the minimum of the two possible moves in the current row (cur)\n            cur[j] = min(down, diagonal)\n        \n        # Update the previous row (front) with the current row (cur) for the next iteration\n        front = cur\n        \n    # The minimum path sum will be stored in the first element of the front list after the loops\n    return front[0]\n\ndef main():\n    # Define the input triangle and its size\n    triangle = [[1], [2, 3], [3, 6, 7], [8, 9, 6, 10]]\n    n = len(triangle)\n    \n    # Call the minimumPathSum function and print the result\n    print(minimumPathSum(triangle, n))\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction minimumPathSum(triangle, n) {\n  // Initialize two arrays: front and cur\n  let front = new Array(n).fill(0);\n  let cur = new Array(n).fill(0);\n\n  // Initialize the bottom row of the front array with the values from the triangle\n  for (let j = 0; j &lt; n; j++) {\n    front[j] = triangle[n - 1][j];\n  }\n\n  // Start from the second-to-last row and work upwards\n  for (let i = n - 2; i &gt;= 0; i--) {\n    for (let j = 0; j &lt;= i; j++) {\n      // Calculate the minimum path sum by considering the down and diagonal moves\n      const down = triangle[i][j] + front[j];\n      const diagonal = triangle[i][j] + front[j + 1];\n\n      // Store the minimum of down and diagonal in the cur array\n      cur[j] = Math.min(down, diagonal);\n    }\n    \n    // Update the front array with the values from the cur array\n    front = [...cur];\n  }\n\n  // The minimum path sum will be stored in the first element of the front array\n  return front[0];\n}\n\nfunction main() {\n  const triangle = [\n    [1],\n    [2, 3],\n    [3, 6, 7],\n    [8, 9, 6, 10]\n  ];\n\n  const n = triangle.length;\n\n  console.log(minimumPathSum(triangle, n));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\n<strong>Output:</strong>14\n\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n</p><p><strong>Time Complexity: O(N*N)</strong></p>\n<p>Reason: There are two nested loops</p>\n<p><strong>Space Complexity: O(N)</strong></p>\n<p>Reason: We are using an external array of size \u2018N\u2019 to store only one row.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Minimum Path Sum in a Triangular Grid\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/SrP-PiLSYC0?si=3590c3UD5CC3UdDN\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/SrP-PiLSYC0?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Minimum Path Sum in a Triangular Grid\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/SrP-PiLSYC0?si=3590c3UD5CC3UdDN\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\">Anshuman Sharma</a></strong>&nbsp;<em>and&nbsp;<a href=\"https://www.linkedin.com/in/abhipsita-das-5b7069212/?originalSubdomain=in\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Abhipsita Das</strong></a></em></em> <em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->"
}