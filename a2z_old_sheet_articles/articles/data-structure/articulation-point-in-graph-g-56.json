{
    "dislikes": 0,
    "video": "j1QDfU21iZk",
    "publishedOn": "Sun Mar 24 2024 22:11:51 GMT+0530 (India Standard Time)",
    "slug": "articulation-point-in-graph-g-56",
    "aid": "2177",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/articulation-point-in-graph",
    "title": "Articulation Point in Graph: G-56",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 31,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given an undirected connected graph with V vertices and adjacency list adj. You are required to find all the vertices removing which (and edges through it) disconnect the graph i...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given an undirected connected graph with V vertices and adjacency list adj. You are required to find all the vertices removing which (and edges through it) disconnect the graph into 2 or more components.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Note: Indexing is zero-based i.e nodes numbering from (0 to V-1). There might be loops present in the graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-requisite: </strong><a href=\"https://www.youtube.com/watch?v=qrAub5z8FeA&amp;list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&amp;index=55\" target=\"_blank\" rel=\"noopener\" title=\"\"><strong>Bridges in Graph</strong></a> problem &amp; <a href=\"https://takeuforward.org/data-structure/depth-first-search-dfs/\" target=\"_blank\" rel=\"noopener\" title=\"\"><strong>DFS algorithm</strong></a>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-172927.png\" alt=\"\" class=\"wp-image-7145\"/></figure>\n<b>Result:</b> {0, 2}\n<b>Explanation:</b> If we remove node 0 or node 2, the graph will be divided into 2 or more components.\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173024.png\" alt=\"\" class=\"wp-image-7146\"/></figure>\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173133.png\" alt=\"\" class=\"wp-image-7147\"/></figure>\n<b>Result:</b> {1, 4}\n<b>Explanation:</b> If we remove either node 1 or node 4, the graph breaks into multiple components.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/articulation-point-1/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=articulation-point\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem Link</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Before moving on to the solution, we need to understand the definition of the articulation point of a graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Articulation Point:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Articulation Points of a graph are the nodes on whose removal, the graph breaks into multiple components.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7148,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173547.png\" alt=\"\" class=\"wp-image-7148\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>For the above graph node 0 and node, 2 are the articulation points. If we remove either of the two nodes, the graph breaks into multiple components like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7149,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173636.png\" alt=\"\" class=\"wp-image-7149\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>But node 3 is not an articulation point as this node\u2019s removal does not break the graph into multiple components.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In order to find all the articulation points of a graph, we will implement some logic over the DFS algorithm. This is more of an algorithm-based approach. So, let\u2019s discuss the algorithm in detail. Before that, we will discuss the two important concepts of the algorithm i.e. <strong><em>time of insertion and lowest time of insertion.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Time of insertion: </strong>Dring the DFS call, the time when a node is visited, is called its time of insertion. For example, if in the above graph, we start DFS from node 0 it will visit node 1 first then node 2, node 3, and so on. So, the time of insertion for node 0 will be 1, node 1 will be 2, node 2 will be 3 and it will continue like this. <strong><em>We will use a time array to store the insertion time for each node</em></strong>.<br>This definition remains the same as it was during the bridge problem.<br></li><li><strong>Lowest time of insertion: </strong>In this case, the current node refers to all its adjacent nodes <strong><em>except the parent and the visited nodes </em></strong>and takes the minimum lowest time of insertion into account. To store this entity for each node, we will use another \u2018<strong><em>low</em></strong>\u2019 array.<br><strong><em>The difference in finding the lowest time of insertion in this problem is that in the bridgealgorithm, we only excluded the parent node but in this algorithm, we are excluding the visited nodes along with the parent node.</em></strong></li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong><em>The logical modification of the DFS algorithm is discussed below</em></strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>To find out the bridges in the bridge problem, we checked inside the DFS, if there exists any alternative path from the adjacent node to the current node.<br>But here we cannot do so as in this case, we are trying to remove the current node along with all the edges linked to it. For that reason, here we will check if there exists any path from the adjacent node to the previous node of the current node. <strong><em>In addition to that</em></strong>, we must ensure that the current node we are trying to remove must not be the starting node.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">The check conditions for this case will change like the following:<br>if(low[it] &gt; tin[node])&nbsp; converts to if(low[it] &gt;= tin[node] &amp;&amp; parent&nbsp; != -1)&nbsp;</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>For the starting node, we will apply different logic.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>The logic for the starting node:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If the node is a starting point we will check the number of children of the node. If the starting node has more than 1 child(The children must not be connected), it will definitely be one of the articulation points.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>To find the number of children, we will generally count the number of adjacent nodes. But there is a point to notice. In the following graph, the starting node 0 has two adjacent nodes, but it is not an articulation point.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7150,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173858.png\" alt=\"\" class=\"wp-image-7150\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>To avoid this edge case, we will increment the number of children only if the adjacent node is not previously visited(<em>i.e. child++ will be inside the not visited if statement</em>).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>We can get a single node as an articulation point multiple times:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If we carefully observe, we can easily notice that we can get a single node as the articulation point multiple times. For example, consider the following graph:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7151,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-173950.png\" alt=\"\" class=\"wp-image-7151\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>While checking for node 2, we will get the node as the articulation point once for the first component that contains nodes 4, 5, and 6 and we will again get the same node 2 for the second component that includes the nodes 7, 8, and 9.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><em>To avoid the storing of duplicate nodes, we will store the nodes in a hash array(i.e. mark array used in the code) instead of directly inserting them in a simple array.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Approach</strong>:&nbsp;</h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First, we need to create the adjacency list for the given graph from the edge information(<strong><em>If not already given</em></strong>). And we will declare a variable timer(either globally or we can carry it while calling DFS), that will keep track of the time of insertion for each node. The timer may be initialized to 0 or 1 accordingly.</li><li>Then we will perform DFS for each component. For each component, the starting node will carry -1 as its parent.<ol><li>Inside DFS, we will first mark the node visited and then store the time of insertion and the lowest time of insertion properly. We will declare a child variable to implement the logic for starting node.</li><li>Now, it\u2019s time to visit the adjacent nodes.&nbsp;<ol><li><strong><em>If the adjacent node is the parent itself</em></strong>, we will just continue to the next node.</li><li><strong><em>If the adjacent node is not visited</em></strong>, we will call DFS for the adjacent node with the current node as the parent.<br>After the DFS gets completed, we will compare the lowest time of insertion of the current node and the adjacent node and take the minimum.<br>Now, we will check if the lowest time of insertion of the adjacent node is greater or equal to the time of insertion of the current node and also ensure that the current node is not the starting node(checking parent not equal -1).<br>If the condition matches, then we will mark the current node in our hash array as one of our answers as it is one of the articulation points of the graph.<br>Then we will increment the child variable by 1.</li><li><strong><em>If the adjacent node is visited</em></strong>, we will just compare the lowest time of insertion of the current node and the time of insertion of the adjacent node and take the minimum.</li></ol></li><li>Finally, we will check if the child value is greater than 1 and if the current node is the starting node. If it is then we will keep the starting node marked in our hash array as the starting node is also an articulation point in this case.</li></ol></li><li>Finally, our answer array will store all the bridges.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>We are not considering the parent and the visited nodes during calculating the lowest insertion time as they may be the articulation points of the graph which means they may be the nodes we intend to remove.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//User function Template for C++\n\nclass Solution {\nprivate:\n    int timer = 1;\n    void dfs(int node, int parent, vector&lt;int&gt; &amp;vis, int tin[], int low[],\n             vector&lt;int&gt; &amp;mark, vector&lt;int&gt;adj[]) {\n        vis[node] = 1;\n        tin[node] = low[node] = timer;\n        timer++;\n        int child = 0;\n        for (auto it : adj[node]) {\n            if (it == parent) continue;\n            if (!vis[it]) {\n                dfs(it, node, vis, tin, low, mark, adj);\n                low[node] = min(low[node], low[it]);\n                if (low[it] &gt;= tin[node] &amp;&amp; parent != -1) {\n                    mark[node] = 1;\n                }\n                child++;\n            }\n            else {\n                low[node] = min(low[node], tin[it]);\n            }\n        }\n        if (child &gt; 1 &amp;&amp; parent == -1) {\n            mark[node] = 1;\n        }\n    }\npublic:\n    vector&lt;int&gt; articulationPoints(int n, vector&lt;int&gt;adj[]) {\n        vector&lt;int&gt; vis(n, 0);\n        int tin[n];\n        int low[n];\n        vector&lt;int&gt; mark(n, 0);\n        for (int i = 0; i &lt; n; i++) {\n            if (!vis[i]) {\n                dfs(i, -1, vis, tin, low, mark, adj);\n            }\n        }\n        vector&lt;int&gt; ans;\n        for (int i = 0; i &lt; n; i++) {\n            if (mark[i] == 1) {\n                ans.push_back(i);\n            }\n        }\n        if (ans.size() == 0) return { -1};\n        return ans;\n    }\n};\nint main() {\n\n    int n = 5;\n    vector&lt;vector&lt;int&gt;&gt; edges = {\n        {0, 1}, {1, 4},\n        {2, 4}, {2, 3}, {3, 4}\n    };\n\n    vector&lt;int&gt; adj[n];\n    for (auto it : edges) {\n        int u = it[0], v = it[1];\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    Solution obj;\n    vector&lt;int&gt; nodes = obj.articulationPoints(n, adj);\n    for (auto node : nodes) {\n        cout &lt;&lt; node &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 1 4 (Example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+2E), where V = no. of vertices, E = no. of edges. It is because the algorithm is just a simple DFS traversal.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(3V), where V = no. of vertices. O(3V) is for the three arrays i.e. tin, low, and vis, each of size V.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\n\n\n\nclass Solution {\n    private int timer = 1;\n    private void dfs(int node, int parent, int[] vis,\n                     int tin[], int low[], int[] mark,\n                     ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {\n        vis[node] = 1;\n        tin[node] = low[node] = timer;\n        timer++;\n        int child = 0;\n        for (Integer it : adj.get(node)) {\n            if (it == parent) continue;\n            if (vis[it] == 0) {\n                dfs(it, node, vis, tin, low, mark, adj);\n                low[node] = Math.min(low[node], low[it]);\n                // node --- it\n                if (low[it] &gt;= tin[node] &amp;&amp; parent != -1) {\n                    mark[node] = 1;\n                }\n                child++;\n            } else {\n                low[node] = Math.min(low[node], tin[it]);\n            }\n        }\n        if (child &gt; 1 &amp;&amp; parent == -1) {\n            mark[node] = 1;\n        }\n    }\n    //Function to return Breadth First Traversal of given graph.\n    public ArrayList&lt;Integer&gt; articulationPoints(int n,\n            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {\n        int[] vis = new int[n];\n        int[] tin = new int[n];\n        int[] low = new int[n];\n        int[] mark = new int[n];\n        for (int i = 0; i &lt; n; i++) {\n            if (vis[i] == 0) {\n                dfs(i, -1, vis, tin, low, mark, adj);\n            }\n        }\n        ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            if (mark[i] == 1) {\n                ans.add(i);\n            }\n        }\n        if (ans.size() == 0) {\n            ans.add(-1);\n        }\n        return ans;\n    }\n}\n\nclass Main {\n    public static void main (String[] args) {\n        int n = 5;\n        int[][] edges = {\n            {0, 1}, {1, 4},\n            {2, 4}, {2, 3}, {3, 4}\n        };\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            adj.add(new ArrayList&lt;Integer&gt;());\n        }\n        for (int i = 0; i &lt; n; i++) {\n            int u = edges[i][0], v = edges[i][1];\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        Solution obj = new Solution();\n        ArrayList&lt;Integer&gt; nodes = obj.articulationPoints(n, adj);\n\n        int size = nodes.size();\n        for (int i = 0; i &lt; size; i++) {\n            int node = nodes.get(i);\n            System.out.print(node + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 1 4 (Example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+2E), where V = no. of vertices, E = no. of edges. It is because the algorithm is just a simple DFS traversal.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(3V), where V = no. of vertices. O(3V) is for the three arrays i.e. tin, low, and vis, each of size V.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}