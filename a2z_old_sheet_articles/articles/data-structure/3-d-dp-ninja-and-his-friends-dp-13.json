{
    "dislikes": 4,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:10:03 GMT+0530 (India Standard Time)",
    "slug": "3-d-dp-ninja-and-his-friends-dp-13",
    "aid": "1659",
    "title": "3-d DP : Ninja and his friends (DP-13)",
    "tuf_plus": "",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p>In this article, we will solve the most asked coding interview problem: Ninja and his friends.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Link: </strong><a href=\"https://www.codingninjas.com/codestudio/problems/ninja-and-his-friends_3125885?source=youtube&amp;campaign=striver_dp_videos&amp;utm_source=youtube&amp;utm_medium=affiliate&amp;utm_campaign=striver_dp_videos&amp;leftPanelTab=0\"><strong>Ninja and his friends</strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Description:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given an \u2018N*M\u2019 matrix. Every cell of the matrix has some chocolates on it, mat[i][j] gives us the number of chocolates. We have two friends \u2018Alice\u2019 and \u2018Bob\u2019. initially, Alice is standing on the cell(0,0) and Bob is standing on the cell(0, M-1). Both of them can move only to the cells below them in these three directions: to the bottom cell (\u2193), to the bottom-right cell(\u2198), or to the bottom-left cell(\u2199).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>When Alica and Bob visit a cell, they take all the chocolates from that cell with them. It can happen that they visit the same cell, in that case, the chocolates need to be considered only once.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>They cannot go out of the boundary of the given matrix, we need to return the maximum number of chocolates that Bob and Alice can <strong>together</strong> collect.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example:</strong>\n\n<img width=\"624\" height=\"351\" src=\"https://lh3.googleusercontent.com/JiIDR22M61hC2OvoVWPERuECB7RqmlqHr8SGPy6jmMWaM3cKx0n9NhWC9TbMflcD-TRbuXQwq8X3YVyPYmnX02sHlU0qbXWIQDbmQiGzQekgswb1D4LGvLvTsrvd6bmwdb7C7Pi8\"></pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/chocolate-pickup_3125885?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nMemorization approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nTabulation approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nSpace Optimization\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemorization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<p>In this question, there are two fixed starting and variable ending points, but as per the movement of Alice and Bob, we know that they will end in the last row. They have to move together at a time to the next row.</p>\n<p><strong>Why a Greedy Solution doesn\u2019t work?</strong></p>\n<p>As we have to return the <strong>maximum</strong> chocolates collected, the first approach that comes to our mind is to take a greedy approach and always form a path by locally choosing the option that gives us more chocolates. But there is no <strong>\u2018uniformity\u2019 </strong>in the values of the matrix, therefore it can happen that whenever we are making a local choice that gives us a better path, we actually take a path that in the later stages is giving us fewer chocolates.</p>\n<p>As a greedy solution doesn\u2019t work, our next choice will be to try out all the possible paths. To generate all possible paths we will use <strong>recursion</strong>.</p>\n<p><strong>Steps to form the recursive solution:&nbsp;</strong></p>\n<p>We will first form the recursive solution by the three points mentioned in <a href=\"https://takeuforward.org/data-structure/dynamic-programming-introduction/\">Dynamic Programming Introduction</a>.&nbsp;</p>\n<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>\n<p>This question is slightly different from all the previous questions, here we are given two starting points from where Alice and Bob can move.</p>\n<p>We are given an \u2018N*M\u2019 matrix. We need to define the function with four parameters&nbsp; i1,j1,i2, and j2 to describe the positions of Alice and Bob at a time.</p>\n<p><img width=\"624\" height=\"357\" src=\"https://lh4.googleusercontent.com/jDE5ItGBCKfSwzNQ4irRgi470jg82Rg4-AISwsQZc-nOipVlZdyhP9wUEy9TRw0SwUlSIs9T1a-hSWQpjz6s8xFV9YA_Nj4sIj-u9hzVLVZeDnB4yNB0Iks4TnfrvuhGnwQ7MJTg\"></p>\n<p>If we observe, initially Alice and Bob are at the first row, and they always move to the row below them every time, so they will always be in the same row. Therefore two different variables i1 and i2, to describe their positions are redundant. We can just use single parameter i, which tells us in which row of the grid both of them are.</p>\n<p>Therefore, we can modify the function. It now takes three parameters: i,j1, and j2. f(i,j1,j2) will give us the maximum number of chocolates collected by Alice and Bob from their current positions to the last position.</p>\n<p><img width=\"624\" height=\"109\" src=\"https://lh6.googleusercontent.com/5lA81LP9vBhOFOxmUyqGKeAoW2raSsGw1oomYGYYycQ4T1dXILS_2jLaXFgBiwQfvfokVlguqG3F53AbXgrkNiiZ0NHyF3mAGUT9kfdLYYO_CzXwnbPABIqazEK6EC_X80U-uC9F\"></p>\n<p><strong>Base Case:</strong></p>\n<p>There will be the following base cases:</p>\n<ul><li>When i == N-1, it means we are at the last row, so we need to return from here. Now it can happen that at the last row, both Alice and Bob are at the same cell, in this condition we will return only chocolates collected by Alice, mat[i][j1]( as question states that the chocolates cannot be doubly calculated), otherwise we return sum of chocolates collected by both, mat[i][j1] + mat[i][j1][j2].</li></ul>\n<p>At every cell, we have three options to go: to the bottom cell (\u2193), to the bottom-right cell(\u2198) or to the bottom-left cell(\u2199)</p>\n<p>As we are moving to the bottom cell (\u2193), at max we will reach the last row, from where we return, so we will never go out of the bounding index.</p>\n<p>To move to the bottom-right cell(\u2198) or to the bottom-left cell(\u2199), it can happen that we may go out of bound as shown in the figure(below). So we need to handle it, we can return -1e9, whenever we go out of bound, in this way this path will not be selected by the calling function as we have to return the maximum chocolates.</p>\n<p><img width=\"624\" height=\"351\" src=\"https://lh5.googleusercontent.com/ThkWCLSug6TcEIvYR0Yzi0ux10nC-Q0EXo0X4U8hPdkxeISMGYNRbR1KnFdpEZKBj_38Tx8jj5xWZRcUVYrorkjK-ioyiJ2ugZeokFq_YmeAhohzNahZXhwmZNgotG7fxlf6RVYE\"></p>\n<ul><li>If j1&lt;0 or j1&gt;=M or j2&lt;0 or j2&gt;=M&nbsp; , then we return -1e9&nbsp;</li></ul>\n<p>The pseudocode till this step will be:</p>\n<p><img width=\"471\" height=\"407\" src=\"https://lh6.googleusercontent.com/DmfWR7q4DfXaK5bbF0YBSj2CGqZZ8Xa4y5CLNq6aBO1Ve1-czNkSDWClkCraj2PWd1vgoeqYgAfSNHKqQP9_Icr4daBvR_P26XdyrDJaos0Y47lALH-V8qytFNV9xabF3qEq6Y68\"></p>\n<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>\n<p>At every cell, we have three options to go: to the bottom cell (\u2193), to the bottom-right cell(\u2198) or to the bottom-left cell(\u2199)</p>\n<p>Now, we need to understand that we want to move Alice and Bob together. Both of them can individually move three moves but say Alice moves to bottom-left, then Bob can have three different moves for Alice\u2019s move, and so on. The following figures will help to understand this:</p>\n<p><img width=\"624\" height=\"351\" src=\"https://lh6.googleusercontent.com/OHTGseWSSfPmxIsyDBBm1ILc7L4LIzkkCL6N82DfhGmc71nHPI1OcocpIwunkSO-tWnBz-4d1lQ0AWnYum2tFtLCUnJYIt_t1UfffQS-bdJ8MnTuOTpJbqAhEQnKozztVeqJFFax\"></p>\n<p>Hence we have a total of 9 different options at every f(i,j1,j2) to move Alice and Bob. Now we can manually write these 9 options or we can observe a pattern in them, first Alice moves to one side and Bob tries all three choices, then again Alice moves, then Bob, and so on. This pattern can be easily captured by using two nested loops that change the column numbers(j1 and j2).</p>\n<p><strong>Note: </strong>if (j1===j2), as discussed in the base case, we will only consider chocolates collected by one of them otherwise we will consider chocolates collected by both of them.</p>\n<p><img width=\"561\" height=\"631\" src=\"https://lh5.googleusercontent.com/sWCNCbtzmnlWGNQs9lvArxyRDDdMWeE4BAg1GIPSp8JJy5hTql1VDpZv6QA0BuyC7L8iPuA8IVgm-BZ6LZzv-dTS3TZ4AUVu0fNfrVLOSWnXbKaIQig7JI6ESHRGCkJFO3e5u9nl\"></p>\n<p><strong>Step 3:&nbsp; Take the maximum of all choices</strong></p>\n<p>As we have to find the<strong> maximum chocolates collected</strong> of<strong> </strong>all the possible paths, we will return the <strong>maximum</strong> of all the choices(the 9 choices of step 2). We will take a maxi variable( initialized to INT_MIN). We will update maxi to the maximum of the previous maxi and the answer of the current choice. At last, we will return maxi from our function as the answer.</p>\n<p>The final pseudocode after steps 1, 2, and 3:</p>\n<p><img width=\"549\" height=\"715\" src=\"https://lh4.googleusercontent.com/7aYfjlF_ObESYKWa2Qp8L2qyNvS6gFM5dZTjp8qcxzj-MJNdDsj_zcdTW_j3ZxjvyAogREQw2JTeFaMbklFglu3i4eaj5Ars-p7ddbdKHPtkjNsK2N2U01R_dOlknRblMttKluQS\"></p>\n<p><strong>Steps to memoize a recursive solution:</strong></p>\n<p>Before moving to the memoization steps, we need to understand the dp array we are taking. The recursive function has three parameters: i,j1, and j2. Therefore, we will also need to take a 3D DP Array. Its dimensions will be [N][M][M] because when we are moving, i can go from 0 to N-1, and j1 and j2 can go from 0 to M-1.</p>\n<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>\n<ol><li>Create a dp array of size [N][M][M], initialized to -1.</li><li>Whenever we want to find the answer of a particular row and column (say f(i,j1,j2)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j1][j2]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given values for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j1][j2] to the solution we get.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the maximum chocolates that can be collected recursively\nint maxChocoUtil(int i, int j1, int j2, int n, int m, vector&lt;vector&lt;int&gt;&gt; &amp;grid, vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; &amp;dp) {\n    // Check if the positions (j1, j2) are valid\n    if (j1 &lt; 0 || j1 &gt;= m || j2 &lt; 0 || j2 &gt;= m)\n        return -1e9; // A very large negative value to represent an invalid position\n\n    // Base case: If we are at the last row, return the chocolate at the positions (j1, j2)\n    if (i == n - 1) {\n        if (j1 == j2)\n            return grid[i][j1];\n        else\n            return grid[i][j1] + grid[i][j2];\n    }\n\n    // If the result for this state is already computed, return it\n    if (dp[i][j1][j2] != -1)\n        return dp[i][j1][j2];\n\n    int maxi = INT_MIN;\n    \n    // Try all possible moves (up, left, right) for both positions (j1, j2)\n    for (int di = -1; di &lt;= 1; di++) {\n        for (int dj = -1; dj &lt;= 1; dj++) {\n            int ans;\n            \n            if (j1 == j2)\n                ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n            else\n                ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n            \n            // Update the maximum result\n            maxi = max(maxi, ans);\n        }\n    }\n    \n    // Store the maximum result for this state in dp\n    return dp[i][j1][j2] = maxi;\n}\n\n// Function to find the maximum chocolates that can be collected\nint maximumChocolates(int n, int m, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    // Create a 3D DP array to store computed results\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(m, -1)));\n\n    // Call the recursive utility function to find the maximum chocolates starting from the first row\n    return maxChocoUtil(0, 0, m - 1, n, m, grid, dp);\n}\n\nint main() {\n    // Define the grid as a 2D vector\n    vector&lt;vector&lt;int&gt;&gt; matrix{\n        {2, 3, 1, 2},\n        {3, 4, 2, 2},\n        {5, 6, 3, 5},\n    };\n\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    // Call the maximumChocolates function and print the result\n    cout &lt;&lt; maximumChocolates(n, m, matrix);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Function to find the maximum number of chocolates using dynamic programming\n  static int maxChocoUtil(int i, int j1, int j2, int n, int m, int[][] grid,\n                          int[][][] dp) {\n    // Check if j1 and j2 are valid column indices\n    if (j1 &lt; 0 || j1 &gt;= m || j2 &lt; 0 || j2 &gt;= m)\n      return (int) (Math.pow(-10, 9));\n\n    // If we are at the last row, return the sum of chocolates in the selected columns\n    if (i == n - 1) {\n      if (j1 == j2)\n        return grid[i][j1];\n      else\n        return grid[i][j1] + grid[i][j2];\n    }\n\n    // If the result for this state is already computed, return it\n    if (dp[i][j1][j2] != -1)\n      return dp[i][j1][j2];\n\n    int maxi = Integer.MIN_VALUE;\n    // Iterate through possible moves in the next row\n    for (int di = -1; di &lt;= 1; di++) {\n      for (int dj = -1; dj &lt;= 1; dj++) {\n        int ans;\n        // If j1 and j2 are the same, add chocolates from grid[i][j1] only\n        if (j1 == j2)\n          ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n        else\n          // Add chocolates from both j1 and j2\n          ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n        // Update maxi with the maximum result\n        maxi = Math.max(maxi, ans);\n      }\n    }\n    // Store the result in the dp array and return it\n    return dp[i][j1][j2] = maxi;\n  }\n\n  // Function to find the maximum number of chocolates\n  static int maximumChocolates(int n, int m, int[][] grid) {\n    // Create a 3D array to store computed results\n    int dp[][][] = new int[n][m][m];\n\n    // Initialize the dp array with -1\n    for (int row1[][] : dp) {\n      for (int row2[] : row1) {\n        Arrays.fill(row2, -1);\n      }\n    }\n\n    // Call the utility function to find the maximum number of chocolates\n    return maxChocoUtil(0, 0, m - 1, n, m, grid, dp);\n  }\n\n  public static void main(String args[]) {\n    int matrix[][] = {{2, 3, 1, 2},\n                      {3, 4, 2, 2},\n                      {5, 6, 3, 5}};\n    int n = matrix.length;\n    int m = matrix[0].length;\n\n    // Call the maximumChocolates function and print the result\n    System.out.println(maximumChocolates(n, m, matrix));\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nimport sys\n\n# Recursive function to find the maximum chocolates collected\ndef maxChocoUtil(i, j1, j2, n, m, grid, dp):\n    # Base cases:\n    # - If either of the indices is out of bounds, return a large negative value\n    # - If we're at the last row, return the sum of chocolates in the two selected columns\n    if j1 &lt; 0 or j1 &gt;= m or j2 &lt; 0 or j2 &gt;= m:\n        return int(-1e9)\n    if i == n - 1:\n        if j1 == j2:\n            return grid[i][j1]\n        else:\n            return grid[i][j1] + grid[i][j2]\n    \n    # If the result for these indices has already been computed, return it\n    if dp[i][j1][j2] != -1:\n        return dp[i][j1][j2]\n    \n    # Initialize the maximum chocolates collected to a large negative value\n    maxi = -sys.maxsize\n    \n    # Iterate through the adjacent cells in the next row\n    for di in range(-1, 2):\n        for dj in range(-1, 2):\n            ans = 0\n            if j1 == j2:\n                ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            else:\n                ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp)\n            maxi = max(maxi, ans)\n    \n    # Store the maximum chocolates collected in the memoization table\n    dp[i][j1][j2] = maxi\n    return maxi\n\n# Function to find the maximum chocolates collected\ndef maximumChocolates(n, m, grid):\n    # Initialize a memoization table with -1 values\n    dp = [[[-1 for j in range(m)] for i in range(m)] for k in range(n)]\n    \n    # Start the recursion from the first row, columns 0 and m-1\n    return maxChocoUtil(0, 0, m - 1, n, m, grid, dp)\n\ndef main():\n    # Define the input matrix and its dimensions\n    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]\n    n = len(matrix)\n    m = len(matrix[0])\n    \n    # Call the maximumChocolates function and print the result\n    print(maximumChocolates(n, m, matrix))\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction maxChocoUtil(i, j1, j2, n, m, grid, dp) {\n  // Check if the indices are out of bounds\n  if (j1 &lt; 0 || j1 &gt;= m || j2 &lt; 0 || j2 &gt;= m) {\n    return -1e9; // A very large negative value for invalid states\n  }\n\n  // Base case: if we are at the last row\n  if (i == n - 1) {\n    // If both indices are the same, return the value at that position\n    if (j1 == j2) {\n      return grid[i][j1];\n    } else {\n      // If the indices are different, return the sum of values at both positions\n      return grid[i][j1] + grid[i][j2];\n    }\n  }\n\n  // If the result for this state is already computed, return it\n  if (dp[i][j1][j2] != -1) {\n    return dp[i][j1][j2];\n  }\n\n  let maxi = Number.MIN_SAFE_INTEGER; // Initialize the maximum value to a very small number\n\n  // Iterate through neighboring positions\n  for (let di = -1; di &lt;= 1; di++) {\n    for (let dj = -1; dj &lt;= 1; dj++) {\n      let ans;\n      if (j1 == j2) {\n        ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n      } else {\n        ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);\n      }\n      // Update the maximum value\n      maxi = Math.max(maxi, ans);\n    }\n  }\n\n  // Store the maximum value in the dp array and return it\n  dp[i][j1][j2] = maxi;\n  return maxi;\n}\n\nfunction maximumChocolates(n, m, grid) {\n  // Initialize a 3D dp array with -1 values\n  const dp = new Array(n).fill(null).map(() =&gt;\n    new Array(m).fill(null).map(() =&gt;\n      new Array(m).fill(-1)\n    )\n  );\n\n  // Call the recursive utility function to find the maximum chocolates\n  return maxChocoUtil(0, 0, m - 1, n, m, grid, dp);\n}\n\nfunction main() {\n  const matrix = [\n    [2, 3, 1, 2],\n    [3, 4, 2, 2],\n    [5, 6, 3, 5]\n  ];\n\n  const n = matrix.length;\n  const m = matrix[0].length;\n\n  console.log(maximumChocolates(n, m, matrix));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Brute Force Here -->\n</p><p><strong>Output:</strong> 21\n\n</p>\n<p></p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n</p><p><strong>Time Complexity: O(N*M*M) * 9</strong></p>\n<p>Reason: At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.</p>\n<p><strong>Space Complexity: O(N) + O(N*M*M)</strong></p>\n<p>Reason: We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size \u2018N*M*M\u2019.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<p><strong>Steps to convert Recursive Solution to Tabulation one.</strong></p>\n<p>For the tabulation approach, it is better to understand what a cell in the 3D DP array means. As we had done in memoization, we will initialize a dp[] array of size [N][M][M].</p>\n<p>So now, when we say dp[2][0][3], what does it mean? It means that we are getting the value of the maximum chocolates collected by Alice and Bob, when Alice is at (2,0) and Bob is at (2,3).</p>\n<p>The below figure gives us a bit more clarity.</p>\n<p><img width=\"624\" height=\"351\" src=\"https://lh5.googleusercontent.com/ULGx32qDnlYn45io6EGzS3Zmdx0AgXlCqgF1Ytewcv8zKJP2hLelzaq-LgN_zilurvhijSVBUlIXulcjU2IgbYvdPG81ylKrMd7xzmogUXqJZlCjIMcRBTXqr27ROmoAJKCsQv1y\"></p>\n<p>Next, we need to initialize the base value conditions. In the recursive code, our base condition is when we reach the last row, therefore in our dp array, we will also initialize dp[n-1][][], i.e (the last plane of 3D Array) as the base condition. Dp[n-1][j1][j2] means Alice is at (n-1,j1) and Bob is at (n-1,j2). As this is the last row, its value will be equal to mat[i][j1], if (j1==j2) and mat[i][j1] + mat[i][j2] otherwise.</p>\n<p>Once we have filled the last plane, we can move to the second-last plane and so on, we will need three nested loops to do this traversal.</p>\n<p>The steps to convert to the tabular solution are given below:</p>\n<ul><li>Declare a dp[] array of size [N][M][M]</li><li>First, initialize the base condition values as explained above.</li><li>We will then move from dp[n-2][][] to dp[0][][]. We will set three nested loops to do this traversal.</li><li>Inside the three nested loops( say i,j1,j2 as loop variables), we will use the recursive relations, i.e we will again set two nested loops to try all the nine options.</li><li>The outer three loops are just for traversal, and the inner two loops that run for 9 times mainly decide, what should be the value of the cell. If you are getting confused, please see the code.</li><li>Inside the inner two nested loops, we will calculate an answer as we had done in the recursive relation, but this time using values from the next plane of the 3D DP Array( dp[i+1][x][y] instead of recursive calls, where x and y will vary according to inner 2 nested loops).</li><li>At last, we will set dp[i][j1][j2] as the maximum of all the 9 options.</li><li>After the outer three nested loops iteration has ended, we will return dp[0][0][m-1] as our answer.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the maximum chocolates that can be collected\nint maximumChocolates(int n, int m, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    // Create a 3D DP array to store computed results\n    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp(n, vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(m, 0)));\n\n    // Initialize the DP array for the last row\n    for (int j1 = 0; j1 &lt; m; j1++) {\n        for (int j2 = 0; j2 &lt; m; j2++) {\n            if (j1 == j2)\n                dp[n - 1][j1][j2] = grid[n - 1][j1];\n            else\n                dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n        }\n    }\n\n    // Outer nested loops for traversing the DP array from the second-to-last row up to the first row\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j1 = 0; j1 &lt; m; j1++) {\n            for (int j2 = 0; j2 &lt; m; j2++) {\n                int maxi = INT_MIN;\n\n                // Inner nested loops to try out 9 options (diagonal moves)\n                for (int di = -1; di &lt;= 1; di++) {\n                    for (int dj = -1; dj &lt;= 1; dj++) {\n                        int ans;\n\n                        if (j1 == j2)\n                            ans = grid[i][j1];\n                        else\n                            ans = grid[i][j1] + grid[i][j2];\n\n                        // Check if the move is valid (within the grid boundaries)\n                        if ((j1 + di &lt; 0 || j1 + di &gt;= m) || (j2 + dj &lt; 0 || j2 + dj &gt;= m))\n                            ans += -1e9; // A very large negative value to represent an invalid move\n                        else\n                            ans += dp[i + 1][j1 + di][j2 + dj]; // Include the DP result from the next row\n\n                        maxi = max(ans, maxi); // Update the maximum result\n                    }\n                }\n                dp[i][j1][j2] = maxi; // Store the maximum result for this state in the DP array\n            }\n        }\n    }\n\n    // The maximum chocolates that can be collected is stored at the top-left corner of the DP array\n    return dp[0][0][m - 1];\n}\n\nint main() {\n    // Define the grid as a 2D vector\n    vector&lt;vector&lt;int&gt;&gt; matrix{\n        {2, 3, 1, 2},\n        {3, 4, 2, 2},\n        {5, 6, 3, 5},\n    };\n\n    int n = matrix.size(); // Number of rows\n    int m = matrix[0].size(); // Number of columns\n\n    // Call the maximumChocolates function and print the result\n    cout &lt;&lt; maximumChocolates(n, m, matrix);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Function to find the maximum number of chocolates using dynamic programming\n  static int maximumChocolates(int n, int m, int[][] grid) {\n    // Create a 3D array to store computed results\n    int dp[][][] = new int[n][m][m];\n\n    // Initialize the dp array with values from the last row of the grid\n    for (int j1 = 0; j1 &lt; m; j1++) {\n      for (int j2 = 0; j2 &lt; m; j2++) {\n        if (j1 == j2)\n          dp[n - 1][j1][j2] = grid[n - 1][j1];\n        else\n          dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n      }\n    }\n\n    // Outer nested loops to traverse the DP array from the second last row to the first row\n    for (int i = n - 2; i &gt;= 0; i--) {\n      for (int j1 = 0; j1 &lt; m; j1++) {\n        for (int j2 = 0; j2 &lt; m; j2++) {\n          int maxi = Integer.MIN_VALUE;\n\n          // Inner nested loops to try out 9 options\n          for (int di = -1; di &lt;= 1; di++) {\n            for (int dj = -1; dj &lt;= 1; dj++) {\n              int ans;\n\n              if (j1 == j2)\n                ans = grid[i][j1];\n              else\n                ans = grid[i][j1] + grid[i][j2];\n\n              // Check if the indices are valid\n              if ((j1 + di &lt; 0 || j1 + di &gt;= m) || (j2 + dj &lt; 0 || j2 + dj &gt;= m))\n                ans += (int) Math.pow(-10, 9);\n              else\n                ans += dp[i + 1][j1 + di][j2 + dj];\n\n              // Update maxi with the maximum result\n              maxi = Math.max(ans, maxi);\n            }\n          }\n          // Store the result in the dp array\n          dp[i][j1][j2] = maxi;\n        }\n      }\n    }\n\n    // The final result is stored at the top row (first row) of the dp array\n    return dp[0][0][m - 1];\n  }\n\n  public static void main(String args[]) {\n    int matrix[][] = {{2, 3, 1, 2},\n                      {3, 4, 2, 2},\n                      {5, 6, 3, 5}};\n    int n = matrix.length;\n    int m = matrix[0].length;\n\n    // Call the maximumChocolates function and print the result\n    System.out.println(maximumChocolates(n, m, matrix));\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nimport sys\n\n# Function to find the maximum chocolates collected\ndef maximumChocolates(n, m, grid):\n    # Initialize a 3D memoization table dp with zeros\n    dp = [[[0 for _ in range(m)] for _ in range(m)] for _ in range(n)]\n\n    # Initialize the values for the last row of dp based on grid values\n    for j1 in range(m):\n        for j2 in range(m):\n            if j1 == j2:\n                dp[n - 1][j1][j2] = grid[n - 1][j1]\n            else:\n                dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2]\n\n    # Iterate through rows from the second-to-last row to the first row\n    for i in range(n - 2, -1, -1):\n        for j1 in range(m):\n            for j2 in range(m):\n                maxi = -sys.maxsize\n\n                # Try out 9 possible options by changing the indices\n                for di in range(-1, 2):\n                    for dj in range(-1, 2):\n                        ans = 0\n                        if j1 == j2:\n                            ans = grid[i][j1]\n                        else:\n                            ans = grid[i][j1] + grid[i][j2]\n\n                        if ((j1 + di &lt; 0 or j1 + di &gt;= m) or (j2 + dj &lt; 0 or j2 + dj &gt;= m)):\n                            ans += int(-1e9)  # A large negative value if out of bounds\n                        else:\n                            ans += dp[i + 1][j1 + di][j2 + dj]  # Add the value from the next row\n\n                        maxi = max(ans, maxi)\n\n                # Store the maximum chocolates collected in the memoization table\n                dp[i][j1][j2] = maxi\n\n    # Return the maximum chocolates collected in the top row and the last column\n    return dp[0][0][m - 1]\n\ndef main():\n    # Define the input matrix and its dimensions\n    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # Call the maximumChocolates function and print the result\n    print(maximumChocolates(n, m, matrix))\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction maximumChocolates(n, m, grid) {\n  // Initialize a 3D dp array with zeros\n  const dp = new Array(n).fill(null).map(() =&gt;\n    new Array(m).fill(null).map(() =&gt;\n      new Array(m).fill(0)\n    )\n  );\n\n  // Initialize dp array for the last row based on grid values\n  for (let j1 = 0; j1 &lt; m; j1++) {\n    for (let j2 = 0; j2 &lt; m; j2++) {\n      if (j1 === j2) {\n        dp[n - 1][j1][j2] = grid[n - 1][j1];\n      } else {\n        dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n      }\n    }\n  }\n\n  // Iterate through rows in reverse order\n  for (let i = n - 2; i &gt;= 0; i--) {\n    for (let j1 = 0; j1 &lt; m; j1++) {\n      for (let j2 = 0; j2 &lt; m; j2++) {\n        let maxi = Number.MIN_SAFE_INTEGER;\n\n        // Iterate through all possible move combinations\n        for (let di = -1; di &lt;= 1; di++) {\n          for (let dj = -1; dj &lt;= 1; dj++) {\n            let ans;\n\n            if (j1 === j2) {\n              ans = grid[i][j1];\n            } else {\n              ans = grid[i][j1] + grid[i][j2];\n            }\n\n            // Check if the move is valid (within grid bounds)\n            if (\n              j1 + di &gt;= 0 &amp;&amp; j1 + di &lt; m &amp;&amp;\n              j2 + dj &gt;= 0 &amp;&amp; j2 + dj &lt; m\n            ) {\n              ans += dp[i + 1][j1 + di][j2 + dj];\n            } else {\n              ans += -1e9; // A very large negative value for invalid moves\n            }\n\n            maxi = Math.max(ans, maxi);\n          }\n        }\n\n        dp[i][j1][j2] = maxi;\n      }\n    }\n  }\n\n  // The maximum chocolates will be stored in dp[0][0][m - 1]\n  return dp[0][0][m - 1];\n}\n\nfunction main() {\n  const matrix = [\n    [2, 3, 1, 2],\n    [3, 4, 2, 2],\n    [5, 6, 3, 5]\n  ];\n\n  const n = matrix.length;\n  const m = matrix[0].length;\n\n  console.log(maximumChocolates(n, m, matrix));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\n<strong>Output:</strong> 21\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n</p><p><strong>Time Complexity: O(N*M*M)*9</strong></p>\n<p>Reason: The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.</p>\n<p><strong>Space Complexity: O(N*M*M)</strong></p>\n<p>Reason: We are using an external array of size \u2018N*M*M\u2019. The stack space will be eliminated.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nSpace Optimization Approach \n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Better Approach Here -->\n<p>If we look closely, to compute dp[i][j1][j2], we need values only from dp[i+1][][]. Therefore it is not necessary to store a three-dimensional array. Instead, we can store a two-dimensional array and update it as we move from one plane to the other in the 3D Array.</p>\n<p>The Steps to space optimize the tabulation approach are as follows:&nbsp;</p>\n<ul><li>Initially, we can take a dummy 2D Array ( say front). We initialize this 2D Array as we had done in the Tabulation Approach.</li><li>Next, we also initialize a 2D Array( say cur), which we will need in the traversal.</li><li>Now we set our three nested loops to traverse the 3D Array, from the second last plane.</li><li>Following the same approach as we did in the tabulation approach, we find the maximum number of chocolates collected at each cell. To calculate it we have all the values in our \u2018front\u2019 2D Array.</li><li>Previously, we assigned dp[i][j1][j2] to maxi, now we will simply assign cur[j1][j2] to maxi.</li><li>Then whenever the plane of the 3D DP(the first parameter) is going to change, we assign the front to cur.</li></ul>\n<p>At last, we will return front[0][m-1] as our answer.</p>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Function to find the maximum chocolates that can be collected\nint maximumChocolates(int n, int m, vector&lt;vector&lt;int&gt;&gt; &amp;grid) {\n    // Create two 2D vectors 'front' and 'cur' to store computed results\n    vector&lt;vector&lt;int&gt;&gt; front(m, vector&lt;int&gt;(m, 0));\n    vector&lt;vector&lt;int&gt;&gt; cur(m, vector&lt;int&gt;(m, 0));\n\n    // Initialize 'front' for the last row\n    for (int j1 = 0; j1 &lt; m; j1++) {\n        for (int j2 = 0; j2 &lt; m; j2++) {\n            if (j1 == j2)\n                front[j1][j2] = grid[n - 1][j1];\n            else\n                front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n        }\n    }\n\n    // Outer nested loops for traversing the DP array from the second-to-last row up to the first row\n    for (int i = n - 2; i &gt;= 0; i--) {\n        for (int j1 = 0; j1 &lt; m; j1++) {\n            for (int j2 = 0; j2 &lt; m; j2++) {\n                int maxi = INT_MIN;\n\n                // Inner nested loops to try out 9 options (diagonal moves)\n                for (int di = -1; di &lt;= 1; di++) {\n                    for (int dj = -1; dj &lt;= 1; dj++) {\n                        int ans;\n\n                        if (j1 == j2)\n                            ans = grid[i][j1];\n                        else\n                            ans = grid[i][j1] + grid[i][j2];\n\n                        // Check if the move is valid (within the grid boundaries)\n                        if ((j1 + di &lt; 0 || j1 + di &gt;= m) || (j2 + dj &lt; 0 || j2 + dj &gt;= m))\n                            ans += -1e9; // A very large negative value to represent an invalid move\n                        else\n                            ans += front[j1 + di][j2 + dj]; // Include the value from the 'front' array\n\n                        maxi = max(ans, maxi); // Update the maximum result\n                    }\n                }\n                cur[j1][j2] = maxi; // Store the maximum result for this state in the 'cur' array\n            }\n        }\n        front = cur; // Update 'front' with the values from 'cur' for the next iteration\n    }\n\n    // The maximum chocolates that can be collected is stored at the top-left corner of the 'front' array\n    return front[0][m - 1];\n}\n\nint main() {\n    // Define the grid as a 2D vector\n    vector&lt;vector&lt;int&gt;&gt; matrix{\n        {2, 3, 1, 2},\n        {3, 4, 2, 2},\n        {5, 6, 3, 5},\n    };\n\n    int n = matrix.size(); // Number of rows\n    int m = matrix[0].size(); // Number of columns\n\n    // Call the maximumChocolates function and print the result\n    cout &lt;&lt; maximumChocolates(n, m, matrix);\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Function to find the maximum number of chocolates using dynamic programming\n  static int maximumChocolates(int n, int m, int[][] grid) {\n    // Create two 2D arrays to store computed results: front and cur\n    int[][] front = new int[m][m];\n    int[][] cur = new int[m][m];\n\n    // Initialize the front array with values from the last row of the grid\n    for (int j1 = 0; j1 &lt; m; j1++) {\n      for (int j2 = 0; j2 &lt; m; j2++) {\n        if (j1 == j2)\n          front[j1][j2] = grid[n - 1][j1];\n        else\n          front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n      }\n    }\n\n    // Outer nested loops to traverse the DP array from the second last row to the first row\n    for (int i = n - 2; i &gt;= 0; i--) {\n      for (int j1 = 0; j1 &lt; m; j1++) {\n        for (int j2 = 0; j2 &lt; m; j2++) {\n          int maxi = Integer.MIN_VALUE;\n\n          // Inner nested loops to try out 9 options\n          for (int di = -1; di &lt;= 1; di++) {\n            for (int dj = -1; dj &lt;= 1; dj++) {\n              int ans;\n\n              if (j1 == j2)\n                ans = grid[i][j1];\n              else\n                ans = grid[i][j1] + grid[i][j2];\n\n              // Check if the indices are valid\n              if ((j1 + di &lt; 0 || j1 + di &gt;= m) || (j2 + dj &lt; 0 || j2 + dj &gt;= m))\n                ans += (int) Math.pow(-10, 9);\n              else\n                ans += front[j1 + di][j2 + dj];\n\n              // Update maxi with the maximum result\n              maxi = Math.max(ans, maxi);\n            }\n          }\n          // Store the result in the cur array\n          cur[j1][j2] = maxi;\n        }\n      }\n\n      // Update the front array with the values from the cur array for the next row\n      for (int a = 0; a &lt; m; a++) {\n        front[a] = cur[a].clone();\n      }\n    }\n\n    // The final result is stored at the top left corner of the front array\n    return front[0][m - 1];\n  }\n\n  public static void main(String args[]) {\n    int matrix[][] = {{2, 3, 1, 2},\n                      {3, 4, 2, 2},\n                      {5, 6, 3, 5}};\n\n    int n = matrix.length;\n    int m = matrix[0].length;\n\n    // Call the maximumChocolates function and print the result\n    System.out.println(maximumChocolates(n, m, matrix));\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nimport sys\n\n# Function to find the maximum chocolates collected\ndef maximumChocolates(n, m, grid):\n    # Initialize two matrices: front (for the current row) and cur (for the next row)\n    front = [[0] * m for _ in range(m)]\n    cur = [[0] * m for _ in range(m)]\n\n    # Initialize the values for the last row of front based on grid values\n    for j1 in range(m):\n        for j2 in range(m):\n            if j1 == j2:\n                front[j1][j2] = grid[n - 1][j1]\n            else:\n                front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2]\n\n    # Iterate through rows from the second-to-last row to the first row\n    for i in range(n - 2, -1, -1):\n        for j1 in range(m):\n            for j2 in range(m):\n                maxi = -sys.maxsize\n\n                # Try out 9 possible options by changing the indices\n                for di in range(-1, 2):\n                    for dj in range(-1, 2):\n                        ans = 0\n                        if j1 == j2:\n                            ans = grid[i][j1]\n                        else:\n                            ans = grid[i][j1] + grid[i][j2]\n\n                        if ((j1 + di &lt; 0 or j1 + di &gt;= m) or (j2 + dj &lt; 0 or j2 + dj &gt;= m)):\n                            ans += int(-1e9)  # A large negative value if out of bounds\n                        else:\n                            ans += front[j1 + di][j2 + dj]  # Add the value from the current front row\n\n                        maxi = max(ans, maxi)\n                cur[j1][j2] = maxi\n\n        # Update front with the values of cur for the next iteration\n        front = [row[:] for row in cur]\n\n    # Return the maximum chocolates collected in the top-left corner of front\n    return front[0][m - 1]\n\ndef main():\n    # Define the input matrix and its dimensions\n    matrix = [[2, 3, 1, 2], [3, 4, 2, 2], [5, 6, 3, 5]]\n    n = len(matrix)\n    m = len(matrix[0])\n\n    # Call the maximumChocolates function and print the result\n    print(maximumChocolates(n, m, matrix))\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction maximumChocolates(n, m, grid) {\n  // Initialize two 2D arrays: front and cur\n  let front = new Array(m).fill(null).map(() =&gt; new Array(m).fill(0));\n  let cur = new Array(m).fill(null).map(() =&gt; new Array(m).fill(0));\n\n  // Initialize front array for the last row based on grid values\n  for (let j1 = 0; j1 &lt; m; j1++) {\n    for (let j2 = 0; j2 &lt; m; j2++) {\n      if (j1 === j2) {\n        front[j1][j2] = grid[n - 1][j1];\n      } else {\n        front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];\n      }\n    }\n  }\n\n  // Outer nested loops for traversing the DP array\n  for (let i = n - 2; i &gt;= 0; i--) {\n    for (let j1 = 0; j1 &lt; m; j1++) {\n      for (let j2 = 0; j2 &lt; m; j2++) {\n        let maxi = Number.MIN_SAFE_INTEGER;\n\n        // Inner nested loops to try out 9 options\n        for (let di = -1; di &lt;= 1; di++) {\n          for (let dj = -1; dj &lt;= 1; dj++) {\n            let ans;\n\n            if (j1 === j2) {\n              ans = grid[i][j1];\n            } else {\n              ans = grid[i][j1] + grid[i][j2];\n            }\n\n            // Check if the move is valid (within grid bounds)\n            if (\n              j1 + di &gt;= 0 &amp;&amp; j1 + di &lt; m &amp;&amp;\n              j2 + dj &gt;= 0 &amp;&amp; j2 + dj &lt; m\n            ) {\n              ans += front[j1 + di][j2 + dj];\n            } else {\n              ans += -1e9; // A very large negative value for invalid moves\n            }\n\n            maxi = Math.max(ans, maxi);\n          }\n        }\n        cur[j1][j2] = maxi;\n      }\n    }\n    // Update the front array with values from the cur array\n    front = [...cur];\n  }\n\n  // The maximum chocolates will be stored in front[0][m - 1]\n  return front[0][m - 1];\n}\n\nfunction main() {\n  const matrix = [\n    [2, 3, 1, 2],\n    [3, 4, 2, 2],\n    [5, 6, 3, 5]\n  ];\n\n  const n = matrix.length;\n  const m = matrix[0].length;\n\n  console.log(maximumChocolates(n, m, matrix));\n}\n\n// Call the main function to execute the code\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\n<strong>Output:</strong>21\n\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n</p><p><strong>Time Complexity: O(N*M*M)*9</strong></p>\n<p>Reason: The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.</p>\n<p><strong>Space Complexity: O(M*M)</strong></p>\n<p>Reason: We are using an external array of size \u2018M*M\u2019.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Cherry Pickup II\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/QGfn7JeXK54?si=KUpj2kCzQsJByRVK\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/QGfn7JeXK54?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Cherry Pickup II\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/QGfn7JeXK54?si=KUpj2kCzQsJByRVK\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\">Anshuman Sharma</a></strong> <em><em>and&nbsp;<a href=\"https://www.linkedin.com/in/abhipsita-das-5b7069212/?originalSubdomain=in\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Abhipsita Das</strong></a></em></em>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 82,
    "preview": "In this article, we will solve the most asked coding interview problem: Ninja and his friends. Problem Link: Ninja and his friends Problem Description: We are given an \u2018N*M\u2019 matrix. Every cell of t..."
}