{
    "dislikes": 0,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:56 GMT+0530 (India Standard Time)",
    "slug": "construct-a-binary-tree-from-inorder-and-preorder-traversal",
    "aid": "1627",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/construct-a-bt-from-preorder-and-inorder",
    "title": "Construct A Binary Tree from Inorder and Preorder Traversal",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "likes": 61,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given the Preorder and Inorder traversal of a Binary Tree, construct the Unique Binary Tree represented by them. Examples Example 1: Input:Inorder: [40, 20, 50, 10, 60, 30], Preo...",
    "content": "<p><strong>Problem Statement: </strong> Given the Preorder and Inorder traversal of a Binary Tree, construct the Unique Binary Tree represented by them.\n</p>\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Inorder: [40, 20, 50, 10, 60, 30], Preorder: [10, 20, 40, 50, 30, 60]\n\n\t\t\t\t</span>\n\t\t\t\t\n\t\t\t\t<span><strong>Output:</strong></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/Construct-inorder-preorder-image1-RDo70eh3\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Explanation: </strong>The unique Binary Tree hence created has inorder traversal: [40, 20, 50, 10, 60, 30] and preorder traversal: [10, 20, 40, 50, 30, 60].</span>\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t<span><strong>Example 2:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Inorder: [9, 3, 15, 20, 7], Preorder: [3, 9, 20, 15, 7]\n\t\t\t\t</span>\n\t\t\t\t\n\t\t\t\t<span><strong>Output :</strong></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/Construct-inorder-preorder-image2-7y8Vhdnu\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Explanation: </strong> The unique Binary Tree hence created has inorder traversal:[9, 3, 15, 20, 7]and preorder traversal: [3, 9, 20, 15, 7]. </span>\t\t\t\t\n            </pre>\n        </div>\n    </details>\n</div>\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/construct-binary-tree-from-inorder-and-preorder-traversal_920539?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\"\n                alt=\"code-studio\">\n        </a>\n    </div>\n    <!--<div class=\"problem-buttons\">\n         Add Problem Link inside href \n        <a href=\"\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp\"\n                alt=\"leetcode\">\n        </a>\n    </div>-->\n</div>\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\n        yourself first. </em></p>\n\n\n<div id=\"brute-force-approach\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Optimal Approach \n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                </path>\n            </svg>\n        </summary>\n        <div class=\"common-drops\">\n            <details class=\"secondary-details\" open=\"\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Algorithm / Intuition\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"approach-algorithm\">\n                    <!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n                    <p>Before we dive into the algorithm, it's essential to grasp the significance of inorder and preorder traversals. Inorder traversal allows us to identify a node and its left and right subtrees, while preorder traversal ensures we always encounter the root node first. Leveraging these properties, we can uniquely construct a binary tree.\n                    The core of our approach lies in a recursive algorithm that creates one node at a time. We locate this root node in the inorder traversal, which splits the array into the left and right subtrees.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/Construct-inorder-preorder-image3-ajDrqf8u\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    <p>The inorder array keeps getting divided into left and subtrees hence to avoid unnecessary array duplication, we use variables (inStart, inEnd) and (preStart, preEnd) on the inorder and preorder array respectively.\n                    These variables effectively define the boundaries of the current subtree within the original inorder and preorder traversals.\n                    Everytime we encounter the root of a subtree via preorder traversal, we locate its position in the inorder array to get the left and right subtrees.\n                    So to save complexity on the linear look up, we employ a hashmap to store the index of each element in the inorder traversal. This transforms the search operation into a constant-time lookup.</p>\n                    \n                    \n                    <p><strong>Algorithm:</strong></p>\n                    <p><strong>Step 1:</strong>Create an empty map to store the indices of elements in the inorder traversal. Iterate through each element in the inorder traversal and store its index in the map (inMap) using the element as the key and its index as the value.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/Construct-inorder-preorder-image4-slinmr1F\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p><strong>Step 2: </strong>Create a recursive helper function `buildTree` with the following parameters:\n                    <ol><li>Preorder vector</li><li>Start index of preorder (preStart), initially set to 0</li><li>End index of preorder (preEnd), initially set to preorder.size() - 1.</li><li>Inorder vector</li><li>Start index of inorder (inStart), initially set to 0.</li><li>End index of inorder (inEnd), initially set to inorder.size() - 1.</li><li>Map for efficient root index lookup in the inorder traversal.</li></ol></p>                   \n\n                    <p><strong>Step 3: Base Case: </strong>\n                    Check if preStart is greater than preEnd or inStart is greater than inEnd. If true, return NULL, indicating an empty subtree/node.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/Construct-inorder-preorder-image5-GefUXvY5\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                           \n                    <p><strong>Step 4: </strong>\n                    The root node for the current subtree is the first element in the preorder traversal (preorder[preStart]).\n                \tFind the index of this root node in the inorder traversal using the map (inMap[rootValue]). This is the rootIndex. </p>\n                \t<p><strong>Step 5: </strong>\n                    Hence, the left subtree ranges from inStart to rootIndex. Subtracting these indexes gives us the leftSubtreeSize.</p>\n                \t<p><strong>Step 6: </strong>\n                    TMake two recursive calls to buildTree to build the left and right subtrees:\n                    For the left subtree:\n                    <ol><li>Update preStart to preStart + 1 (moving to the next element in preorder)</li><li>Update preEnd to preStart + leftSubtreeSize (end of left subtree in preorder)</li><li>Update inEnd to rootIndex - 1 (end of left subtree in inorder)</li></ol>\n                    For the right subtree:\n                    <ol><li>Update preStart to preStart + leftSubtreeSize + 1 (moving to the next element after the left subtree)</li><li>Update preEnd to the original preEnd (end of right subtree in preorder)</li><li>Update inStart to rootIndex + 1 (start of right subtree in inorder)</li></ol> </p>\n                \t<p><strong>Step 7: </strong>\n                    Return the root node constructed for the current subtree. The function returns the root of the entire binary tree constructed from the preorder and inorder traversals. </p>\n\n                    \n                </div>\n            </details>\n            <details class=\"code-section secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Code\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"code-tabs\">\n                    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                    <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                        </path>\n                    </svg>\n                </div>\n                <div class=\"code-content\">\n                    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\n// TreeNode structure\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to build a binary tree\n    // from preorder and inorder traversals\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder){\n        // Create a map to store indices\n        // of elements in the inorder traversal\n        map&lt;int, int&gt; inMap;\n        \n        // Populate the map with indices\n        // of elements in the inorder traversal\n        for(int i = 0; i &lt; inorder.size(); i++){\n            inMap[inorder[i]] = i;\n        }\n        \n        // Call the private helper function\n        // to recursively build the tree\n        TreeNode* root = buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, inMap);\n        \n        return root;\n    }\n\nprivate:\n    // Recursive helper function to build the tree\n    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, \n            vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, map&lt;int, int&gt;&amp; inMap){\n                // Base case: If the start indices \n                // exceed the end indices, return NULL\n                if(preStart &gt; preEnd || inStart &gt; inEnd){\n                    return NULL;\n                }\n                \n                // Create a new TreeNode with value\n                // at the current preorder index\n                TreeNode* root = new TreeNode(preorder[preStart]);\n                \n                // Find the index of the current root\n                // value in the inorder traversal\n                int inRoot = inMap[root-&gt;val];\n                \n                // Calculate the number of\n                // elements in the left subtree\n                int numsLeft = inRoot - inStart;\n                \n                // Recursively build the left subtree\n                root-&gt;left = buildTree(preorder, preStart + 1, preStart + numsLeft, \n                                inorder, inStart, inRoot - 1, inMap);\n                \n                // Recursively build the right subtree\n                root-&gt;right = buildTree(preorder, preStart + numsLeft + 1, preEnd, \n                                inorder, inRoot + 1, inEnd, inMap);\n                \n                // Return the current root node\n                return root;\n            }\n};\n\n// Function to print the\n// inorder traversal of a tree\nvoid printInorder(TreeNode* root){\n    if(!root){\n        return;\n    }\n    printInorder(root-&gt;left);\n    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;\n    printInorder(root-&gt;right);\n}\n\n// Function to print the \n// given vector\nvoid printVector(vector&lt;int&gt;&amp;vec){\n    for(int i = 0; i &lt; vec.size(); i++){\n        cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n}\n\n\nint main() {\n    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};\n    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};\n    \n    cout &lt;&lt; &quot;Inorder Vector: &quot;;\n    printVector(inorder);\n    \n    cout &lt;&lt; &quot;Preorder Vector: &quot;;\n    printVector(preorder);\n    \n    Solution sol;\n\n    TreeNode* root = sol.buildTree(preorder, inorder);\n    \n    cout &lt;&lt; &quot;Inorder of Unique Binary Tree Created: &quot;&lt;&lt; endl;\n    printInorder(root);\n    cout &lt;&lt; endl;\n\n\n    return 0;\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block \" data-lang=\"java\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"java\" class=\"language-java\">\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Vector;\n\n// TreeNode structure\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n    // Function to build a binary tree\n    // from preorder and inorder traversals\n    public TreeNode buildTree(Vector&lt;Integer&gt; preorder, Vector&lt;Integer&gt; inorder) {\n        // Create a map to store indices\n        // of elements in the inorder traversal\n        Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;();\n\n        // Populate the map with indices\n        // of elements in the inorder traversal\n        for (int i = 0; i &lt; inorder.size(); i++) {\n            inMap.put(inorder.get(i), i);\n        }\n\n        // Call the private helper function\n        // to recursively build the tree\n        TreeNode root = buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, inMap);\n\n        return root;\n    }\n\n    // Recursive helper function to build the tree\n    private TreeNode buildTree(Vector&lt;Integer&gt; preorder, int preStart, int preEnd,\n            Vector&lt;Integer&gt; inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) {\n        // Base case: If the start indices\n        // exceed the end indices, return null\n        if (preStart &gt; preEnd || inStart &gt; inEnd) {\n            return null;\n        }\n\n        // Create a new TreeNode with value\n        // at the current preorder index\n        TreeNode root = new TreeNode(preorder.get(preStart));\n\n        // Find the index of the current root\n        // value in the inorder traversal\n        int inRoot = inMap.get(root.val);\n\n        // Calculate the number of\n        // elements in the left subtree\n        int numsLeft = inRoot - inStart;\n\n        // Recursively build the left subtree\n        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,\n                inorder, inStart, inRoot - 1, inMap);\n\n        // Recursively build the right subtree\n        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,\n                inorder, inRoot + 1, inEnd, inMap);\n\n        // Return the current root node\n        return root;\n    }\n\n    // Function to print the\n    // inorder traversal of a tree\n    private void printInorder(TreeNode root) {\n        if (root != null) {\n            printInorder(root.left);\n            System.out.print(root.val + &quot; &quot;);\n            printInorder(root.right);\n        }\n    }\n\n    // Function to print the\n    // given vector\n    private void printVector(Vector&lt;Integer&gt; vec) {\n        for (int i = 0; i &lt; vec.size(); i++) {\n            System.out.print(vec.get(i) + &quot; &quot;);\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Vector&lt;Integer&gt; inorder = new Vector&lt;&gt;(java.util.Arrays.asList(9, 3, 15, 20, 7));\n        Vector&lt;Integer&gt; preorder = new Vector&lt;&gt;(java.util.Arrays.asList(3, 9, 20, 15, 7));\n\n        System.out.print(&quot;Inorder Vector: &quot;);\n        new Solution().printVector(inorder);\n\n        System.out.print(&quot;Preorder Vector: &quot;);\n        new Solution().printVector(preorder);\n\n        Solution sol = new Solution();\n        TreeNode root = sol.buildTree(preorder, inorder);\n\n        System.out.println(&quot;Inorder of Unique Binary Tree Created:&quot;);\n        sol.printInorder(root);\n        System.out.println();\n    }\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"python\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"python\" class=\"language-python\">\nfrom typing import List\n\n# TreeNode class definition\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:\n        # Create a map to store indices of elements in the inorder traversal\n        inMap = {val: idx for idx, val in enumerate(inorder)}\n        \n        # Call the private helper function to recursively build the tree\n        root = self._buildTree(preorder, 0, len(preorder)-1, inorder, 0, len(inorder)-1, inMap)\n        \n        return root\n\n    def _buildTree(self, preorder, preStart, preEnd, inorder, inStart, inEnd, inMap):\n        # Base case: If the start indices exceed the end indices, return None\n        if preStart &gt; preEnd or inStart &gt; inEnd:\n            return None\n\n        # Create a new TreeNode with value at the current preorder index\n        root = TreeNode(preorder[preStart])\n\n        # Find the index of the current root value in the inorder traversal\n        inRoot = inMap[root.val]\n\n        # Calculate the number of elements in the left subtree\n        numsLeft = inRoot - inStart\n\n        # Recursively build the left subtree\n        root.left = self._buildTree(preorder, preStart + 1, preStart + numsLeft,\n                                    inorder, inStart, inRoot - 1, inMap)\n\n        # Recursively build the right subtree\n        root.right = self._buildTree(preorder, preStart + numsLeft + 1, preEnd,\n                                     inorder, inRoot + 1, inEnd, inMap)\n\n        # Return the current root node\n        return root\n\n# Function to print the inorder traversal of a tree\ndef printInorder(root):\n    if not root:\n        return\n    printInorder(root.left)\n    print(root.val, end=&quot; &quot;)\n    printInorder(root.right)\n\n# Function to print the given list\ndef printList(lst):\n    for val in lst:\n        print(val, end=&quot; &quot;)\n    print()\n\n# Main function\nif __name__ == &quot;__main__&quot;:\n    inorder = [9, 3, 15, 20, 7]\n    preorder = [3, 9, 20, 15, 7]\n    \n    print(&quot;Inorder List: &quot;, end=&quot;&quot;)\n    printList(inorder)\n    \n    print(&quot;Preorder List: &quot;, end=&quot;&quot;)\n    printList(preorder)\n    \n    sol = Solution()\n\n    root = sol.buildTree(preorder, inorder)\n    \n    print(&quot;Inorder of Unique Binary Tree Created:&quot;)\n    printInorder(root)\n    print()\n                           </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// TreeNode structure\nclass TreeNode {\n    constructor(val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to build a binary tree\n    // from preorder and inorder traversals\n    buildTree(preorder, inorder) {\n        // Create a map to store indices\n        // of elements in the inorder traversal\n        const inMap = new Map();\n\n        // Populate the map with indices\n        // of elements in the inorder traversal\n        inorder.forEach((value, index) =&gt; {\n            inMap.set(value, index);\n        });\n\n        // Call the private helper function\n        // to recursively build the tree\n        const root = this.buildTreeHelper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);\n\n        return root;\n    }\n\n    // Recursive helper function to build the tree\n    buildTreeHelper(preorder, preStart, preEnd, inorder, inStart, inEnd, inMap) {\n        // Base case: If the start indices \n        // exceed the end indices, return null\n        if (preStart &gt; preEnd || inStart &gt; inEnd) {\n            return null;\n        }\n\n        // Create a new TreeNode with value\n        // at the current preorder index\n        const root = new TreeNode(preorder[preStart]);\n\n        // Find the index of the current root\n        // value in the inorder traversal\n        const inRoot = inMap.get(root.val);\n\n        // Calculate the number of\n        // elements in the left subtree\n        const numsLeft = inRoot - inStart;\n\n        // Recursively build the left subtree\n        root.left = this.buildTreeHelper(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);\n\n        // Recursively build the right subtree\n        root.right = this.buildTreeHelper(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);\n\n        // Return the current root node\n        return root;\n    }\n}\n\n// Function to print the\n// inorder traversal of a tree\nfunction printInorder(root) {\n    if (!root) {\n        return;\n    }\n    printInorder(root.left);\n    console.log(root.val + &quot; &quot;);\n    printInorder(root.right);\n}\n\n// Function to print the \n// given array\nfunction printArray(arr) {\n    arr.forEach((value) =&gt; {\n        console.log(value + &quot; &quot;);\n    });\n    console.log();\n}\n\n// Main function\nfunction main() {\n    const inorder = [9, 3, 15, 20, 7];\n    const preorder = [3, 9, 20, 15, 7];\n\n    console.log(&quot;Inorder Array: &quot;);\n    printArray(inorder);\n\n    console.log(&quot;Preorder Array: &quot;);\n    printArray(preorder);\n\n    const sol = new Solution();\n\n    const root = sol.buildTree(preorder, inorder);\n\n    console.log(&quot;Inorder of Unique Binary Tree Created: &quot;);\n    printInorder(root);\n    console.log();\n}\n\n// Call the main function\nmain();\n\n                            </code>\n                        </pre>\n                    </div>\n                    <p>\n                       <strong>Output</strong> \n                      \tInorder Vector: 9 3 15 20 7, Preorder Vector: 3 9 20 15 7 ,Inorder of Unique Binary Tree Created: 9 3 15 20 7 \n                    </p>\n                </div>\n            </details>\n            <details class=\"secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Complexity Analysis\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <p>\n                    <!-- Insert Time and Space Complexity  Here -->\n                    <p><strong>Time Complexity: O(N)</strong>   where N is the number of nodes in the Binary Tree. This is because each node of the Binary Tree is visited once.</p>\n\n\t\t\t\t\t<p><strong>Space Complexity: O(N)</strong>    where N is the number of nodes in the Binary Tree. The inorder hashmap to store the inorder array for fast lookup takes up space proportional to the input nodes.\n\t\t\t\t\tAn auxiliary stack space ~ O(H) where H is the height of the Binary Tree is used. This is the stack space used to build the tree recursively. In the case of a skewed tree, the height of the tree will be H ~ N hence the worst case auxiliary space is O(N).</p>\n\n                </p>\n            </details>\n        </div>\n    </details>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <!-- Insert iframe embed Link of Youtube Video-->\n        <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/aZNaLrVebKQ?si=WDGyqV0gpU7YfmvE\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n        </div>\n    </details>\n</div>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}