{
    "dislikes": 76,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:18 GMT+0530 (India Standard Time)",
    "slug": "morris-preorder-traversal-of-a-binary-tree",
    "aid": "1448",
    "title": "Morris Preorder Traversal of a Binary Tree",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/morris-preorder-traversal-",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Tree, implement Morris Preorder Traversal and return the array containing its preorder sequence. \n</p>\n<p>Morris Preorder Traversal is a tree traversal algorithm aiming to achieve a space complexity of O(1) without recursion or an external data structure. The algorithm should efficiently visit each node in the binary tree in preorder sequence, printing or processing the node values as it traverses, without using a stack or recursion. \n</p>\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 4 2 5 3 -1 7 6 -1 9 -1 -1 8 -1 1\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image1-H3tj5yqI\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output: </strong>[4 2 3 9 1 5 7 6 8]</span>\t\t\t\n\t\t\t\t<span><strong>Explanation: </strong>We traverse the binary tree in the order of Root, Left then Right recursively resulting in the following traversal:</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image2-UQTtw9Ud\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t\n\t\t\t\t<span><strong>Example 2:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 3 4 5 6 7 -1 -1 8 -1 -1 -1 9 10\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image3-agurdU7E\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output: </strong>[1 2 4 5 8 3 6 7 9 10]</span>\n\t\t\t\t\n\t\t\t\t<span><strong>Explanation: </strong>We traverse the binary tree in the order of Root, Left then Right recursively resulting in the following traversal:</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image4-mKHI7kOD\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t\t\n            </pre>\n        </div>\n    </details>\n</div>\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/preorder-binary-tree_5948?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\"\n                alt=\"code-studio\">\n        </a>\n    </div>\n    <!--<div class=\"problem-buttons\">\n         Add Problem Link inside href \n        <a href=\"\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp\"\n                alt=\"leetcode\">\n        </a>\n    </div>-->\n</div>\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\n        yourself first. </em></p>\n\n\n<div id=\"brute-force-approach\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Optimal Approach \n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                </path>\n            </svg>\n        </summary>\n        <div class=\"common-drops\">\n            <details class=\"secondary-details\" open=\"\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Algorithm / Intuition\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"approach-algorithm\">\n                    <!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n                    \n                    <p>A prerequisite to this problem is Morris Inorder Traversal of Binary Tree. We extend Morris Inorder Traversal to Preorder Morris Traversal and modify the algorithm to print the current node\u2019s value before moving to the left child when the right child of the inorder predecessor is null.</p>\n                    <p>This change ensures that the nodes are processed in the desired order for Preorder Traversal. The basic structure of Morris Traversal remains intact, but the printing step is adjusted, resulting in a Preorder Traversal that is still in-place and has a constant space complexity.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image5-tW551Gn1\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p>In Morris Inorder Traversal, we are traversing the tree in the way: Left, Root, Right. In Morris Preorder traversal we want to traverse the tree in the way: Root, Left, Right. Therefore, the following code changes are required:</p>\n                    <p><strong>When the current node has a left child:</strong></p>\n                    <p>In Morris Inorder Traversal, a new thread is created by establishing a temporary link between the current node and its in-order predecessor. In Morris Preorder Traversal, we want to print the root before visiting the left child. Therefore, after setting the thread (establishing the link), we print the current node's value before moving it to its left child.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image6-xd_vcDS-\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p><strong>When the current node has no left child:</strong></p>\n                    <p>This case remains unchanged from Morris Inorder Traversal. If the current node has no left child, there is nothing to visit on the left side. In both Inorder and Preorder traversals, we want to print the current node's value and move to the right child. Therefore, there is no code modification needed for this scenario.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image7-i0AawQQi\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\n                    <h3>Algorithm: </h3>\n                    <p><strong>Step 1:</strong>Initialise a current to traverse the tree. Set current to the root of the Binary Tree.</p>\n                   \n                    <p><strong>Step 2: </strong>While the current is not null: If the current node has no left child, print the current node's value and move to the right child ie. set current to its right child.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image8-hVKa1Abt\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                   \n                   \t\n                    \n                    <p><strong>Step 3: </strong>\n                    If the current node has a left child, we find the in-order predecessor of the current node. This in-order predecessor is the rightmost node in the left subtree or the left subtree's rightmost node.</p>\n                    <p><strong>If the right child of the in-order predecessor is null:</strong>\n                   \t<ol><li>Set the right child to the current node.</li><li>Print the value of the current node as preorder traverses the tree in the inorder: Root, Left then Right.</li><li>Move to the left child (i.e., set current to its left child).</li></ol></p>\n                   \t<p><strong>If the right child of the in-order predecessor is not null:</strong>\n                   \t<ol><li>Revert the changes made in the previous step by setting the right child as null.</li><li>Move to the right child (i.e., set current to its right child).</li></ol></p>\n                   \t<p>Repeat steps 2 and 3 until the end of the tree is reached. </p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/morris-preorder-image9-zK5cv0iP\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure> \n                              \n                </div>\n            </details>\n            <details class=\"code-section secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Code\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"code-tabs\">\n                    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                    <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                        </path>\n                    </svg>\n                </div>\n                <div class=\"code-content\">\n                    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\n// TreeNode structure\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to perform iterative Morris\n    // preorder traversal of a binary tree\n    vector&lt;int&gt; getPreorder(TreeNode* root) {\n        // Vector to store the\n        // preorder traversal result\n        vector&lt;int&gt; preorder;\n        \n        // Pointer to the current node,\n        // starting with the root\n        TreeNode* cur = root;\n\n        // Iterate until the\n        // current node becomes NULL\n        while (cur != NULL) {\n            // If the current node\n            // has no left child\n            if (cur-&gt;left == NULL) {\n                // Add the value of the\n                // current node to the preorder vector\n                preorder.push_back(cur-&gt;val);\n                \n                // Move to the right child\n                cur = cur-&gt;right;\n            } else {\n                // If the current node has a left child\n                // Create a pointer to traverse to the\n                // rightmost node in the left subtree\n                TreeNode* prev = cur-&gt;left;\n                \n                // Traverse to the rightmost node in the\n                // left subtree or until we find a node \n                // whose right child is not yet processed\n                while (prev-&gt;right &amp;&amp; prev-&gt;right != cur) {\n                    prev = prev-&gt;right;\n                }\n                \n                // If the right child of the\n                // rightmost node is NULL\n                if (prev-&gt;right == NULL) {\n                    // Set the right child of the\n                    // rightmost node to the current node\n                    prev-&gt;right = cur;\n                    \n                    // Move to the left child\n                    cur = cur-&gt;left;\n                } else {\n                    // If the right child of the\n                    // rightmost node is not NULL\n                    // Reset the right child to NULL\n                    prev-&gt;right = NULL;\n                    \n                    // Add the value of the\n                    // current node to the preorder vector\n                    preorder.push_back(cur-&gt;val);\n                    \n                    // Move to the right child\n                    cur = cur-&gt;right;\n                }\n            }\n        }\n        \n        // Return the resulting\n        //preorder traversal vector\n        return preorder;\n    }\n};\n\n\nint main() {\n\n    TreeNode* root = new TreeNode(1);\n    root-&gt;left = new TreeNode(2);\n    root-&gt;right = new TreeNode(3);\n    root-&gt;left-&gt;left = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(5);\n    root-&gt;left-&gt;right-&gt;right = new TreeNode(6);\n\n    Solution sol;\n    \n    vector&lt;int&gt; preorder = sol.getPreorder(root);\n\n    cout &lt;&lt; &quot;Binary Tree Morris Preorder Traveral: &quot;;\n    for(int i = 0; i&lt; preorder.size(); i++){\n        cout &lt;&lt; preorder[i] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block \" data-lang=\"java\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"java\" class=\"language-java\">\nimport java.util.ArrayList;\nimport java.util.List;\n\n// TreeNode structure\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n    // Function to perform iterative Morris\n    // preorder traversal of a binary tree\n    public List&lt;Integer&gt; getPreorder(TreeNode root) {\n        // List to store the\n        // preorder traversal result\n        List&lt;Integer&gt; preorder = new ArrayList&lt;&gt;();\n\n        // Pointer to the current node,\n        // starting with the root\n        TreeNode cur = root;\n\n        // Iterate until the\n        // current node becomes null\n        while (cur != null) {\n            // If the current node\n            // has no left child\n            if (cur.left == null) {\n                // Add the value of the\n                // current node to the preorder list\n                preorder.add(cur.val);\n\n                // Move to the right child\n                cur = cur.right;\n            } else {\n                // If the current node has a left child\n                // Create a pointer to traverse to the\n                // rightmost node in the left subtree\n                TreeNode prev = cur.left;\n\n                // Traverse to the rightmost node in the\n                // left subtree or until we find a node\n                // whose right child is not yet processed\n                while (prev.right != null &amp;&amp; prev.right != cur) {\n                    prev = prev.right;\n                }\n\n                // If the right child of the\n                // rightmost node is null\n                if (prev.right == null) {\n                    // Set the right child of the\n                    // rightmost node to the current node\n                    prev.right = cur;\n\n                    // Move to the left child\n                    cur = cur.left;\n                } else {\n                    // If the right child of the\n                    // rightmost node is not null\n                    // Reset the right child to null\n                    prev.right = null;\n\n                    // Add the value of the\n                    // current node to the preorder list\n                    preorder.add(cur.val);\n\n                    // Move to the right child\n                    cur = cur.right;\n                }\n            }\n        }\n\n        // Return the resulting\n        // preorder traversal list\n        return preorder;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.left = new TreeNode(4);\n        root.left.right = new TreeNode(5);\n        root.left.right.right = new TreeNode(6);\n\n        Solution sol = new Solution();\n\n        List&lt;Integer&gt; preorder = sol.getPreorder(root);\n\n        System.out.print(&quot;Binary Tree Morris Preorder Traveral: &quot;);\n        for (int i = 0; i &lt; preorder.size(); i++) {\n            System.out.print(preorder.get(i) + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"python\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"python\" class=\"language-python\">\n# TreeNode class definition\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def getPreorder(self, root):\n        # List to store the preorder traversal result\n        preorder = []\n\n        # Pointer to the current node, starting with the root\n        cur = root\n\n        # Iterate until the current node becomes None\n        while cur is not None:\n            # If the current node has no left child\n            if cur.left is None:\n                # Add the value of the current node to the preorder list\n                preorder.append(cur.val)\n\n                # Move to the right child\n                cur = cur.right\n            else:\n                # If the current node has a left child\n                # Create a pointer to traverse to the rightmost node in the left subtree\n                prev = cur.left\n\n                # Traverse to the rightmost node in the left subtree\n                # or until we find a node whose right child is not yet processed\n                while prev.right and prev.right != cur:\n                    prev = prev.right\n\n                # If the right child of the rightmost node is None\n                if prev.right is None:\n                    # Set the right child of the rightmost node to the current node\n                    prev.right = cur\n\n                    # Move to the left child\n                    cur = cur.left\n                else:\n                    # If the right child of the rightmost node is not None\n                    # Reset the right child to None\n                    prev.right = None\n\n                    # Add the value of the current node to the preorder list\n                    preorder.append(cur.val)\n\n                    # Move to the right child\n                    cur = cur.right\n\n        # Return the resulting preorder traversal list\n        return preorder\n\n\n# Main function\nif __name__ == &quot;__main__&quot;:\n    # Construct the binary tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.left.right.right = TreeNode(6)\n\n    # Create an instance of the Solution class\n    sol = Solution()\n\n    # Perform Morris Preorder Traversal\n    preorder = sol.getPreorder(root)\n\n    # Print the result\n    print(&quot;Binary Tree Morris Preorder Traversal:&quot;, end=&quot; &quot;)\n    for val in preorder:\n        print(val, end=&quot; &quot;)\n    print()\n                           </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// TreeNode structure\nclass TreeNode {\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to perform iterative Morris\n    // preorder traversal of a binary tree\n    getPreorder(root) {\n        // Vector to store the\n        // preorder traversal result\n        const preorder = [];\n\n        // Pointer to the current node,\n        // starting with the root\n        let cur = root;\n\n        // Iterate until the\n        // current node becomes null\n        while (cur !== null) {\n            // If the current node\n            // has no left child\n            if (cur.left === null) {\n                // Add the value of the\n                // current node to the preorder array\n                preorder.push(cur.val);\n\n                // Move to the right child\n                cur = cur.right;\n            } else {\n                // If the current node has a left child\n                // Create a pointer to traverse to the\n                // rightmost node in the left subtree\n                let prev = cur.left;\n\n                // Traverse to the rightmost node in the\n                // left subtree or until we find a node \n                // whose right child is not yet processed\n                while (prev.right &amp;&amp; prev.right !== cur) {\n                    prev = prev.right;\n                }\n\n                // If the right child of the\n                // rightmost node is null\n                if (prev.right === null) {\n                    // Set the right child of the\n                    // rightmost node to the current node\n                    prev.right = cur;\n\n                    // Move to the left child\n                    cur = cur.left;\n                } else {\n                    // If the right child of the\n                    // rightmost node is not null\n                    // Reset the right child to null\n                    prev.right = null;\n\n                    // Add the value of the\n                    // current node to the preorder array\n                    preorder.push(cur.val);\n\n                    // Move to the right child\n                    cur = cur.right;\n                }\n            }\n        }\n\n        // Return the resulting\n        //preorder traversal array\n        return preorder;\n    }\n}\n\n// Main function\nfunction main() {\n    const root = new TreeNode(1);\n    root.left = new TreeNode(2);\n    root.right = new TreeNode(3);\n    root.left.left = new TreeNode(4);\n    root.left.right = new TreeNode(5);\n    root.left.right.right = new TreeNode(6);\n\n    const sol = new Solution();\n\n    const preorder = sol.getPreorder(root);\n\n    console.log(&quot;Binary Tree Morris Preorder Traveral: &quot; + preorder.join(&quot; &quot;));\n}\n\n// Execute the main function\nmain();\n                            </code>\n                        </pre>\n                    </div>\n                    <p>\n                       <strong>Output</strong> \n                      \tBinary Tree Morris Preorder Traversal: 4 2 5 6 1 3 \n                    </p>\n                </div>\n            </details>\n            <details class=\"secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Complexity Analysis\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <p>\n                    <!-- Insert Time and Space Complexity  Here -->\n                    <p><strong>Time Complexity: O(2N)</strong>\n                    where N is the number of nodes in the Binary Tree.\n                    <ol><li>The time complexity is linear, as each node is visited at most twice (once for establishing the temporary link and once for reverting it).</li><li>In each step, we perform constant-time operations, such as moving to the left or right child and updating pointers.</li></ol></p>\n\n\t\t\t\t\t<p><strong>Space Complexity: O(1)</strong>   \n\t\t\t\t\tThe space complexity is constant, as the algorithm uses only a constant amount of extra space irrespective of the input size.\n\t\t\t\t\t<ol><li>Morris Traversal does not use any additional data structures like stacks or recursion, making it an in-place algorithm.</li><li>The only space utilised is for a few auxiliary variables, such as pointers to current and in-order predecessor nodes.</li></ol></p>\n\n                </p>\n            </details>\n        </div>\n    </details>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <!-- Insert iframe embed Link of Youtube Video-->\n        <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/80Zug6D1_r4?si=DRWnb0bldKkr24mg\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n        </div>\n    </details>\n</div>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>",
    "category_tag": "data-structure",
    "likes": 52,
    "preview": "Problem Statement: Given a Binary Tree, implement Morris Preorder Traversal and return the array containing its preorder sequence. Morris Preorder Traversal is a tree traversal algorithm aiming to..."
}