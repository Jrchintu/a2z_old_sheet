{
    "dislikes": 4,
    "video": "OwMNX8SPavM",
    "publishedOn": "Sun Mar 24 2024 22:11:50 GMT+0530 (India Standard Time)",
    "slug": "most-stones-removed-with-same-row-or-column-dsu-g-53",
    "aid": "2174",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/most-stones-removed-with-same-row-or-column",
    "title": "Most Stones Removed with Same Row or Column - DSU: G-53",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 58,
    "category_tag": "data-structure",
    "preview": "Problem Statement: There are n stones at some integer coordinate points on a 2D plane. Each coordinate point may have at most one stone. You need to remove some stones. A stone can be removed if it...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> There are n stones at some integer coordinate points on a 2D plane. Each coordinate point may have at most one stone.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>You need to remove some stones.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given an array of stones of length n where stones[i] = [xi, yi] represents the location of the ith stone, return the maximum possible number of stones that you can remove.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-requisite: </strong><a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\">Disjoint Set data structure</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b> n=6  stones = [[0, 0],[ 0, 1], [1, 0],[1, 2],[2, 1],[2, 2]]\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-141600.png\" alt=\"\" class=\"wp-image-7121\"/></figure>\n<b>Result:</b> 5\n<b>Explanation:</b> One of the many ways to remove 5 stones is to remove the following stones:\n[0,0], [1,0], [0,1], [2,1], [1,2]\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b> N = 6, stones = {{0, 0}, {0, 2},  {1, 3}, {3, 1}, {3, 2}, {4, 3}};\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-141655-1.png\" alt=\"\" class=\"wp-image-7123\"/></figure>\n<b>Result:</b> 4\n<b>Explanation:</b> We can remove the following stones:\n[0,0], [0,2], [1,3], [3,1]\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/maximum-stone-removal-1662179442/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=maximum-stone-removal\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem Link</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s first understand the thought process that we will be using to solve this problem. In this problem, it is clearly stated that a stone can be removed if it shares either the same row or the same column as another stone that has not been removed. So, we can assume that these types of stones, sharing either the same row or column, are connected and belong to the same group. If we take example 2:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7124,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-141847.png\" alt=\"\" class=\"wp-image-7124\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>We can easily spot two different groups in this example. The first group includes the stones [0,0], [0,2], [3,2], and [3,1], and the second one includes [1,3] and [4,3].</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If we carefully observe, for each group we can remove all the stones leaving one stone intact. So, we can conclude that at most we can remove (size of the group -1) no. of stones from a group as we need to leave one stone untouched for each group.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, if we can think of the stones as nodes, the different groups then seem to be the different components of a graph.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong><em>Mathematical Explanation of getting the maximum no. of stones:</em></strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s assume there are n stones in total. And these n stones have formed k different components each containing X<sub>i</sub> no. of stones. This indicates the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7125,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-142029.png\" alt=\"\" class=\"wp-image-7125\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Until now, we have proved that we can remove a maximum of (n-k) no. of stones from the whole 2D plane, where n is the total number of stones and k is the total number of components.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, we have reduced the question in such a way that we just need to connect the stones properly to find out the number of different components and we will easily solve the problem.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Here we are getting the thought of connected components. So, we can easily decide to choose the <a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\">Disjoint Set data structure</a> to solve this problem.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong><em>How to connect the cells containing stones to form a component:</em></strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In order to connect the cells we will assume that each entire row and column of the 2D plane is a particular node. Now, with each row, we will connect the column no.s in which the stones are located. But column no. may be the same as the row number. To avoid this, we will convert each column no. to (column no. + total no. of rows) and perform the union of row no. and the converted column number i.e. (column no. + total no. of rows) like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7126,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-142121.png\" alt=\"\" class=\"wp-image-7126\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>For the above example, to connect the two stones in the cells [0, 0] and [0, 2] of the first row, we will first take row no. i.e. 0(<em>because of 0-based indexing</em>) as a node and then convert column no.s 0 to (0+5) and 2 to (2+5). Then, we will perform the union of (0 and 5) and (0 and 7).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Thus <strong><em>we will connect all the stones that are either in the same row or in the same column</em></strong> to form different connected components.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First, from the stone information, we will find out the maximum row and the maximum column number so that we can get an idea about the size of the 2D plane(i.e. nothing but a matrix).</li><li>Then, we need to create a disjoint set of sizes (maximum row index+maximum column index). For safety, we may take a size one more than required.</li><li>Now it\u2019s time to connect the cells having a stone. For that we will loop through the given cell information array and for each cell we will extract the row and the column number and do the following:<ol><li>First, we will convert column no. to (column no. + maximum row index +1).&nbsp;</li><li>We will perform the union(<strong><em>either unionBySize() or unionByRank()</em></strong>) of the row number and the converted column number.</li><li>We will store the row and the converted column number in a map data structure for later use.</li></ol></li><li>Now, it\u2019s time to calculate the number of components and for that, we will count the number of ultimate parents. Here we will refer to the previously created map.<ol><li>We just need the nodes in the Disjoint Set that are involved in having a stone. So we have stored the rows and the columns in a map in step 3.3, as they will have stones. Now we just need to check them from the map data structure once for getting the number of ultimate parents.</li></ol></li><li>Finally, we will subtract the no. of components(i.e. no. of ultimate parents) from the total no. of stones and we will get our answer.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n\nclass DisjointSet {\n    vector&lt;int&gt; rank, parent, size;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] &lt; rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] &lt; rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] &lt; size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\nclass Solution {\npublic:\n    int maxRemove(vector&lt;vector&lt;int&gt;&gt;&amp; stones, int n) {\n        int maxRow = 0;\n        int maxCol = 0;\n        for (auto it : stones) {\n            maxRow = max(maxRow, it[0]);\n            maxCol = max(maxCol, it[1]);\n        }\n        DisjointSet ds(maxRow + maxCol + 1);\n        unordered_map&lt;int, int&gt; stoneNodes;\n        for (auto it : stones) {\n            int nodeRow = it[0];\n            int nodeCol = it[1] + maxRow + 1;\n            ds.unionBySize(nodeRow, nodeCol);\n            stoneNodes[nodeRow] = 1;\n            stoneNodes[nodeCol] = 1;\n        }\n\n        int cnt = 0;\n        for (auto it : stoneNodes) {\n            if (ds.findUPar(it.first) == it.first) {\n                cnt++;\n            }\n        }\n        return n - cnt;\n    }\n};\n\nint main() {\n\n    int n = 6;\n    vector&lt;vector&lt;int&gt;&gt; stones = {\n        {0, 0}, {0, 2},\n        {1, 3}, {3, 1},\n        {3, 2}, {4, 3}\n    };\n\n    Solution obj;\n    int ans = obj.maxRemove(stones, n);\n    cout &lt;&lt; \"The maximum number of stones we can remove is: \" &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The maximum number of stones we can remove is: 4 (For example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N), where N = total no. of stones. Here we have just traversed the given stones array several times. And inside those loops, every operation is apparently taking constant time. So, the time complexity is only the time of traversal of the array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2* (max row index + max column index)) for the parent and size array inside the Disjoint Set data structure.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\n\n\nclass DisjointSet {\n    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; size = new ArrayList&lt;&gt;();\n    public DisjointSet(int n) {\n        for (int i = 0; i &lt;= n; i++) {\n            rank.add(0);\n            parent.add(i);\n            size.add(1);\n        }\n    }\n\n    public int findUPar(int node) {\n        if (node == parent.get(node)) {\n            return node;\n        }\n        int ulp = findUPar(parent.get(node));\n        parent.set(node, ulp);\n        return parent.get(node);\n    }\n\n    public void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {\n            parent.set(ulp_v, ulp_u);\n        } else {\n            parent.set(ulp_v, ulp_u);\n            int rankU = rank.get(ulp_u);\n            rank.set(ulp_u, rankU + 1);\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size.get(ulp_u) &lt; size.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\n        } else {\n            parent.set(ulp_v, ulp_u);\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\n        }\n    }\n}\nclass Solution {\n\n    int maxRemove(int[][] stones, int n) {\n        int maxRow = 0;\n        int maxCol = 0;\n        for (int i = 0; i &lt; n; i++) {\n            maxRow = Math.max(maxRow, stones[i][0]);\n            maxCol = Math.max(maxCol, stones[i][1]);\n        }\n        DisjointSet ds = new DisjointSet(maxRow + maxCol + 1);\n        HashMap&lt;Integer, Integer&gt; stoneNodes = new HashMap&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            int nodeRow = stones[i][0];\n            int nodeCol = stones[i][1] + maxRow + 1;\n            ds.unionBySize(nodeRow, nodeCol);\n            stoneNodes.put(nodeRow, 1);\n            stoneNodes.put(nodeCol, 1);\n        }\n\n        int cnt = 0;\n        for (Map.Entry&lt;Integer, Integer&gt; it : stoneNodes.entrySet()) {\n            if (ds.findUPar(it.getKey()) == it.getKey()) {\n                cnt++;\n            }\n        }\n        return n - cnt;\n    }\n};\n\nclass Main {\n    public static void main (String[] args) {\n        int n = 6;\n        int[][] stones = {\n            {0, 0}, {0, 2},\n            {1, 3}, {3, 1},\n            {3, 2}, {4, 3}\n        };\n\n        Solution obj = new Solution();\n        int ans = obj.maxRemove(stones, n);\n        System.out.println(\"The maximum number of stones we can remove is: \" + ans);\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The maximum number of stones we can remove is: 4 (For example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N), where N = total no. of stones. Here we have just traversed the given stones array several times. And inside those loops, every operation is apparently taking constant time. So, the time complexity is only the time of traversal of the array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2* (max row index + max column index)) for the parent and size array inside the Disjoint Set data structure.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}