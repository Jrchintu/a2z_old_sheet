{
    "dislikes": 9,
    "video": "ekcwMsSIzVc",
    "publishedOn": "Sun Mar 24 2024 22:11:29 GMT+0530 (India Standard Time)",
    "slug": "longest-increasing-subsequence-dp-41",
    "aid": "2085",
    "title": "Longest Increasing Subsequence | (DP-41)",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/longest-increasing-subsequence",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p>In the coming articles, we will discuss problems related to \u2018Longest Increasing Subsequence\u2019. Before proceeding further, let us understand the \u201cLongest Increasing Subsequence\u201d, or rather what is a \u201c<strong>subsequence</strong>\u201d?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A subsequence of an array is a list of elements of the array where some elements are deleted ( or not deleted at all) and they should be in the <strong>same order </strong>in the subsequence as in the original array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For example, for the array: [2,3,1] , the subsequences will be [{2},{3},{1},{2,3},{2,1},{3,1},{2,3,1}} but {3,2} is <strong>not</strong> a subsequence because its elements are not in the same order as the original array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>What is the Longest Increasing Subsequence?</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The longest increasing subsequence is described as a subsequence of an array where:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>All elements of the subsequence are in increasing order.</li><li>This subsequence itself is of the longest length possible.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<figure class=\"wp-block-image\"><img src=\"https://lh6.googleusercontent.com/7Y4v7hcxpISAigs1Vvd9vpu_VnxD2HYS5WFNxusE5l-XURyfF8CDPzPrWHscZPPxLkaK_mIV0Z5pKH9pp3c6cfY0olD_3W0opVADet-dUayVn7yJkdjswThmxBNFJZ_yKZGazVNx5U-Guyc-sgg\" alt=\"\"></figure>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p>We need to return the length of the longest increasing subsequence as the answer.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Pre-req: <a href=\"https://www.youtube.com/watch?v=AxNNVECce8c\" target=\"_blank\" rel=\"noreferrer noopener\">Recursion on Subsequences</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/longest-increasing-subsequence_630459?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach 1: Using Brute Force</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given an array arr[]. To find the longest increasing subsequence, the brute force method that comes to our mind is to generate all subsequences and then manually filter the subsequences whose elements come in increasing order and then return the longest such subsequence.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This naive approach will give us the correct answer but to generate all the subsequences, we will require <strong>exponential (</strong> <strong>2<sup>n</sup></strong><strong> ) </strong>time. Therefore we will try some other approaches.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach 2: Using Dynamic Programming</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We would want to try something that can give us the longest increasing subsequence on the way of generating all subsequences. To generate all subsequences we will use recursion and in the recursive logic we will figure out a way to solve this problem.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Steps to form the recursive solution:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will first form the recursive solution by the three points mentioned in the <a href=\"https://takeuforward.org/data-structure/dynamic-programming-introduction/\" target=\"_blank\" rel=\"noreferrer noopener\">Dynamic Programming Introduction</a>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let us take a small example:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"https://lh5.googleusercontent.com/vTYC7x16xNjiRis2_0LjHRTNZgK-VTCfl7UAkonOSlQIxazRwBS6f7fFliRdq66Ryvsn8wGe8cJ4Lz_fm-KTEmhKaYOzFsiyxmLOdzbB7g3n7nZTK74jqFIroemyKXlskQQeecf18bzOwxPHOw\" alt=\"\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now, We need to think in terms of indexes. One definite parameter is the index of the array which can range from 0 to n-1 (where n is the size of the array). Now, initially let us say we considered the first element 4 in our subsequence, and now we are deciding on the second element 6:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"403\" src=\"https://lh3.googleusercontent.com/1PFvYdvnEY-ZbiX17Dr-JvBokO3Hsg9r7Pe0jJHt_lM3qiOhhuQ7vFD0Ee_d83TzaLicYJf2pdIL48KgFVrTBjUw2PD47cduMRRTXXSUJHj8mTRj3cJUj9Pe0eQU8FHoN4fur52EAENgE85UKqE\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>To decide for 6, we need to know what is already present in our subsequence. We denote it by a variable prev_index. This variable prev_index tells us the index of the last element of the subsequence in the original array. Now as the prev_index is 0, we know the last element in the subsequence is arr[0] = 4. As 6 is greater than 4, we can consider adding it to our subsequence, therefore the prev_index is updated to 1 ( the index of 6 in the array).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Hence, we also need a second parameter called prev_index to decide at every index \u2018ind\u2019 whether this array element can be considered in the increasing subsequence or not. Initially, prev_index will be <strong>-1</strong> as there is no element present in the subsequence.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"width\":622,\"height\":68} -->\n<figure class=\"wp-block-image is-resized\"><img src=\"https://lh5.googleusercontent.com/TlNpLni7PUz41FgA0TdeidylW_su0CzuXyl2Xp20rzepSS7rQPj4Pd3Fa-LJCkYHciqcWzCKSmYkjLcMgaakx4pe2avGIlh9iqsBuUrktFwuFSdh35u6SJcU4KyfB-D8fqKxF0DXwQ92PVv_9Q\" alt=\"\" width=\"622\" height=\"68\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 2: </strong>Explore all possibilities at a given index</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition for Recursive Logic</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>At every index, we have two choices based on the pick/non-pick technique as discussed in this video \u201c<a href=\"https://www.youtube.com/watch?v=AxNNVECce8c\" target=\"_blank\" rel=\"noreferrer noopener\">Recursion on Subsequences</a>\u201d.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Do not consider the current element in the subsequence:</strong> In this case, we are not considering the current element in the subsequence, therefore the length of the subsequence will not increase and the prev_index element will remain as it is. Hence we will return <strong>0 + f(ind+1,prev_index)</strong> as our answer.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"https://lh5.googleusercontent.com/zXOP1tqUrsBn_T0k5kOcKTMOuoMg3KeDJkHRBkvmae7cwoKpZotszSw5Ya7SqWah9jdEoPamAsbLaHkay17NUdHSCFmHbo4ZCLEYtGv_uRXvqpaA-AwJ7_4X15Zc3gp0tHxbHkVCS7zUHwd4ag\" alt=\"\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><li><strong>Consider the current element in the subsequence: </strong>In this case, we are considering the current element in the subsequence, therefore the length of the subsequence will increase by 1 and the prev_index element will be updated to the current index element.. Hence we will return 1 + f(ind+1,ind) as our answer. Here is a simple catch, when we want to consider the current index element to the subsequence, we need to check that it is <strong>greater than </strong>the<strong> </strong>last element of the subsequence so far,i.e the prev_index element.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"https://lh4.googleusercontent.com/uZS0-0JSKITaaEC5jwgzIvtJQcMimBTAjHmD4yoK1NB6CbI4bH7guGxNcvtpAx3W5zEREB505ld5bdUmmqhJY6nklKYDXt78dcuvMGNYzKB7YPiKBNbRLgs4BeEv3kC98TJKXRBLmd7w-Ge8TQ\" alt=\"\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code class=\"\">f(ind, prev_index){\n    notTake = 0 + f(ind + 1, prev_index)\n\n    if(prev_index == -1 || arr[ind]&gt;arr[prev_index]){\n        take = 1 + f(ind + 1, ind)\n    }\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>When prev_index is -1, it means that we have not considered any element to our subsequence. Therefore, we can always consider the current element (arr[ind]) for our subsequence.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 3:&nbsp; Return the maximum of the choices</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As we have to find the length of the longest increasing subsequence, we will return the maximum of the above-discussed two cases.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Base Case:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>When ind==n</strong>,</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>It means that we have considered all the elements of the array and there are no more elements left to explore, therefore we return 0.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The final pseudocode after steps 1, 2, and 3:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code class=\"\"><meta charset=\"utf-8\">f(ind, prev_index){\n\n    if(ind == n)\n        return 0\n\n    notTake = 0 + f(ind + 1, prev_index)\n\n    if(prev_index == -1 || arr[ind]&gt;arr[prev_index]){\n        take = 1 + f(ind + 1, ind)\n    }\n\n    return max(notTake, take)\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Recursive Tree</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will dry run this example arr{4,2,6]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"https://lh4.googleusercontent.com/ybMnh1UKnWpRTwrZMtLMKwlxnF1_TMg6H3PkM91mAm9nhqh64h9tMemjV3IJPar9vy69pg0lFObUBj-unQsV8qqlt4FKGp6k7uonEY6Dw9SBUBSCgh9hrpbFRfsatAP7u2dx2zbbDTEYo-pVlr0\" alt=\"\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Steps to memoize a recursive solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As we see there are overlapping subproblems in the recursive tree, we can memorize the recursive code to reduce the time complexity.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Our function has two variables that are changing: ind and prev_ind.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>\u2018ind\u2019 represents the index of the array. It can range from 0 to n-1.</li><li>\u2018prev_index\u2019 also represents the index of the array. When we have not considered any element in our LIS, prev_index is -1. Therefore, prev_index can range from -1 to n-1. Now we cannot store the -1 index in our 2D array. Therefore, we would do a coordinate shift of one as follows:</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image -->\n<figure class=\"wp-block-image\"><img src=\"https://lh4.googleusercontent.com/uvIm2uiuoE8eRVXKVnqVbDDbft12j_6aXsrEh06J-5EmBZZ8SZ_fvxgcF3gkvGOwp4ifno107GV-akWcJ42pj5dFdfLNqeR9d2pfwbNx3vJT4AVF1Ds5abtsWMukx5M1wbn62s0Rfq6YTYQ-d3w\" alt=\"\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Therefore the size of the dp array required for this will be dp[N][N+1], where N is the size of the array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Next, we do the following steps:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(ind,prev_index), we first check whether the answer is already calculated using the dp array(i.e dp[ind][prev_index]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][ind2] to the solution we get.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to find the length of the longest increasing subsequence\nint getAns(int arr[], int n, int ind, int prev_index, vector&lt;vector&lt;int>>&amp; dp) {\n    // Base condition\n    if (ind == n)\n        return 0;\n        \n    if (dp[ind][prev_index + 1] != -1)\n        return dp[ind][prev_index + 1];\n    \n    int notTake = 0 + getAns(arr, n, ind + 1, prev_index, dp);\n    \n    int take = 0;\n    \n    if (prev_index == -1 || arr[ind] > arr[prev_index]) {\n        take = 1 + getAns(arr, n, ind + 1, ind, dp);\n    }\n    \n    return dp[ind][prev_index + 1] = max(notTake, take);\n}\n\nint longestIncreasingSubsequence(int arr[], int n) {\n    // Create a 2D DP array initialized to -1\n    vector&lt;vector&lt;int>> dp(n, vector&lt;int>(n + 1, -1));\n    \n    return getAns(arr, n, 0, -1, dp);\n}\n\nint main() {\n    int arr[] = {10, 9, 2, 5, 3, 7, 101, 18};\n    int n = sizeof(arr) / sizeof(arr[0]);\n    \n    cout &lt;&lt; \"The length of the longest increasing subsequence is \" &lt;&lt; longestIncreasingSubsequence(arr, n);\n    \n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest increasing subsequence is 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states therefore at max \u2018N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N) + O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an auxiliary recursion stack space(O(N)) (see the recursive tree, in the worst case we will go till N calls at a time) and a 2D array ( O(N*N+1)).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code class=\"\">import java.util.*;\n\nclass TUF {\n    // Function to find the length of the longest increasing subsequence\n    static int getAns(int arr[], int n, int ind, int prev_index, int[][] dp) {\n        // Base condition\n        if (ind == n) {\n            return 0;\n        }\n\n        if (dp[ind][prev_index + 1] != -1) {\n            return dp[ind][prev_index + 1];\n        }\n\n        int notTake = 0 + getAns(arr, n, ind + 1, prev_index, dp);\n\n        int take = 0;\n\n        if (prev_index == -1 || arr[ind] > arr[prev_index]) {\n            take = 1 + getAns(arr, n, ind + 1, ind, dp);\n        }\n\n        dp[ind][prev_index + 1] = Math.max(notTake, take);\n\n        return dp[ind][prev_index + 1];\n    }\n\n    // Function to find the length of the longest increasing subsequence\n    static int longestIncreasingSubsequence(int arr[], int n) {\n        int dp[][] = new int[n][n + 1];\n        \n        // Initialize dp array with -1 to mark states as not calculated yet\n        for (int row[] : dp) {\n            Arrays.fill(row, -1);\n        }\n\n        return getAns(arr, n, 0, -1, dp);\n    }\n\n    public static void main(String args[]) {\n        int arr[] = {10, 9, 2, 5, 3, 7, 101, 18};\n\n        int n = arr.length;\n\n        System.out.println(\"The length of the longest increasing subsequence is \" + longestIncreasingSubsequence(arr, n));\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest increasing subsequence is 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states therefore at max \u2018N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N) + O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an auxiliary recursion stack space(O(N)) (see the recursive tree, in the worst case we will go till N calls at a time) and a 2D array ( O(N*N+1)).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block\" data-lang=\"python\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def get_longest_increasing_subsequence_length(arr, n, ind, prev_index, dp):\n    # Base condition\n    if ind == n:\n        return 0\n\n    if dp[ind][prev_index + 1] != -1:\n        return dp[ind][prev_index + 1]\n\n    not_take = 0 + get_longest_increasing_subsequence_length(arr, n, ind + 1, prev_index, dp)\n\n    take = 0\n\n    if prev_index == -1 or arr[ind] > arr[prev_index]:\n        take = 1 + get_longest_increasing_subsequence_length(arr, n, ind + 1, ind, dp)\n\n    dp[ind][prev_index + 1] = max(not_take, take)\n    return dp[ind][prev_index + 1]\n\n\ndef longest_increasing_subsequence_length(arr):\n    n = len(arr)\n    dp = [[-1 for _ in range(n + 1)] for _ in range(n)]\n\n    return get_longest_increasing_subsequence_length(arr, n, 0, -1, dp)\n\n\nif __name__ == \"__main__\":\n    arr = [10, 9, 2, 5, 3, 7, 101, 18]\n\n    result = longest_increasing_subsequence_length(arr)\n    print(\"The length of the longest increasing subsequence is\", result)\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest increasing subsequence is 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states therefore at max \u2018N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N) + O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an auxiliary recursion stack space(O(N)) (see the recursive tree, in the worst case we will go till N calls at a time) and a 2D array ( O(N*N+1)).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>[tabby title=\"JavaScript Code\"]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">function getAns(arr, n, ind, prevIndex, dp) {\n    // Base condition\n    if (ind === n) return 0;\n\n    // Check if the result is already computed and stored in dp\n    if (dp[ind][prevIndex + 1] !== -1) return dp[ind][prevIndex + 1];\n\n    // Initialize variables for \"not taking\" and \"taking\" the current element\n    let notTake = 0 + getAns(arr, n, ind + 1, prevIndex, dp);\n    let take = 0;\n\n    // Check if the current element can be included (if it's greater than the previous element)\n    if (prevIndex === -1 || arr[ind] > arr[prevIndex]) {\n        take = 1 + getAns(arr, n, ind + 1, ind, dp);\n    }\n\n    // Store the result in dp and return the maximum\n    dp[ind][prevIndex + 1] = Math.max(notTake, take);\n    return dp[ind][prevIndex + 1];\n}\n\nfunction longestIncreasingSubsequence(arr) {\n    const n = arr.length;\n\n    // Create a 2D dp array filled with -1 to store computed results\n    const dp = new Array(n).fill().map(() => new Array(n + 1).fill(-1));\n\n    // Call the recursive function to compute the length of the longest increasing subsequence\n    return getAns(arr, n, 0, -1, dp);\n}\n\n// Main function\nfunction main() {\n    const arr = [10, 9, 2, 5, 3, 7, 101, 18];\n\n    const result = longestIncreasingSubsequence(arr);\n    console.log(\"The length of the longest increasing subsequence is\", result);\n}\n\n// Call the main function\nmain();\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest increasing subsequence is 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states therefore at max \u2018N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N) + O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an auxiliary recursion stack space(O(N)) (see the recursive tree, in the worst case we will go till N calls at a time) and a 2D array ( O(N*N+1)).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Anshuman Sharma</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 135,
    "preview": "In the coming articles, we will discuss problems related to \u2018Longest Increasing Subsequence\u2019. Before proceeding further, let us understand the \u201cLongest Increasing Subsequence\u201d, or rather what is a..."
}