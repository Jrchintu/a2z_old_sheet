{
    "dislikes": 9,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:11:46 GMT+0530 (India Standard Time)",
    "slug": "dijkstras-algorithm-using-set-g-33",
    "aid": "2158",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/dijkstra's-algorithm",
    "title": "Dijkstra\u2019s Algorithm - Using Set : G-33",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "category_tag": "data-structure",
    "likes": 163,
    "preview": "Given a weighted, undirected, and connected graph of V vertices and an adjacency list adj where adj[i] is a list of lists containing two integers where the first integer of each list j denotes ther...",
    "content": "<!-- wp:paragraph -->\n<p>Given a weighted, undirected, and connected graph of V vertices and an adjacency list adj where adj[i] is a list of lists containing two integers where the first integer of each list j denotes there is an <strong>edge</strong> between i and j, second integers corresponds to the weight of that edge. You are given the source vertex S and You have to Find the shortest distance of all the vertex from the source vertex S. You have to return a list of integers denoting the shortest distance between <strong>each node</strong> and Source vertex <strong>S</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>The Graph doesn\u2019t contain any negative weight cycle</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input:</b>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-162337-1.png\" alt=\"\" class=\"wp-image-6940\"></figure>\nV = 2\nadj [] = {{{1, 9}}, {{0, 9}}}\nS = 0\n\n<b>Output:</b>\n0 9\n\n<b>Explanation: </b>:\nThe source vertex is 0. Hence, the shortest distance of node 0 \nfrom the source is 0 and the shortest distance of node 1 from \nsource will be 9.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input:</b>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-162453-1.png\" alt=\"\" class=\"wp-image-6941\"></figure>\nV = 3, E = 3\nadj = {{{1, 1}, {2, 6}}, {{2, 3}, {0, 1}}, {{1, 3}, {0, 6}}}\nS = 2\n<b>Output:</b>\n4 3 0\n<b>Explanation: </b>\nFor nodes 2 to 0, we can follow the path 2-1-0. \nThis has a distance of 1+3 = 4, whereas the path 2-0 \nhas a distance of 6. So, the Shortest path from 2 to 0 is 4.\n\nThe shortest distance from 0 to 1 is 1.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong><strong>: </strong><strong><em>Don\u2019t jump directly to the solution, try it out yourself first.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/implementing-dijkstra-set-1-adjacency-matrix/0\" target=\"_blank\" rel=\"noopener\" title=\"\"><strong><em>Problem Link</em></strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: In case any image/dry run is not clear please refer to the video attached at the bottom.&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We\u2019ll be using Set in this approach for finding the shortest distances from the source node to every other node through Dijkstra\u2019s Algorithm.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Source Node: </strong>Before starting off with the Algorithm, we need to define a source node from which the shortest distances to every other node would be calculated.</li><li><strong>Set: </strong>Define a Set that would contain pairs of the type {dist, node}, where \u2018dist\u2019 indicates the currently updated value of the shortest distance from the source to the \u2018node\u2019.</li><li><strong>Dist Array: </strong>Define a dist array initialized with a large integer number at the start indicating that the nodes are unvisited initially. This array stores the shortest distances to all the nodes from the source node.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>The Algorithm consists of the following steps :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>We would be using a set and a distance array of size V (where \u2018V\u2019 are the number of nodes in the graph) initialized with infinity (indicating that at present none of the nodes are reachable from the source node) and initialize the distance to source node as 0.</li><li>We push the source node to the set along with its distance which is also 0.</li><li>Now, we start erasing the elements from the set and look out for their adjacent nodes one by one. If the current reachable distance is better than the previous distance indicated by the distance array, we update the distance and insert it in the set.</li><li>A node with a lower distance would be first erased from the set as opposed to a node with a higher distance. By following step 3, until our set becomes empty, we would get the minimum distance from the source node to all other nodes. We can then return the distance array.<strong>&nbsp;</strong></li><li>The only difference between using a Priority Queue and a Set is that in a set we can check if there exists a pair with the same node but a greater distance than the current inserted node as there will be no point in keeping that node into the set if we come across a much better value than that. So, we simply delete the element with a greater distance value for the same node.</li><li>Here\u2019s a quick demonstration of the algorithm :</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":6943,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-164609.png\" alt=\"\" class=\"wp-image-6943\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>Dijkstra\u2019s Algorithm is not valid for negative weights or negative cycles.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We can understand that by looking at the illustration below :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6944,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-165136.png\" alt=\"\" class=\"wp-image-6944\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Here, we initially mark the source node \u20180\u2019 as 0 and node \u20181\u2019 as INFINITY (as it is unvisited). Now, when we start applying the above algorithm on this we notice that both the nodes are updated each time we come to them again. This is due to the negative weight of \u2018-2\u2019 which makes the total distance to the node always lesser than the previous value. Therefore, due to inaccurate results, we assume the graph to always contain positive weights while using Dijkstra's Algorithm.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Note: If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The above problem implements a BFS kind of approach using the set data structure. The only thing that we need to take care of is that for all the paths possible between a pair of nodes, we need to store the path with the minimum cost between them. That is, say we have a node that has been reached by two paths, one with a cost of 7 and another with a cost of say 9. It is obvious that the path with a cost of 7 would be more optimal than the path with a cost of 9. A set data structure in C++ always stores the elements in increasing order i.e., when we erase from a set, the smallest valued elements get erased first.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    \n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution\n{\n\tpublic:\n\t  //Function to find the shortest distance of all the vertices\n    //from the source vertex S.\n    vector &lt;int&gt; dijkstra(int V, vector&lt;vector&lt;int&gt;&gt; adj[], int S)\n    {\n        // Create a set ds for storing the nodes as a pair {dist,node}\n        // where dist is the distance from source to the node.\n        // set stores the nodes in ascending order of the distances \n        set&lt;pair&lt;int,int&gt;&gt; st; \n\n        // Initialising dist list with a large number to\n        // indicate the nodes are unvisited initially.\n        // This list contains distance from source to the nodes.\n        vector&lt;int&gt; dist(V, 1e9); \n        \n        st.insert({0, S}); \n\n        // Source initialised with dist=0\n        dist[S] = 0;\n        \n        // Now, erase the minimum distance node first from the set\n        // and traverse for all its adjacent nodes.\n        while(!st.empty()) {\n            auto it = *(st.begin()); \n            int node = it.second; \n            int dis = it.first; \n            st.erase(it); \n            \n            // Check for all adjacent nodes of the erased\n            // element whether the prev dist is larger than current or not.\n            for(auto it : adj[node]) {\n                int adjNode = it[0]; \n                int edgW = it[1]; \n                \n                if(dis + edgW &lt; dist[adjNode]) {\n                    // erase if it was visited previously at \n                    // a greater cost.\n                    if(dist[adjNode] != 1e9) \n                        st.erase({dist[adjNode], adjNode}); \n                        \n                    // If current distance is smaller,\n                    // push it into the queue\n                    dist[adjNode] = dis + edgW; \n                    st.insert({dist[adjNode], adjNode}); \n                 }\n            }\n        }\n        // Return the list containing shortest distances\n        // from source to all the nodes.\n        return dist; \n    }\n};\n\nint main()\n{\n    // Driver code.\n    int V = 3, E = 3, S = 2;\n    vector&lt;vector&lt;int&gt;&gt; adj[V];\n    vector&lt;vector&lt;int&gt;&gt; edges;\n    vector&lt;int&gt; v1{1, 1}, v2{2, 6}, v3{2, 3}, v4{0, 1}, v5{1, 3}, v6{0, 6};\n    int i = 0;\n    adj[0].push_back(v1);\n    adj[0].push_back(v2);\n    adj[1].push_back(v3);\n    adj[1].push_back(v4);\n    adj[2].push_back(v5);\n    adj[2].push_back(v6);\n\n    Solution obj;\n    vector&lt;int&gt; res = obj.dijkstra(V, adj, S);\n\n    for (int i = 0; i &lt; V; i++)\n    {\n        cout &lt;&lt; res[i] &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>4 3 0</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>This set approach cannot be implemented in <strong>JAVA </strong>by using TreeSet or HashSet. For implementing Dijkstra\u2019s Algorithm in<strong> JAVA</strong>, we would use a priority queue only.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity :</strong> O( E log(V) )&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where E = Number of edges and V = Number of Nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity :</strong> O( |E| + |V| )&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where E = Number of edges and V = Number of Nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/priyanshi-goel-7b6a42210/\" target=\"_blank\" rel=\"noreferrer noopener\">Priyanshi Goel</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\" target=\"_blank\" rel=\"noreferrer noopener\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->\n\n<!-- wp:embed {\"url\":\"https://www.youtube.com/watch?v=PATgNiuTP20\\u0026list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn\\u0026index=33\",\"type\":\"video\",\"providerNameSlug\":\"youtube\",\"responsive\":true,\"className\":\"wp-embed-aspect-16-9 wp-has-aspect-ratio\"} -->\n<figure class=\"wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio\"><div class=\"wp-block-embed__wrapper\">\nhttps://www.youtube.com/watch?v=PATgNiuTP20&amp;list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&amp;index=33\n</div></figure>\n<!-- /wp:embed -->"
}