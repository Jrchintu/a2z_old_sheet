{
    "dislikes": 5,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:11:53 GMT+0530 (India Standard Time)",
    "slug": "palindrome-partitioning-ii-front-partition-dp-53",
    "aid": "2185",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/palindrome-partitioning-ii-",
    "title": "Palindrome Partitioning - II | Front Partition : DP 53",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "likes": 29,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s. Examples Example 1: I...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong> s = \u201cbababcbadcede\u201d\n<strong>Output</strong>: 4\n<strong>Explanation:</strong> If we do 4 partitions in the following way, \neach substring of the partition will be a palindrome.\nbab | abcba | d | c | ede</pre>\n<pre class=\"wp-block-preformatted\"><strong>Input</strong>: s = \"aab\"\n<strong>Output</strong>: 1\n<strong>Explanation</strong>: If we do 1 partition in the following way, \neach substring of the partition will be a palindrome.\naa | b</pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/palindrome-partitioning-ll_873266?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nRecursive approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nMemoization approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nTabulation Approach\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nRecursive Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<p>In order to solve this problem, we need to partition the given string in such a way that every substring of the partition becomes a palindrome. For example, if the string \u201caabb\u201d is given, one of the valid partitions will be \u201caa | b | b\u201d.&nbsp;</p>\n<p>Now, one key point to notice here is that we can make every substring of any string a palindrome, by partitioning it n-1 times(where n = size of the string). For example, if the given string is \u201cabcd\u201d and if we partition it n-1 i.e. (4-1 = 3) times, it will be like the following:<br>a | b | c | d. Here, every single substring of the partitions is a palindrome.</p>\n<p><em>So, we can conclude that it is very much possible all the time to partition a string in such a way that every substring becomes a palindrome and we can also assure that the answer always exists.</em>&nbsp;</p>\n<p>Here, in this question, it is clearly mentioned that we need to figure out the minimum number of such partitions. Consider the example given below:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173047.png\" alt=\"\" class=\"wp-image-7241\"/></figure>\n<h3><strong>Intuition:</strong></h3>\n<p>This type of problem is generally solved using the <strong><em>front partition</em></strong>. Following the front partition technique, we will start checking from the first index of the given string and will check if we can make a partition between the first and the second index. Similarly, then we will include the second index in the account and check if we can make a partition between the second and the third index. This process will continue to the last index.&nbsp;</p>\n<p><strong><em>The condition for a partition to be valid is that the left part of the partition must be a palindromic substring.&nbsp;</em></strong></p>\n<p>The following illustration will depict the process of partitioning:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173149.png\" alt=\"\" class=\"wp-image-7242\"/></figure>\n<p>We have found the right approach so far. Now, let us quickly discuss the rules to solve this problem:</p>\n<ol><li>Express everything(i.e. the given string) in terms of the index.</li><li>Try all partitions.</li><li>Return the best possible answer of all partitions (the answer that comes after dividing the problem into subproblems and solving them recursively).<br>Derive the base case as well.</li></ol>\n<p><strong>Express everything(i.e. the given string) in terms of the index:</strong></p>\n<p>We are given a string. Now, following the front partition rules we will place i to index 0 i.e. the first index. The function will look like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173256.png\" alt=\"\" class=\"wp-image-7243\"/></figure>\n<h5><strong>Try all partitions:</strong></h5>\n<p>As we have figured out the logic for marking the pointer, i, we will move to the partitioning loop. We can simply write a for loop(say j) starting from i to n-1(n = size of the string), The problem is being broken in the following manner:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173359.png\" alt=\"\" class=\"wp-image-7244\"/></figure>\n<p><strong>Base case: </strong>When the index i will be equal to the size of the string(i.e. i == n), we can say there are no more characters left to be partitioned. So, this is the base case and in this case, the function will return 0.</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173538.png\" alt=\"\" class=\"wp-image-7245\"/></figure>\n<h5><strong>Return the best possible answer of all partitions:</strong></h5>\n<p>A partition is possible when the left substring of that partition is a palindrome. Now, inside the partitioning loop, we will check if the partition can be done at index j(i.e. We will check if the substring starts from index i and ends at index j is a palindrome or not). If it is done, we will add 1 to our answer, and then we will again follow the same method for the left-over substring.</p>\n<p>Here, in the question, it is clearly mentioned that we need the minimum number of partitions. So, calculating all possible answers using the above method, we will take the minimum into our consideration.</p>\n<p>The recurrence logic will be the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173728.png\" alt=\"\" class=\"wp-image-7246\"/></figure>\n<h5><strong>Note about the final answer:</strong></h5>\n<p>If we carefully observe, we can notice that our function is actually counting an extra partition at the end of the string in each case. For example, the given string is \u201cabcd\u201d. After doing a partition after \u2018c\u2019 the function will check if a partition can be done after \u2018d\u2019 to check if the last substring i.e. \u2018d\u2019 itself is a palindrome. Consider the following illustration:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-173834.png\" alt=\"\" class=\"wp-image-7247\"/></figure>\n<p>For that our function will return 4 as the answer, instead of the actual answer is 3.&nbsp;</p>\n<p><strong>So, our actual answer will be (number of partitions returned by the function - 1).</strong></p>\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<p><strong>Approach</strong>:&nbsp;</p>\n<p><strong>The recursive algorithm steps are as follows:</strong></p>\n<ol><li>Convert the problem to a recursive function marked by the pointer i.</li><li>Use a loop to check all possible partitions of the string and calculate the number of partitions.</li><li>Return the minimum number of partitions counted.</li><li><strong>Base case: </strong>When the index i will be equal to the size of the string(i.e. i == n), we can say there are no more characters left to be partitioned. So, this is the base case and in this case, the function will return 0.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring is a palindrome.\nbool isPalindrome(int i, int j, string &amp;s) {\n    while (i &lt; j) {\n        if (s[i] != s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive function to find the minimum number of partitions to make palindromes.\nint minPartitions(int i, int n, string &amp;str) {\n    // Base case: If we've reached the end of the string.\n    if (i == n) return 0;\n\n    int minCost = INT_MAX;\n    // Consider all possible substrings starting from the current index.\n    for (int j = i; j &lt; n; j++) {\n        if (isPalindrome(i, j, str)) {\n            // If the substring is a palindrome, calculate the cost and minimize it.\n            int cost = 1 + minPartitions(j + 1, n, str);\n            minCost = min(minCost, cost);\n        }\n    }\n    return minCost;\n}\n\n// Main function to find the minimum number of partitions for palindrome partitioning.\nint palindromePartitioning(string str) {\n    int n = str.size();\n    // Calling the recursive function and subtracting 1 as it counts partitions, not cuts.\n    return minPartitions(0, n, str) - 1;\n}\n\nint main() {\n    string str = \"BABABCBADCEDE\";\n    int partitions = palindromePartitioning(str);\n    cout &lt;&lt; \"The minimum number of partitions: \" &lt;&lt; partitions &lt;&lt; \"\\n\";\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class PalindromePartitioning {\n    static boolean isPalindrome(int i, int j, String s) {\n        while (i &lt; j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    static int f(int i, int n, String str) {\n        // Base case:\n        if (i == n) return 0;\n\n        int minCost = Integer.MAX_VALUE;\n        // String[i...j]\n        for (int j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                int cost = 1 + f(j + 1, n, str);\n                minCost = Math.min(minCost, cost);\n            }\n        }\n        return minCost;\n    }\n\n    static int palindromePartitioning(String str) {\n        int n = str.length();\n        return f(0, n, str) - 1;\n    }\n\n    public static void main(String[] args) {\n        String str = \"BABABCBADCEDE\";\n        int partitions = palindromePartitioning(str);\n        System.out.println(\"The minimum number of partitions: \" + partitions);\n    }\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef is_palindrome(i, j, s):\n    # Helper function to check if a substring s[i...j] is a palindrome\n    while i &lt; j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef f(i, n, s):\n    # Base case: If we reach the end of the string, no further partition is needed\n    if i == n:\n        return 0\n\n    min_cost = float('inf')\n    \n    # Iterate over possible substrings starting from index i\n    for j in range(i, n):\n        if is_palindrome(i, j, s):\n            # If s[i...j] is a palindrome, calculate the cost\n            cost = 1 + f(j + 1, n, s)\n            min_cost = min(min_cost, cost)\n\n    return min_cost\n\ndef palindrome_partitioning(s):\n    # Main function to find the minimum number of partitions\n    n = len(s)\n    return f(0, n, s) - 1  # Subtract 1 to exclude the initial unpartitioned string\n\nif __name__ == \"__main__\":\n    str = \"BABABCBADCEDE\"\n    partitions = palindrome_partitioning(str)\n    print(\"The minimum number of partitions:\", partitions)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\n// Function to check if a substring from index i to j is a palindrome\nfunction isPalindrome(i, j, s) {\n    while (i &lt; j) {\n        if (s[i] !== s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Function to find the minimum number of partitions needed to make palindromes\nfunction palindromePartitioning(str) {\n    // Function f to recursively calculate the minimum number of partitions\n    function f(i, n, str) {\n        // Base case: If i reaches the end of the string, return 0\n        if (i === n) return 0;\n\n        let minCost = Infinity;\n\n        // Check all possible substrings starting from index i\n        for (let j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                // Calculate the cost for the current partition\n                const cost = 1 + f(j + 1, n, str);\n                minCost = Math.min(minCost, cost);\n            }\n        }\n\n        return minCost;\n    }\n\n    const n = str.length;\n\n    // Call the recursive function with initial values and subtract 1 from the result\n    return f(0, n, str) - 1;\n}\n\n// Main function\nfunction main() {\n    const str = \"BABABCBADCEDE\";\n    const partitions = palindromePartitioning(str);\n    console.log(\"The minimum number of partitions:\", partitions);\n}\n\n// Call the main function\nmain();\n</code>\n</pre>\n</div>\n\n<p>\n<!-- Insert Output of Brute Force Here -->\nThe minimum number of partitions: 4 (Given string: \"BABABCBADCEDE\")\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n<p><strong>Time Complexity: Exponential</strong></p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemoization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<p><strong>Steps to memoize the recursive solution:</strong></p>\n<ol><li>Create a 1D dp array of size [n] i can range from 0 to n-1. So we take the size n.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to a particular parameter (say f(i)), we first check whether the answer is already calculated using the dp array(i.e dp[i] != -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i] to the solution we get.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring is a palindrome.\nbool isPalindrome(int i, int j, string &amp;s) {\n    while (i &lt; j) {\n        if (s[i] != s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Recursive function to find the minimum number of partitions to make palindromes.\nint minPartitions(int i, int n, string &amp;str, vector&lt;int> &amp;dp) {\n    // Base case: If we've reached the end of the string.\n    if (i == n) return 0;\n\n    if (dp[i] != -1) return dp[i];\n    int minCost = INT_MAX;\n    // Consider all possible substrings starting from the current index.\n    for (int j = i; j &lt; n; j++) {\n        if (isPalindrome(i, j, str)) {\n            // If the substring is a palindrome, calculate the cost and minimize it.\n            int cost = 1 + minPartitions(j + 1, n, str, dp);\n            minCost = min(minCost, cost);\n        }\n    }\n    return dp[i] = minCost;\n}\n\n// Main function to find the minimum number of partitions for palindrome partitioning.\nint palindromePartitioning(string str) {\n    int n = str.size();\n    vector&lt;int> dp(n, -1);\n    // Calling the recursive function and subtracting 1 as it counts partitions, not cuts.\n    return minPartitions(0, n, str, dp) - 1;\n}\n\nint main() {\n    string str = \"BABABCBADCEDE\";\n    int partitions = palindromePartitioning(str);\n    cout &lt;&lt; \"The minimum number of partitions: \" &lt;&lt; partitions &lt;&lt; \"\\n\";\n    return 0;\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class PalindromePartitioning {\n    static boolean isPalindrome(int i, int j, String s) {\n        while (i &lt; j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    static int f(int i, int n, String str, int[] dp) {\n        // Base case:\n        if (i == n) return 0;\n\n        if (dp[i] != -1) return dp[i];\n        int minCost = Integer.MAX_VALUE;\n        // String[i...j]\n        for (int j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                int cost = 1 + f(j + 1, n, str, dp);\n                minCost = Math.min(minCost, cost);\n            }\n        }\n        return dp[i] = minCost;\n    }\n\n    static int palindromePartitioning(String str) {\n        int n = str.length();\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n        return f(0, n, str, dp) - 1;\n    }\n\n    public static void main(String[] args) {\n        String str = \"BABABCBADCEDE\";\n        int partitions = palindromePartitioning(str);\n        System.out.println(\"The minimum number of partitions: \" + partitions);\n    }\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef is_palindrome(i, j, s):\n    # Helper function to check if a substring s[i...j] is a palindrome\n    while i &lt; j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef f(i, n, s, dp):\n    # Base case: If we reach the end of the string, no further partition is needed\n    if i == n:\n        return 0\n\n    if dp[i] != -1:\n        return dp[i]\n    \n    min_cost = float('inf')\n    \n    # Iterate over possible substrings starting from index i\n    for j in range(i, n):\n        if is_palindrome(i, j, s):\n            # If s[i...j] is a palindrome, calculate the cost\n            cost = 1 + f(j + 1, n, s, dp)\n            min_cost = min(min_cost, cost)\n\n    dp[i] = min_cost\n    return dp[i]\n\ndef palindrome_partitioning(s):\n    # Main function to find the minimum number of partitions\n    n = len(s)\n    dp = [-1] * n  # Initialize a memoization array with -1\n    return f(0, n, s, dp) - 1  # Subtract 1 to exclude the initial unpartitioned string\n\nif __name__ == \"__main__\":\n    str = \"BABABCBADCEDE\"\n    partitions = palindrome_partitioning(str)\n    print(\"The minimum number of partitions:\", partitions)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\n\n// Function to check if a substring from index i to j is a palindrome\nfunction isPalindrome(i, j, s) {\n    while (i &lt; j) {\n        if (s[i] !== s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Function to find the minimum number of partitions needed to make palindromes\nfunction palindromePartitioning(str) {\n    // Function f with memoization\n    function f(i, n, str, dp) {\n        // Base case: If i reaches the end of the string, return 0\n        if (i === n) return 0;\n\n        // Check if the result for this subproblem is already computed\n        if (dp[i] !== -1) return dp[i];\n\n        let minCost = Infinity;\n\n        // Check all possible substrings starting from index i\n        for (let j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                // Calculate the cost for the current partition\n                const cost = 1 + f(j + 1, n, str, dp);\n                minCost = Math.min(minCost, cost);\n            }\n        }\n\n        // Store the result in the memoization table\n        dp[i] = minCost;\n        return minCost;\n    }\n\n    const n = str.length;\n    const dp = new Array(n).fill(-1);\n\n    // Call the recursive function with initial values and subtract 1 from the result\n    return f(0, n, str, dp) - 1;\n}\n\n// Main function\nfunction main() {\n    const str = \"BABABCBADCEDE\";\n    const partitions = palindromePartitioning(str);\n    console.log(\"The minimum number of partitions:\", partitions);\n}\n\n// Call the main function\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\nThe minimum number of partitions: 4 (Given string: \"BABABCBADCEDE\")\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n<p><strong>Time Complexity: </strong>O(N<sup>2</sup>)<br><strong>Reason:</strong> There are a total of N states and inside each state, a loop of size N(apparently) is running.</p>\n<p><strong>Space Complexity: </strong>O(N) + Auxiliary stack space O(N)<br><strong>Reason: </strong>The first O(N) is for the dp array of size N.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Optimal Approach Here -->\n<p><strong>Tabulation:</strong></p>\n<ol><li>First of all, we handle the base case. If (i == n) we return 0. To cover this case we can initialize the entire dp array with 0.<br><strong><em>Here, as we are checking </em></strong><strong>dp[j+1] </strong><strong><em>&nbsp;every time, the function will give a runtime error if </em></strong><strong>j = n-1</strong><strong><em>. To avoid this, we will take the array size as </em></strong><strong>n+1</strong><strong><em> instead of </em></strong><strong>n</strong><strong><em>.</em></strong></li><li>Next, memoization is a top-down approach, whereas tabulation is bottom-up. Our changing parameter i will change in opposite directions, i.e i will change from n-1\u21920.</li><li>Next, we copy down the recursive logic(recurrence) inside the loop.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring is a palindrome.\nbool isPalindrome(int i, int j, string &amp;s) {\n    while (i &lt; j) {\n        if (s[i] != s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Function to find the minimum number of partitions for palindrome partitioning.\nint palindromePartitioning(string str) {\n    int n = str.size();\n    // Create a DP array to store the minimum number of partitions.\n    vector&lt;int> dp(n + 1, 0);\n    dp[n] = 0; // Initialize the last element to 0.\n\n    // Loop through the string in reverse order.\n    for (int i = n - 1; i >= 0; i--) {\n        int minCost = INT_MAX;\n        // Consider all possible substrings starting from the current index.\n        for (int j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                // If the substring is a palindrome, calculate the cost and minimize it.\n                int cost = 1 + dp[j + 1];\n                minCost = min(minCost, cost);\n            }\n        }\n        dp[i] = minCost;\n    }\n    // Subtract 1 as it counts partitions, not cuts.\n    return dp[0] - 1;\n}\n\nint main() {\n    string str = \"BABABCBADCEDE\";\n    int partitions = palindromePartitioning(str);\n    cout &lt;&lt; \"The minimum number of partitions: \" &lt;&lt; partitions &lt;&lt; \"\\n\";\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class PalindromePartitioning {\n    static boolean isPalindrome(int i, int j, String s) {\n        while (i &lt; j) {\n            if (s.charAt(i) != s.charAt(j)) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n    static int palindromePartitioning(String str) {\n        int n = str.length();\n        int[] dp = new int[n + 1];\n        dp[n] = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            int minCost = Integer.MAX_VALUE;\n            // String[i...j]\n            for (int j = i; j &lt; n; j++) {\n                if (isPalindrome(i, j, str)) {\n                    int cost = 1 + dp[j + 1];\n                    minCost = Math.min(minCost, cost);\n                }\n            }\n            dp[i] = minCost;\n        }\n        return dp[0] - 1;\n    }\n\n    public static void main(String[] args) {\n        String str = \"BABABCBADCEDE\";\n        int partitions = palindromePartitioning(str);\n        System.out.println(\"The minimum number of partitions: \" + partitions);\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef is_palindrome(i, j, s):\n    # Helper function to check if a substring s[i...j] is a palindrome\n    while i &lt; j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef palindrome_partitioning(s):\n    # Main function to find the minimum number of partitions\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[n] = 0  # Initialize the last element of dp to 0\n    for i in range(n - 1, -1, -1):  # Start from the second-to-last element and move backward\n        min_cost = float('inf')\n        # Iterate over possible substrings starting from index i\n        for j in range(i, n):\n            if is_palindrome(i, j, s):\n                # If s[i...j] is a palindrome, calculate the cost\n                cost = 1 + dp[j + 1]\n                min_cost = min(min_cost, cost)\n        dp[i] = min_cost\n\n    return dp[0] - 1  # Subtract 1 to exclude the initial unpartitioned string\n\nif __name__ == \"__main__\":\n    str = \"BABABCBADCEDE\"\n    partitions = palindrome_partitioning(str)\n    print(\"The minimum number of partitions:\", partitions)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\n\n// Function to check if a substring from index i to j is a palindrome\nfunction isPalindrome(i, j, s) {\n    while (i &lt; j) {\n        if (s[i] !== s[j]) return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\n// Function to find the minimum number of partitions needed to make palindromes\nfunction palindromePartitioning(str) {\n    const n = str.length;\n\n    // Create an array dp to store the minimum number of partitions\n    const dp = new Array(n + 1).fill(0);\n\n    // Initialize dp[n] as 0 (no partitions needed for an empty string)\n    dp[n] = 0;\n\n    // Loop from the end of the string to the beginning\n    for (let i = n - 1; i >= 0; i--) {\n        let minCost = Infinity;\n\n        // Check all possible substrings starting from index i\n        for (let j = i; j &lt; n; j++) {\n            if (isPalindrome(i, j, str)) {\n                // Calculate the cost for the current partition\n                const cost = 1 + dp[j + 1];\n                minCost = Math.min(minCost, cost);\n            }\n        }\n\n        // Store the minimum cost for the current substring\n        dp[i] = minCost;\n    }\n\n    // The result is stored in dp[0] - 1\n    return dp[0] - 1;\n}\n\n// Main function\nfunction main() {\n    const str = \"BABABCBADCEDE\";\n    const partitions = palindromePartitioning(str);\n    console.log(\"The minimum number of partitions:\", partitions);\n}\n\n// Call the main function\nmain();\n\n</code>\n</pre>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\nThe minimum number of partitions: 4 (Given string: \"BABABCBADCEDE\")\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n<p><strong>Time Complexity: </strong>O(N<sup>2</sup>)<br><strong>Reason:</strong> There are a total of N states and inside each state a loop of size N(apparently) is running.</p>\n<p><strong>Space Complexity: </strong>O(N)<br><strong>Reason: </strong>O(N) is for the dp array we have used.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Palindrome Partitioning - II\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/_H8V5hJUGd0?si=qAa1_6fcDnKLkOwi\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/_H8V5hJUGd0?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Palindrome Partitioning - II\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/_H8V5hJUGd0?si=qAa1_6fcDnKLkOwi\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}