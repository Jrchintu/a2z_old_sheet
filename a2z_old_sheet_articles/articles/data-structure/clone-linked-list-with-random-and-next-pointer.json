{
    "dislikes": 4,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:59 GMT+0530 (India Standard Time)",
    "slug": "clone-linked-list-with-random-and-next-pointer",
    "aid": "1643",
    "title": "Clone Linked List with Random and Next Pointer",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/clone-a-ll-with-random-and-next-pointer",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "linked-list",
            "topic-title": "Linked List"
        }
    ],
    "content": "<p><strong>Problem Statement: </strong>Given a linked list where every node in the linked list contains two pointers:\n<ol><li>\u2018next\u2019 which points to the next node in the list.</li>\n<li>\u2018random\u2019 which points to a random node in the list or \u2018null\u2019.</li></ol></p>\n<p>Create a \u2018deep copy\u2019 of the given linked list and return it.\n</p>\n\n\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\n                <span><strong>Input:</strong>\n                </span>\n\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image1-d3icDCNR\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n               \n                <span><strong>Output:</strong>\n                </span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image2-TL-UUxaT\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Explanation: </strong>  A deep copy of the linked list has to be created while maintaining all \u2018next\u2019 and \u2018random\u2019 pointers to the appropriate new nodes. Additional memory allocation is done while creating a duplicate set of nodes and managing their pointer relationships.</span>\n                \n                <br>\n                <span><strong>Example 2:</strong></span>\n                <span><strong>Input:</strong></span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image3-wZkb9w3Y\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                \n                \n                <span><strong>Output: </strong></span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image4-Srm3x48_\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Explanation: </strong> A deep copy of the linked list has to be created while maintaining all \u2018next\u2019 and \u2018random\u2019 pointers to the appropriate new nodes. Additional memory allocation is done while creating a duplicate set of nodes and managing their pointer relationships.</span>\n                \n            </pre>\n        </div>\n    </details>\n</div>\n\n\n<!-- This is Practice Section\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n         \n        <a href=\"https://www.codingninjas.com/studio/problems/power-of-numbers_8157729?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\" alt=\"code-studio\">\n        </a>\n    </div>\n    \n</div>-->\n\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out yourself first. </em></p>\n\n\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n    <!-- Approach - 1 Starts from here -->\n    <div id=\"brute-force-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    <!-- Change Name Here -->\n                   Brute Force Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        \n                        <p>To create a deep copy of the original linked list we can use a map to establish a relationship between original nodes and their copied nodes.</p>\n                        <p>We traverse the list first to create a copied node for each original node then traverse and establish the correct connections between the copied nodes similar to the arrangement of next and random pointers of the original pointers. In the end, return the head of the copied list obtained from the map.</p>\n\n                        <h4>Algorithm </h4>\n                        <p><strong>Step 1:</strong>Initialise variables \u2018temp\u2019 as a pointer to the head of the original linked list to traverse it. Create an empty unordered_map, to map original nodes to their corresponding copied nodes.</p>\n                        \n                        <p><strong>Step 2: </strong>  Iterate through the original linked list and for each node in the linked list create a new node with the same data value as the original data. Map the original node to its copied node in the map.</p> \n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image5-L10gpaF6\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 3: </strong>\n                         Iterate through the original list again but this time connect the pointers of the copied nodes in the same arrangement as the original node.\n                         <ol><li>Get the copied node corresponding to the original node using the map.</li><li>Set the next pointer of the copied node to the copied node mapped to the original node\u2019s next node.</li><li>Set the random pointer of the copied node to the original node\u2019s next node copied from the map.</li></ol></p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image6--TZrTy11\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\n                        <p><strong>Step 4: </strong>\n                         Return the head of the deep copied list which is obtained by retrieving the copied nodes mapped to the original head from the map.</p>\n                        \n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Node class to represent\n// elements in the linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;           \n     // Pointer to the next node\n    Node *next;        \n    // Pointer to a random\n    // node in the list\n    Node *random;       \n\n    // Constructors for Node class\n    Node() : data(0), next(nullptr), random(nullptr){}; \n    Node(int x) : data(x), next(nullptr), random(nullptr) {} \n    // Constructor with data,\n    // next, and random pointers\n    Node(int x, Node *nextNode, Node *randomNode) :\n            data(x), next(nextNode), random(randomNode) {}  \n};\n\n\n// Function to clone the linked list\nNode *cloneLL(Node *head){\n    Node* temp = head;\n    // Create an unordered_map to map original\n    // nodes to their corresponding copied nodes\n    unordered_map&lt;Node*, Node*&gt; mpp;\n\n    // Step 1: Create copies of each node\n    // and store them in the map\n    while(temp != NULL){\n        // Create a new node with the\n        // same data as the original node\n        Node* newNode = new Node(temp-&gt;data);\n        // Map the original node to its\n        // corresponding copied node in the map\n        mpp[temp] = newNode;\n        // Move to the next node in the original list\n        temp = temp-&gt;next;\n    }\n    \n    temp = head;\n    // Step 2: Connect the next and random\n    // pointers of the copied nodes using the map\n    while(temp != NULL){\n        // Access the copied node corresponding\n        // to the current original node\n        Node* copyNode = mpp[temp];\n        // Set the next pointer of the copied node\n        // to the copied node mapped to the\n        // next node in the original list\n        copyNode-&gt;next = mpp[temp-&gt;next];\n        // Set the random pointer of the copied node\n        // to the copied node mapped to the\n        // random node in the original list\n        copyNode-&gt;random = mpp[temp-&gt;random];\n        // Move to the next node\n        // in the original list\n        temp = temp-&gt;next;\n    }\n    \n    // Return the head of the\n    // deep copied list from the map\n    return mpp[head];\n}\n\n\n// Function to print the cloned linked list\nvoid printClonedLinkedList(Node *head) {\n    while (head != nullptr) {\n        cout &lt;&lt; &quot;Data: &quot; &lt;&lt; head-&gt;data;\n        if (head-&gt;random != nullptr) {\n            cout &lt;&lt; &quot;, Random: &quot; &lt;&lt; head-&gt;random-&gt;data;\n        } else {\n            cout &lt;&lt; &quot;, Random: nullptr&quot;;\n        }\n        cout &lt;&lt; endl;\n         // Move to the next node\n        head = head-&gt;next;  \n    }\n}\n\n// Main function\nint main() {\n    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    Node* head = new Node(7);\n    head-&gt;next = new Node(14);\n    head-&gt;next-&gt;next = new Node(21);\n    head-&gt;next-&gt;next-&gt;next = new Node(28);\n\n    // Assigning random pointers\n    head-&gt;random = head-&gt;next-&gt;next;\n    head-&gt;next-&gt;random = head;\n    head-&gt;next-&gt;next-&gt;random = head-&gt;next-&gt;next-&gt;next;\n    head-&gt;next-&gt;next-&gt;next-&gt;random = head-&gt;next;\n\n    cout &lt;&lt; &quot;Original Linked List with Random Pointers:&quot; &lt;&lt; endl;\n    printClonedLinkedList(head);\n\n    // Clone the linked list\n    Node* clonedList = cloneLL(head);\n\n    cout &lt;&lt; &quot;\\nCloned Linked List with Random Pointers:&quot; &lt;&lt; endl;\n    printClonedLinkedList(clonedList);\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.HashMap;\n\n// Node class to represent\n// elements in the linked list\nclass Node {\n    // Data stored in the node\n    int data;\n    // Pointer to the next node\n    Node next;\n    // Pointer to a random node in the list\n    Node random;\n\n    // Constructors for Node class\n    Node() {\n        this.data = 0;\n        this.next = null;\n        this.random = null;\n    }\n\n    Node(int x) {\n        this.data = x;\n        this.next = null;\n        this.random = null;\n    }\n\n    Node(int x, Node nextNode, Node randomNode) {\n        this.data = x;\n        this.next = nextNode;\n        this.random = randomNode;\n    }\n}\n\npublic class Main {\n    // Function to clone the linked list\n    public static Node cloneLL(Node head) {\n        Node temp = head;\n        // Create a HashMap to map original nodes\n        // to their corresponding copied nodes\n        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();\n\n        // Step 1: Create copies of each\n        // node and store them in the map\n        while (temp != null) {\n            // Create a new node with the\n            // same data as the original node\n            Node newNode = new Node(temp.data);\n            // Map the original node to its\n            // corresponding copied node in the map\n            map.put(temp, newNode);\n            // Move to the next node in the original list\n            temp = temp.next;\n        }\n\n        temp = head;\n        // Step 2: Connect the next and random\n        // pointers of the copied nodes using the map\n        while (temp != null) {\n            // Access the copied node corresponding\n            // to the current original node\n            Node copyNode = map.get(temp);\n            // Set the next pointer of the copied node\n            // to the copied node mapped to the\n            // next node in the original list\n            copyNode.next = map.get(temp.next);\n            // Set the random pointer of the copied node\n            // to the copied node mapped to the\n            // random node in the original list\n            copyNode.random = map.get(temp.random);\n            // Move to the next node in the original list\n            temp = temp.next;\n        }\n\n        // Return the head of the\n        // deep copied list from the map\n        return map.get(head);\n    }\n\n    // Function to print the cloned linked list\n    public static void printClonedLinkedList(Node head) {\n        while (head != null) {\n            System.out.print(&quot;Data: &quot; + head.data);\n            if (head.random != null) {\n                System.out.print(&quot;, Random: &quot; + head.random.data);\n            } else {\n                System.out.print(&quot;, Random: nullptr&quot;);\n            }\n            System.out.println();\n            // Move to the next node in the list\n            head = head.next;\n        }\n    }\n\n    // Main function\n    public static void main(String[] args) {\n        // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n        Node head = new Node(7);\n        head.next = new Node(14);\n        head.next.next = new Node(21);\n        head.next.next.next = new Node(28);\n\n        // Assigning random pointers\n        head.random = head.next.next;\n        head.next.random = head;\n        head.next.next.random = head.next.next.next;\n        head.next.next.next.random = head.next;\n\n        System.out.println(&quot;Original Linked List with Random Pointers:&quot;);\n        printClonedLinkedList(head);\n\n        // Clone the linked list\n        Node clonedList = cloneLL(head);\n\n        System.out.println(&quot;\\nCloned Linked List with Random Pointers:&quot;);\n        printClonedLinkedList(clonedList);\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n# Node class to represent\n# elements in the linked list\nclass Node:\n    def __init__(self, x, nextNode=None, randomNode=None):\n        # Data stored in the node\n        self.data = x\n        # Pointer to the next node\n        self.next = nextNode\n        # Pointer to a random\n        # node in the list\n        self.random = randomNode\n\n\n# Function to clone the linked list\ndef cloneLL(head):\n    temp = head\n    # Create a dictionary to map original\n    # nodes to their corresponding copied nodes\n    mpp = {}\n\n    # Step 1: Create copies of each node\n    # and store them in the map\n    while temp is not None:\n        # Create a new node with the\n        # same data as the original node\n        newNode = Node(temp.data)\n        # Map the original node to its\n        # corresponding copied node in the dictionary\n        mpp[temp] = newNode\n        # Move to the next node in the original list\n        temp = temp.next\n\n    temp = head\n    # Step 2: Connect the next and random\n    # pointers of the copied nodes using the dictionary\n    while temp is not None:\n        # Access the copied node corresponding\n        # to the current original node\n        copyNode = mpp[temp]\n        # Set the next pointer of the copied node\n        # to the copied node mapped to the\n        # next node in the original list\n        copyNode.next = mpp[temp.next]\n        # Set the random pointer of the copied node\n        # to the copied node mapped to the\n        # random node in the original list\n        copyNode.random = mpp[temp.random]\n        # Move to the next node\n        # in the original list\n        temp = temp.next\n\n    # Return the head of the\n    # deep copied list from the dictionary\n    return mpp[head]\n\n\n# Function to print the cloned linked list\ndef printClonedLinkedList(head):\n    while head is not None:\n        print(f&quot;Data: {head.data}&quot;, end=&quot;&quot;)\n        if head.random is not None:\n            print(f&quot;, Random: {head.random.data}&quot;)\n        else:\n            print(&quot;, Random: nullptr&quot;)\n        head = head.next\n\n\n# Main function\nif __name__ == &quot;__main__&quot;:\n    # Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    head = Node(7)\n    head.next = Node(14)\n    head.next.next = Node(21)\n    head.next.next.next = Node(28)\n\n    # Assigning random pointers\n    head.random = head.next.next\n    head.next.random = head\n    head.next.next.random = head.next.next.next\n    head.next.next.next.random = head.next\n\n    print(&quot;Original Linked List with Random Pointers:&quot;)\n    printClonedLinkedList(head)\n\n    # Clone the linked list\n    clonedList = cloneLL(head)\n\n    print(&quot;\\nCloned Linked List with Random Pointers:&quot;)\n    printClonedLinkedList(clonedList)\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node class to represent\n// elements in the linked list\nclass Node {\n    // Data stored in the node\n    constructor(data) {\n        this.data = data;\n        // Pointer to the next node\n        this.next = null;\n        // Pointer to a random node in the list\n        this.random = null;\n    }\n}\n\n// Function to clone the linked list\nfunction cloneLL(head) {\n    let temp = head;\n    // Create a map to map original nodes\n    // to their corresponding copied nodes\n    let mpp = new Map();\n\n    // Step 1: Create copies of each\n    // node and store them in the map\n    while (temp !== null) {\n        // Create a new node with the\n        // same data as the original node\n        let newNode = new Node(temp.data);\n        // Map the original node to its\n        // corresponding copied node in the map\n        mpp.set(temp, newNode);\n        // Move to the next node in the original list\n        temp = temp.next;\n    }\n\n    temp = head;\n    // Step 2: Connect the next and random\n    // pointers of the copied nodes using the map\n    while (temp !== null) {\n        // Access the copied node corresponding\n        // to the current original node\n        let copyNode = mpp.get(temp);\n        // Set the next pointer of the copied node\n        // to the copied node mapped to the next\n        // node in the original list\n        copyNode.next = mpp.get(temp.next);\n        // Set the random pointer of the copied node\n        // to the copied node mapped to the random\n        // node in the original list\n        copyNode.random = mpp.get(temp.random);\n        // Move to the next node in the original list\n        temp = temp.next;\n    }\n\n    // Return the head of the\n    // deep copied list from the map\n    return mpp.get(head);\n}\n\n// Function to print the cloned linked list\nfunction printClonedLinkedList(head) {\n    while (head !== null) {\n        console.log(`Data: ${head.data}` + (head.random !== null ? `,\n                        Random: ${head.random.data}` : `, Random: null`));\n        // Move to the next node in the list\n        head = head.next;\n    }\n}\n\n// Main function\nfunction main() {\n    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    let head = new Node(7);\n    head.next = new Node(14);\n    head.next.next = new Node(21);\n    head.next.next.next = new Node(28);\n\n    // Assigning random pointers\n    head.random = head.next.next;\n    head.next.random = head;\n    head.next.next.random = head.next.next.next;\n    head.next.next.next.random = head.next;\n\n    console.log(&quot;Original Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(head);\n\n    // Clone the linked list\n    let clonedList = cloneLL(head);\n\n    console.log(&quot;\\nCloned Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(clonedList);\n}\n\n// Calling the main function to execute the code\nmain();\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p><strong>Output: </strong>Original Linked List with Random Pointers: \n                        Data: 7, Random: 21\n                        Data: 14, Random: 7\n                        Data: 21, Random: 28\n                        Data: 28, Random: 14\n\n                        Cloned Linked List with Random Pointers:\n                        Data: 7, Random: 21\n                        Data: 14, Random: 7\n                        Data: 21, Random: 28\n                        Data: 28, Random: 14</p>\n\n\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(2N)</strong> where N is the number of nodes in the linked list. The linked list is traversed twice, once for creating copies of each node and for the second time to set the next and random pointers for each copied node. The time to access the nodes in the map is O(1) due to hashing.</p>\n\n                        <p><strong>Space Complexity : O(N)+O(N)</strong>where N is the number of nodes in the linked list as all nodes are stored in the map to maintain mappings and the copied linked lists takes O(N) space as well.</p>\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n    <!-- Approach - 1 Ends here -->\n\n\n    <!-- Approach - 2 Starts from here -->\n\n    <div id=\"optimal-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    Optimal Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        \n                        <p>The previous approach uses an extra space complexity of creating mappings between the original and copied nodes. Instead of creating duplicate nodes and storing them in a map, insert it in between the original node and the next node for quick access without the need for additional space.</p>\n                        <p>Traverse the list again to set the random pointer of copied nodes to the corresponding copied node duplicating the original arrangement. As a final traversal, separate the copied and original nodes by detaching alternate nodes.</p>\n\n                        <p><strong>Algorithm</strong></p>\n                        \n                        <p><strong>Step 1: </strong>\n                        Traverse the original node and create a copy of each node and insert it in between the original node and the next node.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image7-SRAygKPT\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                                             \n                        <p><strong>Step 2: </strong>Traverse this modified list and for each original node that has a random pointer, set the copied node\u2019s random pointer to the corresponding copies random node. If the original node\u2019s random pointer is full, set the copied node\u2019s random pointe to null as well.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image8-fQXkzRwq\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                              \n                        <p><strong>Step 3: Recursion</strong>Traverse the modified list again and extract the coped nodes by breaking the links between the original nodes and the copied nodes. Revert the original list to its initial state by fixing the next pointers.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/clone-a-ll-image9-0b0PPERt\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 4: </strong>Return the head of the deep copy obtained after extracting the copied nodes from the modified list.</p>           \n                        \n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\nusing namespace std;\n\n// Node class to represent\n// elements in the linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;           \n     // Pointer to the next node\n    Node *next;        \n    // Pointer to a random\n    // node in the list\n    Node *random;       \n\n    // Constructors for Node class\n    Node() : data(0), next(nullptr), random(nullptr){}; \n    Node(int x) : data(x), next(nullptr), random(nullptr) {} \n    // Constructor with data,\n    // next, and random pointers\n    Node(int x, Node *nextNode, Node *randomNode) :\n            data(x), next(nextNode), random(randomNode) {}  \n};\n\n// Function to insert a copy of each\n// node in between the original nodes\nvoid insertCopyInBetween(Node* head){\n    Node* temp = head;\n    while(temp != NULL){\n        Node* nextElement = temp-&gt;next;\n        // Create a new node with the same data\n        Node* copy = new Node(temp-&gt;data);  \n        \n        // Point the copy's next to\n        // the original node's next\n        copy-&gt;next = nextElement;  \n        \n        // Point the original\n        // node's next to the copy\n        temp-&gt;next = copy;         \n\n        // Move to the next original node\n        temp = nextElement;         \n    }\n}\n\n// Function to connect random\n// pointers of the copied nodes\nvoid connectRandomPointers(Node* head){\n    Node* temp = head;\n    while(temp != NULL){\n        // Access the copied node\n        Node* copyNode = temp-&gt;next;    \n        \n        // If the original node\n        // has a random pointer\n        if(temp-&gt;random){   \n             // Point the copied node's random to the\n             // corresponding copied random node\n            copyNode-&gt;random = temp-&gt;random-&gt;next; \n        }\n        else{\n             // Set the copied node's random to\n             // null if the original random is null\n            copyNode-&gt;random = NULL;   \n        }\n        \n         // Move to the next original node\n        temp = temp-&gt;next-&gt;next;   \n    }\n}\n\n// Function to retrieve the\n// deep copy of the linked list\nNode* getDeepCopyList(Node* head){\n    Node* temp = head;\n     // Create a dummy node\n    Node* dummyNode = new Node(-1);   \n    // Initialize a result pointer\n    Node* res = dummyNode;             \n\n    while(temp != NULL){\n        // Creating a new List by\n        // pointing to copied nodes\n        res-&gt;next = temp-&gt;next;\n        res = res-&gt;next;\n\n        // Disconnect and revert back to the\n        // initial state of the original linked list\n        temp-&gt;next = temp-&gt;next-&gt;next;\n        temp = temp-&gt;next;\n    }\n    \n     // Return the deep copy of the\n     // list starting from the dummy node\n    return dummyNode-&gt;next;   \n}\n\n// Function to clone the linked list\nNode *cloneLL(Node *head){\n    // If the original list\n    // is empty, return null\n    if(!head) return nullptr;   \n    \n     // Step 1: Insert copy of\n     // nodes in between\n    insertCopyInBetween(head); \n    // Step 2: Connect random\n    // pointers of copied nodes\n    connectRandomPointers(head);  \n    // Step 3: Retrieve the deep\n    // copy of the linked list\n    return getDeepCopyList(head); \n}\n\n// Function to print the cloned linked list\nvoid printClonedLinkedList(Node *head) {\n    while (head != nullptr) {\n        cout &lt;&lt; &quot;Data: &quot; &lt;&lt; head-&gt;data;\n        if (head-&gt;random != nullptr) {\n            cout &lt;&lt; &quot;, Random: &quot; &lt;&lt; head-&gt;random-&gt;data;\n        } else {\n            cout &lt;&lt; &quot;, Random: nullptr&quot;;\n        }\n        cout &lt;&lt; endl;\n         // Move to the next node\n        head = head-&gt;next;  \n    }\n}\n\n// Main function\nint main() {\n    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    Node* head = new Node(7);\n    head-&gt;next = new Node(14);\n    head-&gt;next-&gt;next = new Node(21);\n    head-&gt;next-&gt;next-&gt;next = new Node(28);\n\n    // Assigning random pointers\n    head-&gt;random = head-&gt;next-&gt;next;\n    head-&gt;next-&gt;random = head;\n    head-&gt;next-&gt;next-&gt;random = head-&gt;next-&gt;next-&gt;next;\n    head-&gt;next-&gt;next-&gt;next-&gt;random = head-&gt;next;\n\n    cout &lt;&lt; &quot;Original Linked List with Random Pointers:&quot; &lt;&lt; endl;\n    printClonedLinkedList(head);\n\n    // Clone the linked list\n    Node* clonedList = cloneLL(head);\n\n    cout &lt;&lt; &quot;\\nCloned Linked List with Random Pointers:&quot; &lt;&lt; endl;\n    printClonedLinkedList(clonedList);\n\n    return 0;\n}\n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\n// Node class to represent\n// elements in the linked list\nclass Node {\n    // Data stored in the node\n    int data;\n    // Pointer to the next node\n    Node next;\n    // Pointer to a random\n    // node in the list\n    Node random;\n\n    // Constructors for Node class\n    Node() {\n        // Default constructor\n        this.data = 0;\n        this.next = null;\n        this.random = null;\n    }\n\n    Node(int x) {\n        // Constructor with data\n        this.data = x;\n        this.next = null;\n        this.random = null;\n    }\n\n    Node(int x, Node nextNode, Node randomNode) {\n        // Constructor with data,\n        // next, and random pointers\n        this.data = x;\n        this.next = nextNode;\n        this.random = randomNode;\n    }\n}\n\n// Function to insert a copy of each\n// node in between the original nodes\nvoid insertCopyInBetween(Node head) {\n    Node temp = head;\n    while (temp != null) {\n        Node nextElement = temp.next;\n        // Create a new node with the same data\n        Node copy = new Node(temp.data);\n\n        // Point the copy's next to\n        // the original node's next\n        copy.next = nextElement;\n\n        // Point the original\n        // node's next to the copy\n        temp.next = copy;\n\n        // Move to the next original node\n        temp = nextElement;\n    }\n}\n\n// Function to connect random\n// pointers of the copied nodes\nvoid connectRandomPointers(Node head) {\n    Node temp = head;\n    while (temp != null) {\n        // Access the copied node\n        Node copyNode = temp.next;\n\n        // If the original node\n        // has a random pointer\n        if (temp.random != null) {\n            // Point the copied node's random to the\n            // corresponding copied random node\n            copyNode.random = temp.random.next;\n        } else {\n            // Set the copied node's random to\n            // null if the original random is null\n            copyNode.random = null;\n        }\n\n        // Move to the next original node\n        temp = temp.next.next;\n    }\n}\n\n// Function to retrieve the\n// deep copy of the linked list\nNode getDeepCopyList(Node head) {\n    Node temp = head;\n    // Create a dummy node\n    Node dummyNode = new Node(-1);\n    // Initialize a result pointer\n    Node res = dummyNode;\n\n    while (temp != null) {\n        // Creating a new List by\n        // pointing to copied nodes\n        res.next = temp.next;\n        res = res.next;\n\n        // Disconnect and revert back to the\n        // initial state of the original linked list\n        temp.next = temp.next.next;\n        temp = temp.next;\n    }\n\n    // Return the deep copy of the\n    // list starting from the dummy node\n    return dummyNode.next;\n}\n\n// Function to clone the linked list\nNode cloneLL(Node head) {\n    // If the original list\n    // is empty, return null\n    if (head == null) return null;\n\n    // Step 1: Insert copy of\n    // nodes in between\n    insertCopyInBetween(head);\n    // Step 2: Connect random\n    // pointers of copied nodes\n    connectRandomPointers(head);\n    // Step 3: Retrieve the deep\n    // copy of the linked list\n    return getDeepCopyList(head);\n}\n\n// Function to print the cloned linked list\nvoid printClonedLinkedList(Node head) {\n    while (head != null) {\n        System.out.print(&quot;Data: &quot; + head.data);\n        if (head.random != null) {\n            System.out.print(&quot;, Random: &quot; + head.random.data);\n        } else {\n            System.out.print(&quot;, Random: null&quot;);\n        }\n        System.out.println();\n        // Move to the next node\n        head = head.next;\n    }\n}\n\n// Main function\npublic static void main(String[] args) {\n    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    Node head = new Node(7);\n    head.next = new Node(14);\n    head.next.next = new Node(21);\n    head.next.next.next = new Node(28);\n\n    // Assigning random pointers\n    head.random = head.next.next;\n    head.next.random = head;\n    head.next.next.random = head.next.next.next;\n    head.next.next.next.random = head.next;\n\n    System.out.println(&quot;Original Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(head);\n\n    // Clone the linked list\n    Node clonedList = cloneLL(head);\n\n    System.out.println(&quot;\\nCloned Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(clonedList);\n}\n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n                     \n# Node class to represent\n# elements in the linked list\nclass Node:\n    # Data stored in the node\n    def __init__(self, x):\n        self.data = x\n        # Pointer to the next node\n        self.next = None\n        # Pointer to a random\n        # node in the list\n        self.random = None\n\n# Function to insert a copy of each\n# node in between the original nodes\ndef insertCopyInBetween(head):\n    temp = head\n    while temp:\n        nextElement = temp.next\n        # Create a new node with the same data\n        copy = Node(temp.data)\n\n        # Point the copy's next to\n        # the original node's next\n        copy.next = nextElement\n\n        # Point the original\n        # node's next to the copy\n        temp.next = copy\n\n        # Move to the next original node\n        temp = nextElement\n\n# Function to connect random\n# pointers of the copied nodes\ndef connectRandomPointers(head):\n    temp = head\n    while temp:\n        # Access the copied node\n        copyNode = temp.next\n\n        # If the original node\n        # has a random pointer\n        if temp.random:\n            # Point the copied node's random to the\n            # corresponding copied random node\n            copyNode.random = temp.random.next\n        else:\n            # Set the copied node's random to\n            # null if the original random is null\n            copyNode.random = None\n\n        # Move to the next original node\n        temp = temp.next.next\n\n# Function to retrieve the\n# deep copy of the linked list\ndef getDeepCopyList(head):\n    temp = head\n    # Create a dummy node\n    dummyNode = Node(-1)\n    # Initialize a result pointer\n    res = dummyNode\n\n    while temp:\n        # Creating a new List by\n        # pointing to copied nodes\n        res.next = temp.next\n        res = res.next\n\n        # Disconnect and revert back to the\n        # initial state of the original linked list\n        temp.next = temp.next.next\n        temp = temp.next\n\n    # Return the deep copy of the\n    # list starting from the dummy node\n    return dummyNode.next\n\n# Function to clone the linked list\ndef cloneLL(head):\n    # If the original list\n    # is empty, return null\n    if not head:\n        return None\n\n    # Step 1: Insert copy of\n    # nodes in between\n    insertCopyInBetween(head)\n    # Step 2: Connect random\n    # pointers of copied nodes\n    connectRandomPointers(head)\n    # Step 3: Retrieve the deep\n    # copy of the linked list\n    return getDeepCopyList(head)\n\n# Function to print the cloned linked list\ndef printClonedLinkedList(head):\n    while head:\n        print(&quot;Data:&quot;, head.data, end=&quot;&quot;)\n        if head.random:\n            print(&quot;, Random:&quot;, head.random.data, end=&quot;&quot;)\n        else:\n            print(&quot;, Random: None&quot;, end=&quot;&quot;)\n        print()\n        # Move to the next node\n        head = head.next\n\n# Main function\nif __name__ == &quot;__main__&quot;:\n    # Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    head = Node(7)\n    head.next = Node(14)\n    head.next.next = Node(21)\n    head.next.next.next = Node(28)\n\n    # Assigning random pointers\n    head.random = head.next.next\n    head.next.random = head\n    head.next.next.random = head.next.next.next\n    head.next.next.next.random = head.next\n\n    print(&quot;Original Linked List with Random Pointers:&quot;)\n    printClonedLinkedList(head)\n\n    # Clone the linked list\n    clonedList = cloneLL(head)\n\n    print(&quot;\\nCloned Linked List with Random Pointers:&quot;)\n    printClonedLinkedList(clonedList)\n\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n // Node class to represent\n// elements in the linked list\nclass Node {\n    // Data stored in the node\n    constructor(x, nextNode = null, randomNode = null) {\n        this.data = x;\n        // Pointer to the next node\n        this.next = nextNode;\n        // Pointer to a random\n        // node in the list\n        this.random = randomNode;\n    }\n}\n\n// Function to insert a copy of each\n// node in between the original nodes\nfunction insertCopyInBetween(head) {\n    let temp = head;\n    while (temp !== null) {\n        let nextElement = temp.next;\n        // Create a new node with the same data\n        let copy = new Node(temp.data);\n\n        // Point the copy's next to\n        // the original node's next\n        copy.next = nextElement;\n\n        // Point the original\n        // node's next to the copy\n        temp.next = copy;\n\n        // Move to the next original node\n        temp = nextElement;\n    }\n}\n\n// Function to connect random\n// pointers of the copied nodes\nfunction connectRandomPointers(head) {\n    let temp = head;\n    while (temp !== null) {\n        // Access the copied node\n        let copyNode = temp.next;\n\n        // If the original node\n        // has a random pointer\n        if (temp.random) {\n            // Point the copied node's random to the\n            // corresponding copied random node\n            copyNode.random = temp.random.next;\n        } else {\n            // Set the copied node's random to\n            // null if the original random is null\n            copyNode.random = null;\n        }\n\n        // Move to the next original node\n        temp = temp.next.next;\n    }\n}\n\n// Function to retrieve the\n// deep copy of the linked list\nfunction getDeepCopyList(head) {\n    let temp = head;\n    // Create a dummy node\n    let dummyNode = new Node(-1);\n    // Initialize a result pointer\n    let res = dummyNode;\n\n    while (temp !== null) {\n        // Creating a new List by\n        // pointing to copied nodes\n        res.next = temp.next;\n        res = res.next;\n\n        // Disconnect and revert back to the\n        // initial state of the original linked list\n        temp.next = temp.next.next;\n        temp = temp.next;\n    }\n\n    // Return the deep copy of the\n    // list starting from the dummy node\n    return dummyNode.next;\n}\n\n// Function to clone the linked list\nfunction cloneLL(head) {\n    // If the original list\n    // is empty, return null\n    if (!head) return null;\n\n    // Step 1: Insert copy of\n    // nodes in between\n    insertCopyInBetween(head);\n    // Step 2: Connect random\n    // pointers of copied nodes\n    connectRandomPointers(head);\n    // Step 3: Retrieve the deep\n    // copy of the linked list\n    return getDeepCopyList(head);\n}\n\n// Function to print the cloned linked list\nfunction printClonedLinkedList(head) {\n    while (head !== null) {\n        console.log(`Data: ${head.data}${head.random ? `, Random: ${head.random.data}` : ', Random: nullptr'}`);\n        // Move to the next node\n        head = head.next;\n    }\n}\n\n// Main function\nfunction main() {\n    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28\n    let head = new Node(7);\n    head.next = new Node(14);\n    head.next.next = new Node(21);\n    head.next.next.next = new Node(28);\n\n    // Assigning random pointers\n    head.random = head.next.next;\n    head.next.random = head;\n    head.next.next.random = head.next.next.next;\n    head.next.next.next.random = head.next;\n\n    console.log(&quot;Original Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(head);\n\n    // Clone the linked list\n    let clonedList = cloneLL(head);\n\n    console.log(&quot;\\nCloned Linked List with Random Pointers:&quot;);\n    printClonedLinkedList(clonedList);\n}\n\nmain();\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                             <strong>Output: </strong>Original Linked List with Random Pointers:\n                             Data: 7, Random: 21\n                             Data: 14, Random: 7\n                             Data: 21, Random: 28\n                             Data: 28, Random: 14\n\n                             Cloned Linked List with Random Pointers:\n                             Data: 7, Random: 21\n                             Data: 14, Random: 7\n                             Data: 21, Random: 28\n                             Data: 28, Random: 14</p>\n\n                                               \n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(3N)</strong>where N is the number of nodes in the linked list. The algorithm makes three traversals of the linked list, once to create copies and insert them between original nodes, then to set the random pointers of the copied nodes to their appropriate copied nodes and then to separate the copied and original nodes.</p>\n                        <p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the linked list as the only extra additional space allocated it to create the copied list without creating any other additional data structures.</p>\n\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/q570bKdrnlw?si=CWydsZr5rjJ_g8Tf\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n        </div>\n    </details>\n</div>\n\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>",
    "category_tag": "data-structure",
    "likes": 105,
    "preview": "Problem Statement: Given a linked list where every node in the linked list contains two pointers: 1. \u2018next\u2019 which points to the next node in the list. 2. \u2018random\u2019 which points to a random node in t..."
}