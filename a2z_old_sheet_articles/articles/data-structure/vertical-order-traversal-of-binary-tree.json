{
    "dislikes": 15,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:22 GMT+0530 (India Standard Time)",
    "slug": "vertical-order-traversal-of-binary-tree",
    "aid": "1469",
    "title": "Vertical Order Traversal of Binary Tree",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/vertical-order-traversal",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Tree, return the Vertical Order Traversal of it starting from the Leftmost level to the Rightmost level. If there are multiple nodes passing through a vertical line, then they should be printed as they appear in level order traversal of the tree.\n\n \n</p>\n\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 3 4 10 9 11 -1 5 -1 -1 -1 -1 -1 -1 -1 6\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image1-diChK2E3\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output:</strong> Vertical Order Traversal: [[4],[2, 5], [1, 10, 9, 6],[3],[11]]</span>\n\t\t\t\t<span><strong>Explanation: </strong>Vertical Levels from left to right:\n\t\t\t\t<ol><li>Level -2: [4]</li><li>Level -1: [2]</li><li>Level 0: [1, 10, 9, 6] (Overlapping nodes are added in their level order sequence)</li><li>Level 1: [3]</li><li>Level 2: [11]</li></ol></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image2-L8jBykS-\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Example 2:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 2 7 5 2 6 -1 9 -1 -1 5 11 4 -1\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image3-t3_XyQdZ\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output :</strong> [[2],[7, 5],[2, 6], [5, 11, 4],[9]]</span>\n\t\t\t\t<span><strong>Explanation: </strong>Vertical Levels from left to right:\n\t\t\t\t<ol><li>Level -2: [2]</li><li>Level -1: [7, 5]</li><li>Level 0: [2, 6]</li><li>Level 1: [5, 11, 4] (Overlapping nodes are added in their level order sequence)</li><li>Level 2: [9]</li></ol></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image4-aWuNOE3V\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t\n            </pre>\n        </div>\n    </details>\n</div>\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/vertical-order-traversal_3622711?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\"\n                alt=\"code-studio\">\n        </a>\n    </div>\n    <!--<div class=\"problem-buttons\">\n         Add Problem Link inside href \n        <a href=\"\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp\"\n                alt=\"leetcode\">\n        </a>\n    </div>-->\n</div>\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\n        yourself first. </em></p>\n\n\n<div id=\"brute-force-approach\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Optimal Approach \n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                </path>\n            </svg>\n        </summary>\n        <div class=\"common-drops\">\n            <details class=\"secondary-details\" open=\"\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Algorithm / Intuition\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"approach-algorithm\">\n                    <!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n                    <p>We can assign a vertical and level to every node. This will help us in categorising nodes based on their position in the binary tree.\n                    <strong>Vertical Coordinates (x):</strong> The vertical coordinate, denoted as 'x', represents the vertical column in the tree. It essentially signifies the horizontal position of a node in relation to its parent. Nodes with the same 'x' value are aligned vertically, forming a column.\n                    <strong>Level Coordinates (y):</strong> The level coordinate, denoted as 'y', represents the depth or level of a node in the tree. It signifies the vertical position of a node within the hierarchy of levels. As we traverse down the tree, the 'y' value increases, indicating a deeper level.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image5-umLmDdn9\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    <p>We create a map that serves as our organisational structure. The map is based on the vertical and level information of each node. The vertical information, represented by 'x', signifies the vertical column, while the level information, denoted as 'y', acts as the key within the nested map. This nested map utilises a multiset to ensure that node values are stored in a unique and sorted order.\n                    With our map structure in place, we initiate a level order BFS traversal using a queue. Each element in the queue is a pair containing the current node and its corresponding vertical and level coordinates. Starting with the root node, we enqueue it with initial vertical and level values (0, 0). During traversal, for each dequeued node, we update the map by inserting the node value at its corresponding coordinates and enqueue its left and right children with adjusted vertical and level information.\n                    When traversing to the left child, the vertical value decreases by 1 and the level increases by 1, while traversal to the right child leads to an increase in both vertical and level by 1.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image6-C7TnRsK4\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    <p>After completing the BFS traversal, we prepare the final result vector. We iterate through the map, creating a column vector for each vertical column. This involves gathering node values from the multiset and inserting them into the column vector. These column vectors are then added to the final result vector, resulting in a 2D representation of the vertical order traversal of the binary tree.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image7-8VL1H11C\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    <p><strong>Algorithm:</strong></p>\n                    <p><strong>Step 1:</strong> Create an empty map to store the nodes based on their vertical and horizontal levels.The key of the map \u2018x\u2019 represents the vertical column, and the nested map uses \u2018y\u2019 as the key for the level. Initialise a \u2018multiset\u2019 to store node values at a specific vertical and level to ensure unique and sorted order of nodes.</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image8-ieYxlxXx\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p><strong>Step 2:</strong> Initialise a queue for level order BFS traversal. Each element in the queue should be a pair containing the current node and its vertical and level order information as x and coordinates. Enqueue the root node into the queue with its initial vertical and level order values as (0, 0)</p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image9-aRN3kovx\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    \n                    <p><strong>Step 3:</strong>  While the queue is not empty, pop the front node of the queue:\n                    <ol><li>Get this nodes vertical ie. \u2018x\u2019 and level order \u2018y\u2019 information.</li><li>Insert this node into the map at its corresponding coordinate.</li><li>Push the left and right child of the node with their updated horizontal distance and level order.</li></ol></p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image10-OwfFCRvB\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p>For the left child, decrement the vertical value \u2018x\u2019 by 1 to indicate a move towards the left. Increment the level value \u2018y\u2019 by 1 to indicate a move down to the next level.\n                    For the right child, increment the vertical value \u2018x\u2019 by 1 to indicate a move towards the right.\n                    Increment the level value \u2018y\u2019 by 1 to indicate a move down to the next level.\n                \t</p>\n                \t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/vertical-traversal-image11-wWjMyWWW\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                \t<p>Enqueue both the left and right children along with their updated vertical and level information into the queue.</p>\n                    \n                    <p><strong>Step 4:</strong> After the BFS traversal using the queue is complete, initialise a final result 2D vector \u2018ans\u2019.\n                    <ol><li>Iterate through the map, creating a column vector for each vertical column. Gather the node values from the multiset and insert them into the column vector.</li><li>Add these column vectors to the final result vector \u2018ans\u2019.</li></ol></p>\n                    <!--<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/boundary-traversal-image7-fsN2b9gx\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>-->\n\n                    <p><strong>Step 5:</strong>  Return the 2D vector `ans` representing the vertical order traversal of the binary tree. </p>\n                    \n                    \n                </div>\n            </details>\n            <details class=\"code-section secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Code\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"code-tabs\">\n                    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                    <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                        </path>\n                    </svg>\n                </div>\n                <div class=\"code-content\">\n                    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to perform vertical order traversal\n    // and return a 2D vector of node values\n    vector&lt;vector&lt;int&gt;&gt; findVertical(Node* root){\n        // Map to store nodes based on\n        // vertical and level information\n        map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt; nodes;\n        \n        // Queue for BFS traversal, each\n        // element is a pair containing node\n        // and its vertical and level information\n        queue&lt;pair&lt;Node*, pair&lt;int, int&gt;&gt;&gt; todo;\n        \n        // Push the root node with initial vertical\n        // and level values (0, 0)\n        todo.push({root, {0, 0}});\n        \n        // BFS traversal\n        while(!todo.empty()){\n            // Retrieve the node and its vertical\n            // and level information from\n            // the front of the queue\n            auto p = todo.front();\n            todo.pop();\n            Node* temp = p.first;\n            \n            // Extract the vertical and level information\n            // x -&gt; vertical\n            int x = p.second.first;  \n            // y -&gt; level\n            int y = p.second.second; \n            \n            // Insert the node value into the\n            // corresponding vertical and level\n            // in the map\n            nodes[x][y].insert(temp-&gt;data);\n            \n            // Process left child\n            if(temp-&gt;left){\n                todo.push({\n                    temp-&gt;left,\n                    {\n                        // Move left in\n                        // terms of vertical\n                        x-1, \n                        // Move down in\n                        // terms of level\n                        y+1  \n                    }\n                });\n            }\n            \n            // Process right child\n            if(temp-&gt;right){\n                todo.push({\n                    temp-&gt;right, \n                    {\n                        // Move right in\n                        // terms of vertical\n                        x+1, \n                        // Move down in\n                        // terms of level\n                        y+1  \n                    }\n                });\n            }\n        }\n        \n        // Prepare the final result vector\n        // by combining values from the map\n        vector&lt;vector&lt;int&gt;&gt; ans;\n        for(auto p: nodes){\n            vector&lt;int&gt; col;\n            for(auto q: p.second){\n                // Insert node values\n                // into the column vector\n                col.insert(col.end(), q.second.begin(), q.second.end());\n            }\n            // Add the column vector\n            // to the final result\n            ans.push_back(col);\n        }\n        return ans;\n    }\n};\n\n// Helper function to\n// print the result\nvoid printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n    for(auto level: result){\n        for(auto node: level){\n            cout &lt;&lt; node &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(10);\n    root-&gt;left-&gt;left-&gt;right = new Node(5);\n    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);\n    root-&gt;right = new Node(3);\n    root-&gt;right-&gt;right = new Node(10);\n    root-&gt;right-&gt;left = new Node(9);\n\n    Solution solution;\n\n    // Get the Vertical traversal\n    vector&lt;vector&lt;int&gt;&gt; verticalTraversal =\n                    solution.findVertical(root);\n\n    // Print the result\n    cout &lt;&lt; &quot;Vertical Traversal: &quot;;\n    printResult(verticalTraversal);\n\n    return 0;\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block \" data-lang=\"java\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\n// Node class for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    public Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n    // Function to perform vertical order traversal\n    // and return a 2D ArrayList of node values\n    public List&lt;List&lt;Integer&gt;&gt; findVertical(Node root) {\n        // Map to store nodes based on\n        // vertical and level information\n        Map&lt;Integer, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt;&gt; nodes = new TreeMap&lt;&gt;();\n\n        // Queue for BFS traversal, each\n        // element is a pair containing node\n        // and its vertical and level information\n        Queue&lt;Pair&lt;Node, Pair&lt;Integer, Integer&gt;&gt;&gt; todo = new LinkedList&lt;&gt;();\n\n        // Push the root node with initial vertical\n        // and level values (0, 0)\n        todo.add(new Pair&lt;&gt;(root, new Pair&lt;&gt;(0, 0)));\n\n        // BFS traversal\n        while (!todo.isEmpty()) {\n            // Retrieve the node and its vertical\n            // and level information from\n            // the front of the queue\n            Pair&lt;Node, Pair&lt;Integer, Integer&gt;&gt; p = todo.poll();\n            Node temp = p.getKey();\n\n            // Extract the vertical and level information\n            // x -&gt; vertical\n            int x = p.getValue().getKey();\n            // y -&gt; level\n            int y = p.getValue().getValue();\n\n            // Insert the node value into the\n            // corresponding vertical and level\n            // in the map\n            nodes.computeIfAbsent(x, k -&gt; new TreeMap&lt;&gt;())\n                 .computeIfAbsent(y, k -&gt; new TreeSet&lt;&gt;())\n                 .add(temp.data);\n\n            // Process left child\n            if (temp.left != null) {\n                todo.add(new Pair&lt;&gt;(temp.left, new Pair&lt;&gt;(x - 1, y + 1)));\n            }\n\n            // Process right child\n            if (temp.right != null) {\n                todo.add(new Pair&lt;&gt;(temp.right, new Pair&lt;&gt;(x + 1, y + 1)));\n            }\n        }\n\n        // Prepare the final result list\n        // by combining values from the map\n        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n        for (Map.Entry&lt;Integer, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt;&gt; entry : nodes.entrySet()) {\n            List&lt;Integer&gt; col = new ArrayList&lt;&gt;();\n            for (TreeSet&lt;Integer&gt; set : entry.getValue().values()) {\n                // Insert node values\n                // into the column list\n                col.addAll(set);\n            }\n            // Add the column list\n            // to the final result\n            ans.add(col);\n        }\n        return ans;\n    }\n\n    // Helper function to\n    // print the result\n    private static void printResult(List&lt;List&lt;Integer&gt;&gt; result) {\n        for (List&lt;Integer&gt; level : result) {\n            for (int node : level) {\n                System.out.print(node + &quot; &quot;);\n            }\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.left.left = new Node(4);\n        root.left.right = new Node(10);\n        root.left.left.right = new Node(5);\n        root.left.left.right.right = new Node(6);\n        root.right = new Node(3);\n        root.right.right = new Node(10);\n        root.right.left = new Node(9);\n\n        Solution solution = new Solution();\n\n        // Get the Vertical traversal\n        List&lt;List&lt;Integer&gt;&gt; verticalTraversal = solution.findVertical(root);\n\n        // Print the result\n        System.out.print(&quot;Vertical Traversal: &quot;);\n        printResult(verticalTraversal);\n    }\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"python\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"python\" class=\"language-python\">\nfrom collections import deque, defaultdict\n\n# Node structure for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # Function to perform vertical order traversal\n    # and return a 2D list of node values\n    def findVertical(self, root):\n        # Map to store nodes based on\n        # vertical and level information\n        nodes = defaultdict(lambda: defaultdict(lambda: set()))\n\n        # Queue for BFS traversal, each\n        # element is a pair containing node\n        # and its vertical and level information\n        todo = deque([(root, (0, 0))])\n\n        # BFS traversal\n        while todo:\n            # Retrieve the node and its vertical\n            # and level information from\n            # the front of the queue\n            temp, (x, y) = todo.popleft()\n\n            # Insert the node value into the\n            # corresponding vertical and level\n            # in the map\n            nodes[x][y].add(temp.data)\n\n            # Process left child\n            if temp.left:\n                todo.append((temp.left, (x - 1, y + 1)))\n\n            # Process right child\n            if temp.right:\n                todo.append((temp.right, (x + 1, y + 1)))\n\n        # Prepare the final result list\n        # by combining values from the map\n        ans = []\n        for x, y_vals in nodes.items():\n            col = []\n            for y, values in y_vals.items():\n                # Insert node values\n                # into the column list\n                col.extend(sorted(values))\n            # Add the column list\n            # to the final result\n            ans.append(col)\n\n        return ans\n\n# Helper function to\n# print the result\ndef printResult(result):\n    for level in result:\n        for node in level:\n            print(node, end=&quot; &quot;)\n        print()\n    print()\n\nif __name__ == &quot;__main__&quot;:\n    # Creating a sample binary tree\n    root = Node(1)\n    root.left = Node(2)\n    root.left.left = Node(4)\n    root.left.right = Node(10)\n    root.left.left.right = Node(5)\n    root.left.left.right.right = Node(6)\n    root.right = Node(3)\n    root.right.right = Node(10)\n    root.right.left = Node(9)\n\n    solution = Solution()\n\n    # Get the Vertical traversal\n    verticalTraversal = solution.findVertical(root)\n\n    # Print the result\n    print(&quot;Vertical Traversal: &quot;)\n    printResult(verticalTraversal)\n                           </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node structure for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to perform vertical order traversal\n    // and return a 2D array of node values\n    findVertical(root) {\n        // Map to store nodes based on\n        // vertical and level information\n        const nodes = new Map();\n        \n        // Queue for BFS traversal, each\n        // element is an array containing node\n        // and its vertical and level information\n        const todo = [];\n        \n        // Push the root node with initial vertical\n        // and level values (0, 0)\n        todo.push([root, [0, 0]]);\n        \n        // BFS traversal\n        while (todo.length &gt; 0) {\n            // Retrieve the node and its vertical\n            // and level information from\n            // the front of the queue\n            const [temp, [x, y]] = todo.shift();\n            \n            // Insert the node value into the\n            // corresponding vertical and level\n            // in the map\n            if (!nodes.has(x)) {\n                nodes.set(x, new Map());\n            }\n            if (!nodes.get(x).has(y)) {\n                nodes.get(x).set(y, new Set());\n            }\n            nodes.get(x).get(y).add(temp.data);\n            \n            // Process left child\n            if (temp.left) {\n                todo.push([\n                    temp.left,\n                    [\n                        // Move left in\n                        // terms of vertical\n                        x - 1,\n                        // Move down in\n                        // terms of level\n                        y + 1\n                    ]\n                ]);\n            }\n            \n            // Process right child\n            if (temp.right) {\n                todo.push([\n                    temp.right,\n                    [\n                        // Move right in\n                        // terms of vertical\n                        x + 1,\n                        // Move down in\n                        // terms of level\n                        y + 1\n                    ]\n                ]);\n            }\n        }\n        \n        // Prepare the final result array\n        // by combining values from the map\n        const ans = [];\n        for (const [key, value] of nodes) {\n            const col = [];\n            for (const [subKey, subValue] of value) {\n                // Insert node values\n                // into the column array\n                col.push(...subValue);\n            }\n            // Add the column array\n            // to the final result\n            ans.push(col);\n        }\n        return ans;\n    }\n}\n\n// Helper function to\n// print the result\nfunction printResult(result) {\n    for (const level of result) {\n        console.log(level.join(&quot; &quot;));\n    }\n    console.log(&quot;&quot;);\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.left.left = new Node(4);\nroot.left.right = new Node(10);\nroot.left.left.right = new Node(5);\nroot.left.left.right.right = new Node(6);\nroot.right = new Node(3);\nroot.right.right = new Node(10);\nroot.right.left = new Node(9);\n\nconst solution = new Solution();\n\n// Get the Vertical traversal\nconst verticalTraversal = solution.findVertical(root);\n\n// Print the result\nconsole.log(&quot;Vertical Traversal: &quot;);\nprintResult(verticalTraversal);\n\n                            </code>\n                        </pre>\n                    </div>\n                    <p>\n                       <strong>Output</strong> \n                      \tVertical Traversal: \n                      \t4\n                      \t2 5\n                      \t1 9 10 6\n                      \t3\n                      \t10\n\n                    </p>\n                </div>\n            </details>\n            <details class=\"secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Complexity Analysis\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <p>\n                    <!-- Insert Time and Space Complexity  Here -->\n                    <p><strong>Time Complexity: O(N * log2N * log2N * log2N)</strong> where N represents the number of nodes in the Binary Tree.\n                    <ol><li>Postorder Traversal performed using BFS as a time complexity of O(N) as we are visiting each and every node once.</li><li>Multiset Operations to insert overlapping nodes at a specific vertical and horizontal level also takes O(log2N) complexity.</li><li>Map operations involve insertion and retrieval of nodes with their vertical and level as their keys. Since there are two nested maps, the total time complexity becomes O(log2N)*O(log2N).</li></ol></p>\n\n\t\t\t\t\t<p><strong>Space Complexity:  O(N + N/2)</strong>  where N represents the number of nodes in the Binary Tree.\n\t\t\t\t\t<ol><li>The map for storing nodes based on their vertical and level information occupies an additional space complexity of O(N) as it stores all N nodes of the Binary Tree.</li><li>The queue for breadth first traversal occupies a space proportional to the maximum level of the tree which can be O(N/2) in the worst case of a balanced tree.</li></ol> </p>\n\n                </p>\n            </details>\n        </div>\n    </details>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <!-- Insert iframe embed Link of Youtube Video-->\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/q_a6lpbKJdw?si=e_LfTzvNCVcp5aan\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n        </div>\n    </details>\n</div>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>",
    "category_tag": "data-structure",
    "likes": 119,
    "preview": "Problem Statement: Given a Binary Tree, return the Vertical Order Traversal of it starting from the Leftmost level to the Rightmost level. If there are multiple nodes passing through a vertical lin..."
}