{
    "dislikes": 0,
    "video": "PwMVNSJ5SLI",
    "publishedOn": "Sun Mar 24 2024 22:11:47 GMT+0530 (India Standard Time)",
    "slug": "find-the-city-with-the-smallest-number-of-neighbours-at-a-threshold-distance-g-43",
    "aid": "2162",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/find-the-city-with-the-smallest-number-of-neighbors",
    "title": "Find the City With the Smallest Number of Neighbours at a Threshold Distance: G-43",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 36,
    "category_tag": "data-structure",
    "preview": "Problem Statement: There are n cities numbered from 0 to n-1. Given the array edges where edges[i] = [fromi, toi,weighti] represents a bidirectional and weighted edge between cities fromi and toi,...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> There are n cities numbered from 0 to n-1. Given the array edges where <strong>edges[i] = [fromi, toi</strong><strong>,weight<sub>i</sub></strong><strong>]</strong>&nbsp; represents a bidirectional and weighted edge between cities <strong>from<sub>i</sub></strong><strong> </strong>and <strong>to<sub>i</sub></strong>, and given the integer distance Threshold. You need to find out a city with the smallest number of cities that are reachable through some path and whose distance is at most Threshold Distance, If there are multiple such cities, our answer will be the city with the greatest number.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Note: that the distance of a path, connecting cities i and j are equal to the sum of the edges' weights along that path.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input Format:</b> \nN=4, M=4, \nedges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], \ndistanceThreshold = 4\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-182442.png\" alt=\"\" class=\"wp-image-6963\"></figure>\n<b>Result:</b> 3\n<b>Explanation:</b> \nThe adjacent cities for each city at a distanceThreshold are =\nCity 0 \u2192[City 1, City 2]\nCity 1 \u2192[City 0, City 2, City 3]\nCity 2 \u2192[City 0, City 1, City 3]\nCity 3 \u2192[City 1, City 2]\nHere, City 0 and City 3 have a minimum number of cities \ni.e. 2 within distanceThreshold. So, the result will be the \ncity with the largest number. So, the answer is City 3.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input Format:</b> \nN=3, M=2, edges = [[0,1,3],[1,2,1]], distanceThreshold = 2\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-23-182533.png\" alt=\"\" class=\"wp-image-6964\"></figure>\n<b>Result:</b> 2\n<b>Explanation:</b> \nCity 1 \u2192 City 2,\nCity 2 \u2192 City 1\nHence, 2 is the answer.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In order to solve this problem, we will use the <strong><em>Floyd Warshall algorithm </em></strong>(article link of Floyd Warshall). We know Floyd Warshall algorithm helps us to generate a 2D matrix, that stores the shortest distances from each node to every other node. In the generated 2D matrix, each cell matrix[i][j] represents the shortest distance from node i to node j.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>After generating the 2D matrix(that contains the shortest paths) using the Floyd Warshall algorithm, for each node, we will count the number of nodes with a distance lesser or equal to the distanceThreshold by iterating each row of that matrix. Finally, we will choose the node with the minimum number of adjacent cities(whose distance is at the most distanceThreshold) and with the largest value.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>This 2D matrix can also be generated using Dijkstra\u2019s algorithm. As Dijkstra\u2019s algorithm is a single-source shortest-path algorithm, we need to calculate the shortest distances for one single node at a time. So, to create the 2D matrix we need to apply Dijkstra\u2019s algorithm to each of the V nodes separately.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition:<br></strong><em>For each node, the job is to find the shortest distances to every other node and count the number of adjacent cities(Let\u2019s say: </em><strong><em>cntCity</em></strong><em>) whose distance is at the most distanceThreshold. Finally, the task is to choose the node with the largest value and the minimum \u2018</em><strong><em>cntCity</em></strong><em>\u2019 value.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial Configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Adjacency Matrix(dist): </strong>All the cells of the matrix are initially set to infinity(\u221e).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>cntCity: </strong>Initially set to V(no. of nodes) i.e. the maximum value possible. It will store the minimum number of cities whose distance is at most distanceThreshold.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>cityNo: </strong>Initially set to -1. It will store the answer i.e. the node with the largest value and the minimum \u2018<strong>cntCity</strong>\u2019 value.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First, we will iterate over the edges, and set the value of dist[from<sub>i</sub>][to<sub>i</sub>] and dist[to<sub>i</sub>][from<sub>i</sub>] to weight<sub>i</sub> as the edges are bidirectional.</li><li>After having set the adjacency matrix accordingly, we will run a loop from 0 to V-1(V = no. of vertices). In the k<sup>th</sup> iteration, this loop will help us to check the path via node k for every possible pair of nodes. Basically, this loop will change the value of k in the formula(given in step 4).</li><li>Inside the loop, there will be two nested loops for generating every possible pair of nodes(Nothing but to visit each cell of a 2D matrix using the nested loop). Among these two loops, the first loop will change the value of i and the second one will change the value of j in the formula(given in step 4).</li><li>Inside these nested loops, we will apply the following formula to calculate the shortest distance between the pair of nodes:<strong>dist[i][j] =min(dist[i][j], dist[i ][k]+dist[k][j]), where i = source node, j = destination node, and k = the node via which we are reaching from i to j.<br></strong></li><li>The adjacency matrix will store all the shortest paths for each node. For example, dist[i][j] will store the shortest path from node i to node j.</li><li>After that, we will count the nodes(<strong>cnt</strong>) with a distance lesser or equal to distanceThreshold and check if it is lesser than the current value of cntCity.</li><li>If it is lesser, we will update cntCity with the count of nodes and cityNo with the value of the current city.</li><li>Finally, we will return cityNo as our answer.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>If we need to find out the number of adjacent cities as well, we need to return cntCity-1. This is because we have included the node itself in the group of adjacent nodes whose distance is at the most distanceThreshold.</em><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution {\npublic:\n\tint findCity(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; edges,\n\t             int distanceThreshold) {\n\t\tvector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt; (n, INT_MAX));\n\t\tfor (auto it : edges) {\n\t\t\tdist[it[0]][it[1]] = it[2];\n\t\t\tdist[it[1]][it[0]] = it[2];\n\t\t}\n\t\tfor (int i = 0; i &lt; n; i++) dist[i][i] = 0;\n\t\tfor (int k = 0; k &lt; n; k++) {\n\t\t\tfor (int i = 0; i &lt; n; i++) {\n\t\t\t\tfor (int j = 0; j &lt; n; j++) {\n\t\t\t\t\tif (dist[i][k] == INT_MAX || dist[k][j] == INT_MAX)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cntCity = n;\n\t\tint cityNo = -1;\n\t\tfor (int city = 0; city &lt; n; city++) {\n\t\t\tint cnt = 0;\n\t\t\tfor (int adjCity = 0; adjCity &lt; n; adjCity++) {\n\t\t\t\tif (dist[city][adjCity] &lt;= distanceThreshold)\n\t\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tif (cnt &lt;= cntCity) {\n\t\t\t\tcntCity = cnt;\n\t\t\t\tcityNo = city;\n\t\t\t}\n\t\t}\n\t\treturn cityNo;\n\n\t}\n};\n\n\nint main() {\n\n\tint n = 4;\n\tint m = 4;\n\tvector&lt;vector&lt;int&gt;&gt; edges = {{0, 1, 3}, {1, 2, 1}, {1, 3, 4}, {2, 3, 1}};\n\tint distanceThreshold = 4;\n\n\tSolution obj;\n\tint cityNo = obj.findCity(n, m, edges, distanceThreshold);\n\tcout &lt;&lt; \"The answer is node: \" &lt;&lt; cityNo &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The answer is node: 3</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V<sup>3</sup>), as we have three nested loops each running for V times, where V = no. of vertices.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(V<sup>2</sup>), where V = no. of vertices. This space complexity is due to storing the adjacency matrix of the given graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\n\n//User function template for JAVA\n\n\n// User function Template for Java\n\nclass Solution {\n\n    int findCity(int n, int m, int edges[][],\n                 int distanceThreshold) {\n        int[][] dist = new int[n][n];\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; n; j++)\n                dist[i][j] = Integer.MAX_VALUE;\n        }\n        for (int i = 0; i &lt; m; i++) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            int wt = edges[i][2];\n            dist[u][v] = wt;\n            dist[v][u] = wt;\n        }\n\n        for (int i = 0; i &lt; n; i++) dist[i][i] = 0;\n        for (int k = 0; k &lt; n; k++) {\n            for (int i = 0; i &lt; n; i++) {\n                for (int j = 0; j &lt; n; j++) {\n                    if (dist[i][k] == Integer.MAX_VALUE ||\n                            dist[k][j] == Integer.MAX_VALUE)\n                        continue;\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        int cntCity = n;\n        int cityNo = -1;\n        for (int city = 0; city &lt; n; city++) {\n            int cnt = 0;\n            for (int adjCity = 0; adjCity &lt; n; adjCity++) {\n                if (dist[city][adjCity] &lt;= distanceThreshold)\n                    cnt++;\n            }\n\n            if (cnt &lt;= cntCity) {\n                cntCity = cnt;\n                cityNo = city;\n            }\n        }\n        return cityNo;\n    }\n}\n\npublic class tUf {\n    public static void main(String[] args) {\n        int n = 4;\n        int m = 4;\n        int[][] edges =  {{0, 1, 3}, {1, 2, 1}, {1, 3, 4}, {2, 3, 1}};\n        int distanceThreshold = 4;\n\n        Solution obj = new Solution();\n        int cityNo = obj.findCity(n, m, edges, distanceThreshold);\n        System.out.println(\"The answer is node: \" + cityNo);\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The answer is node: 3</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V<sup>3</sup>), as we have three nested loops each running for V times, where V = no. of vertices.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(V<sup>2</sup>), where V = no. of vertices. This space complexity is due to storing the adjacency matrix of the given graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}