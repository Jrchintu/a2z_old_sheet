{
    "dislikes": 5,
    "video": "_-QHfMDde90",
    "publishedOn": "Sun Mar 24 2024 22:09:18 GMT+0530 (India Standard Time)",
    "slug": "lowest-common-ancestor-for-two-given-nodes",
    "aid": "1447",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/lca-in-bt",
    "title": "Lowest Common Ancestor for two given Nodes",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "category_tag": "data-structure",
    "likes": 129,
    "preview": "Problem Statement: Given a binary tree, Find the Lowest Common Ancestor for two given Nodes (x,y). Lowest Common Ancestor(LCA): The lowest common ancestor is defined between two nodes x and y as th...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given a binary tree, Find the  Lowest Common Ancestor for two given Nodes (x,y).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Lowest Common Ancestor(LCA): </strong>The lowest common ancestor is defined between two nodes x and y as the lowest node in T that has both x and y as descendants (where we allow a node to be a descendant of itself.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Consider the following Binary Tree</strong>\n<img width=\"207\" height=\"185\" src=\"https://lh5.googleusercontent.com/R3uP1fB_yH92rN233Ihjwd3sR4E7JlNmduWhFEYqE7TpXX4IB2hTdtSCyc0u0BPiRbZPBk60IvFLx6i5QhYCBbSHA3CKPbUl8KIn2qc3lVDeDZRRCvL3my9dzitjk3E5_p_5Hne0\">\n\n<strong>Example 1: </strong>\n\n<strong>Input: </strong>x = 4 , y = 5\n\n<strong>Output:</strong> 2 \n\n<strong>Explanation:</strong> All ancestors for 4,5 are 2,1.  But we need Lowest Common ancestor, So we will consider lowest and also common ancestor that is 2\n\n<strong>Example 2:</strong>\n\n<strong>Input:</strong> \nx = 2 , y = 3\n\n<strong>Output:</strong> 1\n\n<strong>Explanation:</strong>  Lowest Common Ancestor for x,y i.e for 2,3 is 1\n\n<strong>Example 3:</strong>\n\n<strong>Input:</strong> \nx= 6 , y = 7\n\n<strong>Output:</strong> 3\n\n<strong>Explanation:</strong>  Lowest Common Ancestor for x,y i.e for 6,7 is 3 </pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph {\"textColor\":\"vivid-red\"} -->\n<p class=\"has-vivid-red-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The very first thing we can observe from the question is that we can find the LCA of 2 given nodes from&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i) Left subtree or in</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ii)Right subtree, if not in both the subtrees then root will be the&nbsp; LCA.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>If root is null or if root is x or if root is y then return root</li><li>Made a recursion call for both</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>i) Left subtree&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>ii)Right subtree</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Because we would find LCA in the left or right subtree only.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true,\"start\":3} -->\n<ol start=\"3\"><li>If the left subtree recursive call gives a null value that means we haven\u2019t found LCA in the left subtree, which means we found LCA on the right subtree. So we will return right.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:list {\"ordered\":true,\"start\":4} -->\n<ol start=\"4\"><li>If the right subtree recursive call gives null value, that means we haven\u2019t found LCA on&nbsp;the right subtree, which means we found LCA on the left subtree. So we will return left .</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:list {\"ordered\":true,\"start\":5} -->\n<ol start=\"5\"><li>&nbsp;If both left &amp; right calls give values (not null)&nbsp; that means the root is the LCA.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s take an example and will try to understand the approach more clearly:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3>LCA of (x,y) = &gt; (4,5) = ? (from above given example)</h3>\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n<ul><li>Root is 1 which is not null and x,y is not equal to root, So the 1st statement in approach&nbsp; will not execute.</li><li>i) Call left subtree, While calling recursively it will find 4 and this call will return 4 to its parent&nbsp;</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><em>Point to Note: At present, the root is 2 ( Look at below recursion tree for better understanding)</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>i) Call the right subtree ( i.e right of 2), While calling recursively it will find 5&nbsp; and this call will return 5 to its parent.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Now the left recursive&nbsp; call returns value (not null) i.e 4 and also the right recursive call returns value (not null) i.e 5 to its root ( at present root is 2) , and this 2 will return itself to its root i.e to 1 (main root).</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><em>Point to Note: At present, the root is 1 ( Look at below recursion tree for better understanding)</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Now, the left subtree gives a value i.e 2.</li><li>Right recursive call will give null value .because x,y are not present in the right subtree.</li><li>As we know if the right recursive call gives null then we return the answer which we got from the left call, So we will return 2.</li><li>&nbsp;Hence LCA of (4,5) is 2.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>For a better understanding of the</strong> <strong>above example (LCA OF 4,5) :</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"393\" height=\"259\" src=\"https://lh4.googleusercontent.com/kAHrNk763Pdg77Wy36n7S0YKDcfx7-5D4zknAMSF1JLWqdpoTnCdx8lCgB1LfcpAby4lMUL6ASS3PQocgw1JOpN_Yu6puZSio68Pj-U8QcKAfz0P3XJdc3s46FR1afDM0yoq8rVz\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong> </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>[tabby title= \"C++ Code\"]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        //base case\n        if (root == NULL || root == p || root == q) {\n            return root;\n        }\n        TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);\n        TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);\n\n        //result\n        if(left == NULL) {\n            return right;\n        }\n        else if(right == NULL) {\n            return left;\n        }\n        else { //both left and right are not null, we found our result\n            return root;\n        }\n    }\n};</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Time complexity</strong>: O(N) where n is the number of nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space complexity</strong>: O(N), auxiliary space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        //base case\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        //result\n        if(left == null) {\n            return right;\n        }\n        else if(right == null) {\n            return left;\n        }\n        else { //both left and right are not null, we found our result\n            return root;\n        }\n    }\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Time complexity</strong>: O(N) where n is the number of nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space complexity</strong>: O(N), auxiliary space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em><em>Special thanks to <strong><a href=\"https://www.linkedin.com/in/sai-bargav-nellepalli-74799b1bb/\" target=\"_blank\" rel=\"noreferrer noopener nofollow\">Sai bargav Nellepalli</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/contribute/help-us-grow-takeuforward/\">please check out this articl</a><em>e</em></em></p></blockquote>\n<!-- /wp:quote -->"
}