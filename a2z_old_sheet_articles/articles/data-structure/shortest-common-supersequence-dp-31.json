{
    "dislikes": 1,
    "video": "xElxAuBcvsU",
    "publishedOn": "Sun Mar 24 2024 22:10:31 GMT+0530 (India Standard Time)",
    "slug": "shortest-common-supersequence-dp-31",
    "aid": "1800",
    "title": "Shortest Common Supersequence | (DP - 31)",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/shortest-common-supersequence",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:&nbsp;</strong>Shortest Common Supersequence</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given two strings \u2018S1\u2019 and \u2018S2\u2019. We need to return their shortest common supersequence. A supersequence is defined as the string which contains both the strings S1 and S2 as subsequences.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example:</strong>\n\n<img width=\"554\" height=\"367\" src=\"https://lh3.googleusercontent.com/yCJEIc5nB_P1SIqKzcBEcywKRgTAgQt3w1wHrYad81cPdwFQRcagmfJLtOtw7_NzhsmbX0VxPxsm64fyGSolB-j0jY0QeC_vDaA-iEdUIWJQAf9bzjKdeRyc7fcHlWkfVhEIsL4i\"></pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>We need to return the length<strong> </strong>of the longest common subsequence and the string as well.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Link: </strong><a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbklWUVRldW53WXRPMWVuVGJMeldJWF9YY1J0QXxBQ3Jtc0ttckRGV0RCeVZDRVo0dTgtdlhwQ0VKSXh3WXlnaUlJeER6RTE4YlVONF9ySXUwdzQ3RndmUV9iSlVMelJZTTJ5a0FYbzE0YXp0TnJGRXh1Nkk3U1VGSjNmTEJTQnR5VFl2WXl6a1pCZDFKOVZFVmViTQ&amp;q=https%3A%2F%2Fbit.ly%2F3vEYKce\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Shortest Supersequence</strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution :</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-req: </strong><a href=\"https://takeuforward.org/data-structure/longest-common-subsequence-dp-25/\" target=\"_blank\" rel=\"noreferrer noopener\">Longest Common Subsequence</a>, <a href=\"https://takeuforward.org/data-structure/print-longest-common-subsequence-dp-26/\" target=\"_blank\" rel=\"noreferrer noopener\">Print Longest Common Subsequence</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Intuition:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>If we keep the \u201cshortest\u201d criteria aside, what can be a way to generate a supersequence given two strings. One easy way is to concat the given strings (write one after the other), this will always give us a supersequence for any pair of given strings.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"554\" height=\"221\" src=\"https://lh4.googleusercontent.com/Fj4kN0VGEtTDD1RRl5o7jhiq7Q72eovbn_TeZXq0HQ4NL8ZBB-H9AOJi1HxRXNq-wsOKbHEaiOkQ7JodJGiPST2tOFV-Pdg_7YknzEfydXg6YbWbIrSEnCCpkTsBBaY-9pYlfEKf\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This can be said as the worst case with time complexity of O(n+m), where n and are the lengths of strings S1 and S2 respectively.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>How can we improve from this naive approach?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If we think a little, there are some common characters that we can avoid writing for both the strings separately. These common characters can\u2019t be all the common characters. They are the characters that <strong>are common and come in the same order</strong>. In other words, they are the characters of the <strong>longest common subsequence</strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In an optimum solution, the characters of the longest common subsequence are written only once and other characters are placed around them. For every character that belongs to the longest common subsequence, the non-lcs characters coming before them in the strings S1 and S2 are placed before the lcs-character in the answer string. The below figure explains this:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"698\" height=\"214\" src=\"https://lh4.googleusercontent.com/dn1E8FkvkQe5-218ps0qS5bHupyLOm4lpj3JIkADTNXBmENRsIxumxw49WyJNGJb0MPYuAF9bEQIgNRh9ea431jBzaSLXFiXRicjSN76B7iuQS09c_Tro3KQNL-ynzMrRiRxa33c\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Length of Shortest Common Supersequence?</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>From the explanation above, we can see that characters of lcs need to be covered only once. Therefore, the length of the shortest Common supersequence =<strong> n + m -k</strong>, where (n and m are lengths of S1 and S2, and k is the length of the lcs string).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Finding the supersequence string</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, instead of the length, we are interested in finding the shortest supersequence string itself. Readers are highly advised to read the article <a href=\"https://takeuforward.org/data-structure/print-longest-common-subsequence-dp-26/\" target=\"_blank\" rel=\"noreferrer noopener\">Print Longest Common Subsequence</a>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Intuition:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>When we form the DP table to calculate the longest common subsequence (as done in <a href=\"https://takeuforward.org/data-structure/print-longest-common-subsequence-dp-26/\" target=\"_blank\" rel=\"noreferrer noopener\">Print Longest Common Subsequence</a>) we have all the information of characters that are coming in the lcs string and characters that don\u2019t. We use this same DP table to form the shortest common supersequence.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"476\" height=\"438\" src=\"https://lh4.googleusercontent.com/N8H5wN5dhc9ieVkv9skfHeJVVPQ4vqqEA34a6JP74RP0bixZqw0bne55XrCOCzBsetmOOHhOhrivOcLADqgSTjnF5sSgfqbAkjymnbPPvYulX_B86HJyFR0n283oJ3cgJn8JwYs3\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>To frame the string, we need to understand how the dp table was formed and work in the reverse process.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, let us see what were the conditions that we used while forming the dp array:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>if(S1[i-1] == S2[j-1])</strong>, then return 1 + dp[i-1][j-1]</li><li><strong>if(S1[i-1] != S2[j-1]) ,</strong> then return 0 + max(dp[i-1][j],dp[i][j-1])</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will start from the right-most cell of the dp array, initially i=n and j=m</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>To form the string, we will work in a reverse manner.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>if(S1[i-1] == S2[j-1]), </strong>this means the character is an lcs character and needs to be included only once from both the strings, so we add it to the ans string and reduce both i and j by 1. We reduce them simultaneously to make sure the character is counted only once.</li><li>if(S1[i-1] != S2[j-1]), this means that the character is a non-lcs character and then we move the pointer to the top cell or left cell depending on which is greater. This way non-lcs characters will be included separately in the right order.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are stated below:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>We start from cell dp[n][m]. Initially i=n and j=m.</li><li>At every cell, we will check if S1[i-1] == S2[j-1], if it is then it means this character is a part of the longest common subsequence. So we will push it to the ans string str. Then we will move to the diagonally top-left(\u2196)&nbsp; cell by assigning i to i-1 and j to j-1.</li><li>Else, this character is not a part of the longest common subsequence so we include it in ans string. Originally this cell got its value from its left cell (\u2190) or from its top cell (\u2191). Whichever cell\u2019s value will be more of the two, we will move to that cell.</li><li>We will continue till i&gt;0 and j&gt;0, failing it we will break from the loop.</li><li>After breaking, either i&gt;0 or j&gt;0 (only one condition will fail to break from the while loop), if(i&gt;0) we push all the characters from S1 to ans string, else if(j&gt;0), we push all the remaining characters from S2.</li><li>At last, we reverse the \u2018ans\u2019 string and we get our answer.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Dry Run:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>At starting i=5 and j=5.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"343\" src=\"https://lh6.googleusercontent.com/5Bd4LT6tixSoKt3zR-qNR9CfhkKpZYJ-XOCk-kWy-V-7fX8BxgixFNxJJn9dF3nTuFj6oQ4dzkyTmSe2F2h26q3RbetgdtGtyTyt9Eb4ux1bGYsMY9Zfp8HdrrVHmX_CsZXeukPI\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(i) As S1[4] != S2[4], we move to the top cell(\u2191) as its value is greater than the left cell(\u2190)&nbsp; but before moving as we are leaving row 5(i=5) and will not return to it so we add S1[4] to our ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(ii) As S1[3] == S2[4], this is an lcs-character. We add the current character to the ans string(and move to i-1 and j-1 cell) i.e top-left(\u2196). <strong>Reducing i and j simultaneously helps in adding the lcs character only once in the ans string.</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"328\" src=\"https://lh5.googleusercontent.com/WcE4nV3ZAIpRUAhfakUZww4db8rKw_8N-bqsax1NF8SbWD4vFG4EpsPApW0pz7Wg4k5PXrkaPF0y7EEXnEIKxaekXicRcGOWF4AQEwenS6o0bUBnUeik2aYMIedZ8ISsDGL4OuIc\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(iii) As S1[2] != S2[3], we move to the left cell(\u2190) as its value is greater than or equal to the top cell(\u2191) but before moving as we are leaving column 4 (j=4) and will not return to it so we add S2[3] to our ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(iv) As S1[2] != S2[2], we move to the left cell(\u2190) as its value is greater than or equal to the top cell(\u2191) but before moving as we are leaving column 3 (j=3) and will not return to it so we add S2[2] to our ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"337\" src=\"https://lh6.googleusercontent.com/wKwuJZgNFCqAijbV1_Jrrw4AHrYIYikbRUmWDHT80V8_CLIRUERwfwpA0KLXOYUOeCmxerb8MqECLKpvXHc9ULQG8khDNIbZLV62CE7bKjDBxg3EDLljqstmTKOMoeI0RqP4YNDc\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(v) As S1[2] != S2[1], we move to the top cell(\u2191) as its value is greater than the left cell(\u2190)&nbsp; but before moving as we are leaving row 3(i=3) and will not return to it so we add S1[2] to our ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(vi) As S1[1] == S2[1], this is an lcs-character. We add the current character to the ans string(and move to i-1 and j-1 cell) i.e top-left(\u2196).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"329\" src=\"https://lh3.googleusercontent.com/mRb54iK7C9JDLIIqMld-lwHofvmrsJ05hSWRHAVd_3xornzrInPT-iX5IsXDiFWMMILukU6sWZcSYyQ3AOq8qD_uYxKugkp6KJ9biB59lCA0-COCSMG2xkXrA3kO_Vi_85Cq89tx\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(vii)&nbsp; As S1[2] != S2[2], we move to the left cell(\u2190) as its value is greater than or equal to the top cell(\u2191) but before moving as we are leaving column 1 (j=1) and will not return to it so we add S2[0] to our ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(viii) As j=0, we have reached the exit condition of the while loop, so we will break from it but still there are some characters left in the other string. We will simply add them in the ans string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>(ix) At last, we will return the <strong>reverse of the ans string</strong> as the final answer.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nstring shortestSupersequence(string s1, string s2){\n\n  int n = s1.size();\n  int m = s2.size();\n\n  vector &lt; vector &lt; int &gt;&gt; dp(n + 1, vector &lt; int &gt; (m + 1, 0));\n  for (int i = 0; i &lt;= n; i++) {\n    dp[i][0] = 0;\n  }\n  for (int i = 0; i &lt;= m; i++) {\n    dp[0][i] = 0;\n  }\n\n  for (int ind1 = 1; ind1 &lt;= n; ind1++) {\n    for (int ind2 = 1; ind2 &lt;= m; ind2++) {\n      if (s1[ind1 - 1] == s2[ind2 - 1])\n        dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];\n      else\n        dp[ind1][ind2] = 0 + max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);\n    }\n  }\n\n  int len = dp[n][m];\n  int i = n;\n  int j = m;\n\n  int index = len - 1;\n  string ans = \"\";\n\n  while (i &gt; 0 &amp;&amp; j &gt; 0) {\n    if (s1[i - 1] == s2[j - 1]) {\n      ans += s1[i-1];\n      index--;\n      i--;\n      j--;\n    } else if (dp[i - 1][j] &gt; dp[i][j - 1]) {\n        ans += s1[i-1];\n        i--;\n    } else {\n        ans += s2[j-1];\n        j--;\n    }\n  }\n  \n  //Adding Remaing Characters - Only one of the below two while loops will run \n  \n  while(i&gt;0){\n      ans += s1[i-1];\n      i--;\n  }\n  while(j&gt;0){\n      ans += s2[j-1];\n      j--;\n  }\n\n  reverse(ans.begin(),ans.end());\n  \n  return ans;\n}\n\nint main() {\n\n  string s1 = \"brute\";\n  string s2 = \"groot\";\n\n  cout &lt;&lt; \"The Longest Common Supersequence is \"&lt;&lt;shortestSupersequence(s1,s2);\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The Longest Common Supersequence is bgruoote</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an external array of size (N*M).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass TUF{\nstatic String shortestSupersequence(String s1, String s2){\n\n  int n = s1.length();\n  int m = s2.length();\n\n  int[][] dp =new int[n+1][m+1];\n  for (int i = 0; i &lt;= n; i++) {\n    dp[i][0] = 0;\n  }\n  for (int i = 0; i &lt;= m; i++) {\n    dp[0][i] = 0;\n  }\n\n  for (int ind1 = 1; ind1 &lt;= n; ind1++) {\n    for (int ind2 = 1; ind2 &lt;= m; ind2++) {\n      if (s1.charAt(ind1 - 1) == s2.charAt(ind2 - 1))\n        dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];\n      else\n        dp[ind1][ind2] = 0 + Math.max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);\n    }\n  }\n\n  int len = dp[n][m];\n  int i = n;\n  int j = m;\n\n  int index = len - 1;\n  String ans = \"\";\n\n  while (i &gt; 0 &amp;&amp; j &gt; 0) {\n    if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n      ans += s1.charAt(i-1);\n      index--;\n      i--;\n      j--;\n    } else if (dp[i - 1][j] &gt; dp[i][j - 1]) {\n        ans += s1.charAt(i-1);\n        i--;\n    } else {\n        ans += s2.charAt(j-1);\n        j--;\n    }\n  }\n  \n  //Adding Remaing Characters - Only one of the below two while loops will run \n  \n  while(i&gt;0){\n      ans += s1.charAt(i-1);\n      i--;\n  }\n  while(j&gt;0){\n      ans += s2.charAt(j-1);\n      j--;\n  }\n\n  String ans2=new StringBuilder(ans).reverse().toString();\n  \n  return ans2;\n}\n\npublic static void main(String args[]) {\n\n  String s1 = \"brute\";\n  String s2 = \"groot\";\n\n  System.out.println(\"The Longest Common Supersequence is \"+shortestSupersequence(s1,s2));\n}\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The Longest Common Supersequence is bgruoote</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an external array of size (N*M).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block\" data-lang=\"python\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def shortestSupersequence(s1, s2):\n    n = len(s1)\n    m = len(s2)\n\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n    for i in range(n + 1):\n        dp[i][0] = 0\n    for i in range(m + 1):\n        dp[0][i] = 0\n\n    for ind1 in range(1, n + 1):\n        for ind2 in range(1, m + 1):\n            if s1[ind1 - 1] == s2[ind2 - 1]:\n                dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]\n            else:\n                dp[ind1][ind2] = 0+ max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1])\n\n    len_ = dp[n][m]\n    i = n\n    j = m\n\n    index = len_ - 1\n    ans = \"\"\n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            ans += s1[i - 1]\n            index -= 1\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            ans += s1[i - 1]\n            i -= 1\n        else:\n            ans += s2[j - 1]\n            j -= 1\n    #Adding Remaing Characters - Only one of the below two while loops will run \n    while i > 0:\n        ans += s1[i - 1]\n        i -= 1\n    while j > 0:\n        ans += s2[j - 1]\n        j -= 1\n\n    ans=ans[::-1]\n    return ans\n\ndef main():\n    s1 = \"brute\"\n    s2 = \"groot\"\n    print(\"The Longest Common Supersequence is \" + shortestSupersequence(s1, s2))\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The Longest Common Supersequence is bgruoote</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*M)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using an external array of size (N*M).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to\u00a0<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\">Anshuman Sharma</a></strong>\u00a0<em>and\u00a0<a href=\"https://www.linkedin.com/in/abhipsita-das-5b7069212/?originalSubdomain=in\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Abhipsita Das</strong></a></em></em> <em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,\u00a0</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 67,
    "preview": "Problem Statement: Shortest Common Supersequence We are given two strings \u2018S1\u2019 and \u2018S2\u2019. We need to return their shortest common supersequence. A supersequence is defined as the string which contai..."
}