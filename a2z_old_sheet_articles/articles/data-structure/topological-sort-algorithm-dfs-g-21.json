{
    "dislikes": 2,
    "video": "5lZ0iJMrUMk",
    "publishedOn": "Sun Mar 24 2024 22:11:43 GMT+0530 (India Standard Time)",
    "slug": "topological-sort-algorithm-dfs-g-21",
    "aid": "2147",
    "title": "Topological Sort Algorithm | DFS: G-21",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/topological-sort-or-kahns-algorithm",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given a <a href=\"https://takeuforward.org/graph/introduction-to-graph/\">Directed Acyclic Graph (DAG)</a> with V vertices and E edges, Find any Topological Sorting of that Graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:<em> </em></strong><em>In topological sorting, node u will always appear before node v if there is a directed edge from node u towards node v(u -&gt; v).</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input:</b> V = 6, E = 6\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/10/image-14.png\" alt=\"\" class=\"wp-image-6778\"></figure>\n<b>Output:</b> 5, 4, 2, 3, 1, 0\n<b>Explanation</b>: A graph may have multiple topological sortings. \nThe result is one of them. The necessary conditions \nfor the ordering are:\n<ul><li>According to edge <strong>5 -&gt; 0, </strong>node 5 must appear before node 0 in the ordering.</li><li>According to edge <strong>4 -&gt; 0, </strong>node 4 must appear before node 0 in the ordering.</li><li>According to edge <strong>5 -&gt; 2, </strong>node 5 must appear before node 2 in the ordering.</li><li>According to edge <strong>2 -&gt; 3, </strong>node 2 must appear before node 3 in the ordering.</li><li>According to edge <strong>3 -&gt; 1, </strong>node 3 must appear before node 1 in the ordering.</li><li>According to edge <strong>4 -&gt; 1, </strong>node 4 must appear before node 1 in the ordering.</li></ul>\nThe above result satisfies all the necessary conditions. \n[4, 5, 2, 3, 1, 0] is also one such topological sorting \nthat satisfies all the conditions.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input:</b> V = 4, E = 3\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/10/image-15.png\" alt=\"\" class=\"wp-image-6779\"></figure>\n<b>Result:</b> 3, 2, 1, 0\n<b>Explanation:</b> The necessary conditions for the ordering are:\n<ul><li>For edge <strong>1 -&gt; 0</strong> node 1 must appear before node 0.</li><li>For edge <strong>2 -&gt; 0</strong> node 1 must appear before node 0.</li><li>For edge <strong>3 -&gt; 0</strong> node 1 must appear before node 0.</li></ul>\n<b>[2, 3, 1, 0]</b> is also another topological sorting for the graph.\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/topological-sort/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=topological-sort\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem link</em></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Topological sorting only exists in <a href=\"https://takeuforward.org/graph/introduction-to-graph/\" target=\"_blank\" rel=\"noopener\" title=\"\">Directed Acyclic Graph (DAG)</a>. If the nodes of a graph are connected through directed edges and the graph does not contain a cycle, it is called a <strong>directed acyclic graph(DAG)</strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The <strong><em>topological sorting</em></strong> of a directed acyclic graph is nothing but the linear ordering of vertices such that if there is an edge between node u and v(u -&gt; v), node u appears before v in that ordering.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, let's understand <strong><em>Why topological sort only exists in DAG:</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Case 1 (If the edges are undirected)</strong>: If there is an undirected edge between node u and v, it signifies that there is an edge from node u to v(u -&gt; v) as well as there is an edge from node v to u(v -&gt; u). But according to the definition of topological sorting, it is practically impossible to write such ordering where <strong><em>u appears before v</em></strong> and <strong><em>v appears before u </em></strong>simultaneously. So, it is only possible for directed edges.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Case 2(If the directed graph contains a cycle)</strong>: The following directed graph contains a cycle:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6780,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/10/image-16.png\" alt=\"\" class=\"wp-image-6780\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><li>If we try to get topological sorting of this cyclic graph, for edge 1-&gt;2, node 1 must appear before 2, for edge 2-&gt;3, node 2 must appear before 3, and for edge 3-&gt;1, node 3 must appear before 1 in the linear ordering. But such ordering is not possible as there exists a cyclic dependency in the graph. Thereby, topological sorting is only possible for a directed acyclic graph.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will be solving it using the DFS traversal technique. DFS goes in-depth, i.e., traverses all nodes by going ahead, and when there are no further nodes to traverse in the current path, then it backtracks on the same path and traverses other unvisited nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>We must traverse all components of the graph.</li><li>Make sure to carry a visited array(all elements are initialized to 0) and a stack data structure, where we are going to store the nodes after completing the DFS call.</li><li>In the DFS call, first, the current node is marked as visited. Then DFS call is made for all its adjacent nodes.</li><li>After visiting all its adjacent nodes, DFS will backtrack to the previous node and meanwhile, the current node is pushed into the stack.</li><li>Finally, we will get the stack containing one of the topological sortings of the graph.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s quickly understand the algorithm considering the following graph:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6781,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/10/image-17.png\" alt=\"\" class=\"wp-image-6781\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><li>DFS will start from <strong>node 0</strong> and mark it as visited. But it has no adjacent nodes. So the DFS will return putting node 0 into the stack( stack: {0} ).</li><li>Then DFS will again start from <strong>node 1</strong> and mark it as visited, but it also has no adjacent nodes. So node 1 is pushed into the stack( stack: {1, 0} ) and the DFS call will be over.</li><li>Then DFS will start from <strong>node 2</strong> and mark it as visited as well. It will again call DFS for its adjacent node 3 and mark 3 as visited. After visiting node 3, it will find out that only adjacent node 1 is previously visited.</li><li>So it will backtrack to node 2, putting node 3 first and then node 2 into the stack ( stack: {2, 3, 1, 0} ).</li><li>Again, DFS will start from <strong>node 4</strong> and mark it as visited. It will find all its adjacent nodes 0 and 1 have been previously visited. So, node 4 will be pushed into the stack( stack: {4, 2, 3, 1, 0} ).</li><li>Lastly, DFS will start from <strong>node 5 </strong>and mark it as visited. Again, it will find all its adjacent nodes 0 and 2 are previously visited. So, it will return putting node 5 into the stack( stack: {5, 4, 2, 3, 1, 0} ).</li><li>Finally, the stack will contain {5, 4, 2, 3, 1, 0}, which is one of the topological sortings of the graph.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand how the linear orderings are maintained considering the following simple graph:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6782,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/10/image-18.png\" alt=\"\" class=\"wp-image-6782\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>The linear ordering for the above graph can be 1, 2, 3, 4, 5, 6 or 1, 2, 3, 4, 6, 5. If we closely observe this algorithm, it is designed in such a way that when the DFS call for a node is completed, the node is always kept in the stack. So for example, if the DFS call for 3 is over, we must have the nodes 3, 4, 5, and 6 linearly ordered in the stack. And this is true for every other node. Thus the linear ordering is always maintained for each node of the graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Since we are inserting the nodes into the stack after the completion of the traversal, we are making sure, there will be no one who appears afterward but may come before in the ordering as everyone during the traversal would have been inserted into the stack.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>Points to remember, that node will be marked as visited immediately after making the DFS call and before returning from the DFS call, the node will be pushed into the stack.</em><strong><br><br>Code</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution {\nprivate:\n\tvoid dfs(int node, int vis[], stack&lt;int&gt; &amp;st,\n\t         vector&lt;int&gt; adj[]) {\n\t\tvis[node] = 1;\n\t\tfor (auto it : adj[node]) {\n\t\t\tif (!vis[it]) dfs(it, vis, st, adj);\n\t\t}\n\t\tst.push(node);\n\t}\npublic:\n\t//Function to return list containing vertices in Topological order.\n\tvector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[])\n\t{\n\t\tint vis[V] = {0};\n\t\tstack&lt;int&gt; st;\n\t\tfor (int i = 0; i &lt; V; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tdfs(i, vis, st, adj);\n\t\t\t}\n\t\t}\n\n\t\tvector&lt;int&gt; ans;\n\t\twhile (!st.empty()) {\n\t\t\tans.push_back(st.top());\n\t\t\tst.pop();\n\t\t}\n\t\treturn ans;\n\t}\n};\n\n\nint main() {\n\n\t//V = 6;\n\tvector&lt;int&gt; adj[6] = {{}, {}, {3}, {1}, {0, 1}, {0, 2}};\n\tint V = 6;\n\tSolution obj;\n\tvector&lt;int&gt; ans = obj.topoSort(V, adj);\n\n\tfor (auto node : ans) {\n\t\tcout &lt;&lt; node &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 5 4 2 3 1 0</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+E)+O(V), where V = no. of nodes and E = no. of edges. There can be at most V components. So, another O(V) time complexity.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2N) + O(N) ~ O(2N): O(2N) for the visited array and the stack carried during DFS calls and O(N) for recursive stack space, where N = no. of nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass Solution {\n    private static void dfs(int node, int vis[], Stack&lt;Integer&gt; st,\n            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {\n        vis[node] = 1;\n        for (int it : adj.get(node)) {\n            if (vis[it] == 0)\n                dfs(it, vis, st, adj);\n        }\n        st.push(node);\n    }\n\n    // Function to return list containing vertices in Topological order.\n    static int[] topoSort(int V, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {\n        int vis[] = new int[V];\n        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();\n        for (int i = 0; i &lt; V; i++) {\n            if (vis[i] == 0) {\n                dfs(i, vis, st, adj);\n            }\n        }\n\n        int ans[] = new int[V];\n        int i = 0;\n        while (!st.isEmpty()) {\n            ans[i++] = st.peek();\n            st.pop();\n        }\n        return ans;\n    }\n}\n\npublic class tUf {\n    public static void main(String[] args) {\n        int V = 6;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; V; i++) {\n            adj.add(new ArrayList&lt;&gt;());\n        }\n        adj.get(2).add(3);\n        adj.get(3).add(1);\n        adj.get(4).add(0);\n        adj.get(4).add(1);\n        adj.get(5).add(0);\n        adj.get(5).add(2);\n\n        int[] ans = Solution.topoSort(V, adj);\n        for (int node : ans) {\n            System.out.print(node + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 5 4 2 3 1 0</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+E)+O(V), where V = no. of nodes and E = no. of edges. There can be at most V components. So, another O(V) time complexity.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2N) + O(N) ~ O(2N): O(2N) for the visited array and the stack carried during DFS calls and O(N) for recursive stack space, where N = no. of nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 137,
    "preview": "Problem Statement: Given a Directed Acyclic Graph (DAG) with V vertices and E edges, Find any Topological Sorting of that Graph. Note: In topological sorting, node u will always appear before node..."
}