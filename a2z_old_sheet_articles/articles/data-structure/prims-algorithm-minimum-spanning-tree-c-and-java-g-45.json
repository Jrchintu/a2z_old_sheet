{
    "dislikes": 4,
    "video": "mJcZjjKzeqk",
    "publishedOn": "Sun Mar 24 2024 22:11:48 GMT+0530 (India Standard Time)",
    "slug": "prims-algorithm-minimum-spanning-tree-c-and-java-g-45",
    "aid": "2164",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/find-the-mst-weight",
    "title": "Prim's Algorithm - Minimum Spanning Tree - C++ and Java: G-45",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "category_tag": "data-structure",
    "likes": 124,
    "preview": "Problem Statement: Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree. (Sometimes it may b...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given a weighted, undirected, and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.<br>(<em>Sometimes it may be asked to find the MST as well, where in the MST the edge-informations will be stored in the form {u, v}(u = starting node, v = ending node).</em>)</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre><b>Input Format:</b> \nV = 5, edges = { {0, 1, 2}, {0, 3, 6}, {1, 2, 3}, {1, 3, 8}, {1, 4, 5}, {4, 2, 7}}\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-25-202057.png\" alt=\"\" class=\"wp-image-7018\"></figure>\n<b>Result:</b> 16\n<b>Explanation:</b> \nThe minimum spanning tree for the given graph is drawn below:\nMST = {(0, 1), (0, 3), (1, 2), (1, 4)}\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-25-202305.png\" alt=\"\" class=\"wp-image-7019\"></figure>\n</pre>\n<!-- /wp:html -->\n\n<p><strong>Example 2</strong>:</p>\n<pre><strong>Input Format</strong>: \nV = 5, edges = { {0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}}\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-25-202402.png\" alt=\"\" class=\"wp-image-7020\"></figure>\n<strong>Result</strong>: 5\n<strong>Explanation</strong>: \nThe minimum spanning tree is drawn below:\n<br><strong><em>MST</em></strong><em> = {(0, 2), (1, 2), (2, 3), (3, 4)}</em><p></p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/image-9.png\" alt=\"\" class=\"wp-image-7021\"></figure>\n</pre>\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/minimum-spanning-tree/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=minimum-spanning-tree\"><em>Problem Link</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In our previous article, we discussed <a href=\"https://takeuforward.org/data-structure/minimum-spanning-tree-theory-g-44/\" target=\"_blank\" rel=\"noopener\" title=\"\"><strong><em>what a minimum spanning tree is</em></strong></a>. Now it\u2019s time to discuss <strong><em>Prim\u2019s algorithm</em></strong> which will help us to find the minimum spanning tree for a given graph.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:&nbsp;</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In order to implement Prim\u2019s algorithm, we will be requiring an array(<strong><em>visited array</em></strong>) and a priority queue that will essentially represent a <a href=\"https://takeuforward.org/heap/binary-heap-implementation/\" target=\"_blank\" rel=\"noopener\" title=\"\">min-heap</a>. We need another array(<strong><em>MST</em></strong>) as well if we wish to store the edge information of the minimum spanning tree.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Priority Queue(Min Heap):</strong> The priority queue will be storing the pairs (edge weight, node). We can start from any given node. Here we are going to start from node 0 and so we will initialize the priority queue with (0, 0). If we wish to store the mst of the graph, the priority queue should instead store the triplets (edge weight, adjacent node, parent node) and in that case, we will initialize with (0, 0, -1).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Visited array: </strong>All the nodes will be initially marked as unvisited.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>sum variable: </strong>It will be initialized with 0 and we wish that it will store the sum of the edge weights finally.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>MST array(optional):</strong> If we wish to store the minimum spanning tree(MST) of the graph, we need this array. This will store the edge information as a pair of starting and ending nodes of a particular edge.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>We will first push edge weight 0, node value 0, and parent -1 as a triplet into the priority queue to start the algorithm.<br><strong>Note:</strong> <em>We can start from any node of our choice. Here we have chosen node 0.</em></li><li>Then the top-most element (element with minimum edge weight as it is the min-heap we are using) of the priority queue is popped out.</li><li>After that, we will check whether the popped-out node is visited or not.<br><strong>If the node is visited: </strong>We will continue to the next element of the priority queue.<br><strong>If the node is not visited: </strong>We will mark the node visited in the <strong><em>visited array</em></strong> and add the edge weight to the sum variable. If we wish to store the mst, we should insert the parent node and the current node into the mst array as a pair in this step.</li><li>Now, we will iterate on all the unvisited adjacent nodes of the current node and will store each of their information in the specified triplet format i.e. (edge weight, node value, and parent node) in the priority queue.</li><li>We will repeat steps 2, 3, and 4 using a loop until the priority queue becomes empty.</li><li>Finally, the sum variable should store the sum of all the edge weights of the minimum spanning tree.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>Points to remember if we do not wish to store the mst(minimum spanning tree) for the graph and are only concerned about the sum of all the edge weights of the minimum spanning tree:</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><em>First of all, we will not use the triplet format instead, we will just use the pair in the format of (edge weight, node value). Basically, we do not need the parent node.</em></li><li><em>In step 3, we need not store anything in the mst array and we need not even use the mst array in our whole algorithm as well.</em></li></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Intuition:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The intuition of this algorithm is the greedy technique used for every node. If we carefully observe, for every node, we are greedily selecting its unvisited adjacent node with the minimum edge weight(as the priority queue here is a min-heap and the topmost element is the node with the minimum edge weight). Doing so for every node, we can get the sum of all the edge weights of the minimum spanning tree and the spanning tree itself(if we wish to) as well.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n\t//Function to find sum of weights of edges of the Minimum Spanning Tree.\n\tint spanningTree(int V, vector&lt;vector&lt;int&gt;&gt; adj[])\n\t{\n\t\tpriority_queue&lt;pair&lt;int, int&gt;,\n\t\t               vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;\n\n\t\tvector&lt;int&gt; vis(V, 0);\n\t\t// {wt, node}\n\t\tpq.push({0, 0});\n\t\tint sum = 0;\n\t\twhile (!pq.empty()) {\n\t\t\tauto it = pq.top();\n\t\t\tpq.pop();\n\t\t\tint node = it.second;\n\t\t\tint wt = it.first;\n\n\t\t\tif (vis[node] == 1) continue;\n\t\t\t// add it to the mst\n\t\t\tvis[node] = 1;\n\t\t\tsum += wt;\n\t\t\tfor (auto it : adj[node]) {\n\t\t\t\tint adjNode = it[0];\n\t\t\t\tint edW = it[1];\n\t\t\t\tif (!vis[adjNode]) {\n\t\t\t\t\tpq.push({edW, adjNode});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\n\n\nint main() {\n\n\tint V = 5;\n\tvector&lt;vector&lt;int&gt;&gt; edges = {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};\n\tvector&lt;vector&lt;int&gt;&gt; adj[V];\n\tfor (auto it : edges) {\n\t\tvector&lt;int&gt; tmp(2);\n\t\ttmp[0] = it[1];\n\t\ttmp[1] = it[2];\n\t\tadj[it[0]].push_back(tmp);\n\n\t\ttmp[0] = it[0];\n\t\ttmp[1] = it[2];\n\t\tadj[it[1]].push_back(tmp);\n\t}\n\n\tSolution obj;\n\tint sum = obj.spanningTree(V, adj);\n\tcout &lt;&lt; \"The sum of all the edge weights: \" &lt;&lt; sum &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The sum of all the edge weights: 5</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(E*logE) + O(E*logE)~ O(E*logE), where E = no. of given edges.<br>The maximum size of the priority queue can be E so after at most E iterations the priority queue will be empty and the loop will end. Inside the loop, there is a pop operation that will take logE time. This will result in the first O(E*logE) time complexity. Now, inside that loop, for every node, we need to traverse all its adjacent nodes where the number of nodes can be at most E. If we find any node unvisited, we will perform a push operation and for that, we need a logE time complexity. So this will result in the second O(E*logE).&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(E) + O(V), where E = no. of edges and V = no. of vertices. O(E) occurs due to the size of the priority queue and O(V) due to the visited array. If we wish to get the mst, we need an extra O(V-1) space to store the edges of the most.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\n// User function Template for Java\n\nclass Pair {\n    int node;\n    int distance;\n    public Pair(int distance, int node) {\n        this.node = node;\n        this.distance = distance;\n    }\n}\nclass Solution {\n    //Function to find sum of weights of edges of the Minimum Spanning Tree.\n    static int spanningTree(int V,\n                            ArrayList&lt;ArrayList&lt;ArrayList&lt;Integer&gt;&gt;&gt; adj) {\n        PriorityQueue&lt;Pair&gt; pq =\n            new PriorityQueue&lt;Pair&gt;((x, y) -&gt; x.distance - y.distance);\n\n        int[] vis = new int[V];\n        // {wt, node}\n        pq.add(new Pair(0, 0));\n        int sum = 0;\n        while (pq.size() &gt; 0) {\n            int wt = pq.peek().distance;\n            int node = pq.peek().node;\n            pq.remove();\n\n            if (vis[node] == 1) continue;\n            // add it to the mst\n            vis[node] = 1;\n            sum += wt;\n\n            for (int i = 0; i &lt; adj.get(node).size(); i++) {\n                int edW = adj.get(node).get(i).get(1);\n                int adjNode = adj.get(node).get(i).get(0);\n                if (vis[adjNode] == 0) {\n                    pq.add(new Pair(edW, adjNode));\n                }\n            }\n        }\n        return sum;\n    }\n}\n\npublic class tUf {\n    public static void main(String[] args) {\n        int V = 5;\n        ArrayList&lt;ArrayList&lt;ArrayList&lt;Integer&gt;&gt;&gt; adj = new ArrayList&lt;ArrayList&lt;ArrayList&lt;Integer&gt;&gt;&gt;();\n        int[][] edges =  {{0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}};\n\n        for (int i = 0; i &lt; V; i++) {\n            adj.add(new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;());\n        }\n\n        for (int i = 0; i &lt; 6; i++) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            int w = edges[i][2];\n\n            ArrayList&lt;Integer&gt; tmp1 = new ArrayList&lt;Integer&gt;();\n            ArrayList&lt;Integer&gt; tmp2 = new ArrayList&lt;Integer&gt;();\n            tmp1.add(v);\n            tmp1.add(w);\n\n            tmp2.add(u);\n            tmp2.add(w);\n\n            adj.get(u).add(tmp1);\n            adj.get(v).add(tmp2);\n        }\n\n        Solution obj = new Solution();\n        int sum = obj.spanningTree(V, adj);\n        System.out.println(\"The sum of all the edge weights: \" + sum);\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The sum of all the edge weights: 5</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(E*logE) + O(E*logE)~ O(E*logE), where E = no. of given edges.<br>The maximum size of the priority queue can be E so after at most E iterations the priority queue will be empty and the loop will end. Inside the loop, there is a pop operation that will take logE time. This will result in the first O(E*logE) time complexity. Now, inside that loop, for every node, we need to traverse all its adjacent nodes where the number of nodes can be at most E. If we find any node unvisited, we will perform a push operation and for that, we need a logE time complexity. So this will result in the second O(E*logE).&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(E) + O(V), where E = no. of edges and V = no. of vertices. O(E) occurs due to the size of the priority queue and O(V) due to the visited array. If we wish to get the mst, we need an extra O(V-1) space to store the edges of the most.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}