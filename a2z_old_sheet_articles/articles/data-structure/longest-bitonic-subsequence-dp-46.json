{
    "dislikes": 5,
    "video": "y4vN0WNdrlg",
    "publishedOn": "Sun Mar 24 2024 22:11:39 GMT+0530 (India Standard Time)",
    "slug": "longest-bitonic-subsequence-dp-46",
    "aid": "2130",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/longest-bitonic-subsequence",
    "title": "Longest Bitonic Subsequence | (DP-46)",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        }
    ],
    "likes": 35,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Longest Bitonic Subsequence Prerequisite: Longest increasing subsequence, Printing Longest Increasing subsequence Problem Link: Given an array, \u2018Arr\u2019 of length \u2018n\u2019, find the long...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Longest Bitonic Subsequence</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>Prerequisite: </em><a href=\"https://takeuforward.org/data-structure/longest-increasing-subsequence-dp-41/\" target=\"_blank\" rel=\"noopener\"><em>Longest increasing subsequence</em></a><em>, </em><a href=\"https://takeuforward.org/data-structure/printing-longest-increasing-subsequence-dp-42/\" target=\"_blank\" rel=\"noopener\"><em>Printing Longest Increasing subsequence</em></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><a href=\"https://www.codingninjas.com/codestudio/problems/longest-bitonic-sequence_1062688?source=youtube&amp;campaign=striver_dp_videos&amp;utm_source=youtube&amp;utm_medium=affiliate&amp;utm_campaign=striver_dp_videos\" target=\"_blank\" rel=\"noopener\">Problem Link</a>:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given an array, \u2018Arr\u2019 of length \u2018n\u2019, find the longest bitonic subsequence.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"140\" src=\"https://lh4.googleusercontent.com/mPCnc0492bscv3TU6MoqwmSqsaUo7VQmgOgmmq6NWWw-sg3sv3_uJQNMn6z1Mu98_A-PDvpTBzvozwP--d3Hr8qeCNGtBLj-2wBzxc9vlVWOzj4w5QNLWziTBDWuxqq6Thg0NHSyEu70Er_n0jy6tZOGGyXtpWCFUCZtzOEYv2mq4jJNCljm8NexXg\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let us first understand what a bitonic subsequence means.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>A bitonic subsequence is a subsequence of an array in which the elements can be any of these three:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>First, increase till a point and then decrease.</li><li>Goes on increasing (Longest increasing subsequence)</li><li>Goes on decreasing (Longest decreasing subsequence)</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"257\" src=\"https://lh3.googleusercontent.com/t0G5UmQxtq019ibxd8FeK8rh54wi4CYdgXoX9fF3lG8uRm5pgE-L18uOU4M8YzsatQ_zmuYiHVJ5uKv2qjhpoGkvNp--LEWGS6VtHLsOoGgKLxu2aDAgMHTdPEWvJKtBvUppyBpXNVmpBU6atKPPsg1XL9shJ1-nb8B4pF14rGVBH0iJ1cVNU3dEcg\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Bitonic subsequence for the below example is:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"552\" height=\"297\" src=\"https://lh5.googleusercontent.com/e1nPzUbfZ2eZfIkNY7kb1dxuaf_gAnEtCM2qUfzuC0TN5K_ctGNdr0B0pn6AJzPBM5ETE2qN433hm5ovCnHkAaJsaGhp1ARrQwZLx78gb7iZ16LTy5Pg49RTAE0GK5vJWERZx3RIsdnOtTqqo-qn86B3v7sojO-niTGItNlU4TIUJlICjzkjQJ5fwA\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Similarly, a subsequence having the elements in either increasing or decreasing order only also counts as a bitonic subsequence. For example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"537\" height=\"151\" src=\"https://lh6.googleusercontent.com/MoxlW3UrHLuOW08EDLc2xgCUD4JPNhs5VATDXJlAQlNz4wxQDPd1f9Jo6YFRGde_9wu7qE0TVUG5yXHWErUgIfLBrJCgDrHKLFvZ2MuOHIhhazfVQhwZuov32sbeYjzhkJKS9HcFsJ2poPltF8muQSTv85hAl43IrSU5ofgL0PYpy-tZjYNUVEqROw\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We need to return the length of the longest bitonic subsequence as our answer.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Intuition:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The length of the increasing and then decreasing subsequence gives us the hint to think in terms of the longest increasing subsequence (LIS). Now let us revise the approach for finding the LIS as discussed in <a href=\"https://takeuforward.org/data-structure/printing-longest-increasing-subsequence-dp-42/\" target=\"_blank\" rel=\"noopener\"><em>Printing Longest Increasing subsequence</em></a>. Readers are highly advised to understand that approach first. In that solution, we write two nested loops to get a dp array whose maximum element gives us the length of the LIS as shown below:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"339\" src=\"https://lh3.googleusercontent.com/D3fGadt5LLlpYxXEG6mleDECaaKpGfsLv3D0eBrPBAiOZwML1aYxcPB78ibYC-r82W4g7g4S0jTKv1Io2-G3zrVioic4tjElEQQEucmqvd_R3sS3-F5I9ZughQVJu-0j6sfoPivD3e7TjNoGUw3hhJwj2xGCh7aNPjECx-TAepEPRxobXmumHmtCFw\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, what does this dp[i] represent? It represents the LIS in the array \u2018arr\u2019 from index 0 to index i in the array ending with element arr[i]. Therefore the maximum value of dp[i] gives us the LIS of the array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"629\" height=\"390\" src=\"https://lh5.googleusercontent.com/jhRwJtt0z_kCgBvu5KjmqshgoAOnOWGOD1RfHkArgdD5SUqnC0RdKtL2nwltcx7gyK2Z9ExRDelEH6lsHFrQV3rN928ZDnRVFnb-1_QkfVfDcTG2KO6Nop38t5FTSBn-nUj-NzZX133NlQ0sudWpdrRgQxNY7W5CY-nDusHULGxwmzKLPJvNUZd0TA\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, after understanding the approach to finding the LIS let us revisit the problem of the longest bitonic subsequence and how it is linked with the problem of LIS.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The below figure breaks general bitonic subsequence into two parts:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"545\" src=\"https://lh5.googleusercontent.com/Bg09piSsBJxtzcDoK3BJ0MOPLpoz2WFNBRPlynMHCHYUx3cFyaoQ4rNDGbuZfUAhfhMIn7-3SjLIsxTk9feedJ8TxWhdTKuBaDXyskaV21VNV8V6u8_PuDxptLmky_PNr-RmQHL1cuyqQclrXO6j_zIsDmvRu4TJQrsumI7Dm_-bng69C_gm4e1_dA\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As we can see in the second part of the bitonic subsequence, the decreasing part, LDS from index i to index n-1 can also be thought of in terms of LIS from index n-1 to index i. Therefore we can compute this two LIS separately to determine the length of the bitonic subsequence:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"682\" height=\"204\" src=\"https://lh5.googleusercontent.com/Dv3lmFy7wuO7IwaF5W6Tb5UTrFhcXqBb9jXqIZQ6NfE8rUOs2-fAlBdcPz6vFFywjMTS7CHqyAB_FvIeESFRR4aDuz7sj1q4KqsBhVHEncYV_1WGBv0a-Ff1Qt9DJtBwLLy3gpgANO57ty3oKnyA7joW55xiESZ22GLQmJwxW6Q8NTfW1xsDS4VvSA\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now with these two separate lengths of LIS, we can calculate the length of the longest bitonic subsequence for each index i. Here index i is acting as the pivot point of the points. Therefore the length of the longest bitonic subsequence at pivot [ i ] will be dp1[i] + dp2[i] -1. (Note that we are counting the element at index i twice in both the parts so we need to subtract 1 from the final answer). We will return the maximum value of this addition as the final answer as the length of the longest bitonic subsequence.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"613\" height=\"575\" src=\"https://lh6.googleusercontent.com/Oq4pESZbsozBdYKZExfMT3aEl6-G1BeeN8bDDH-Ahkw_77MWARWaCodKZ6rQPJVFbjxnbX1g_p6iYxnzfc-PK9uAlENsv4OGXM0CpXtoFIVF2DgmnbOIsH57RKWNLflgDvTmljvk_14muRKnNncCNWzd7XdHyuvp57HtHwOrmd0kypdVfWPjGJHKxw\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Therefore we will return the max in ans array (6) as the final answer.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The algorithm approach is stated as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Using the approach of the article <a href=\"https://takeuforward.org/data-structure/printing-longest-increasing-subsequence-dp-42/\" target=\"_blank\" rel=\"noopener\"><em>Printing Longest Increasing subsequence</em></a>, find the dp1[ ] array, where dp1[i] gives us the length of the LIS from index 0 to index i.</li><li>Modifying the approach slightly, find the dp2[ ] array, where dp2[i] gives us the length of the LIS from index n-1 to index i. To find this opposite direction LIS simply reverses the direction of variables in the nested loops (see the code).</li><li>At last return the answer (the length of the longest bitonic subsequence) as the maximum value of dp1[i] - dp2[i] -1.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to find the length of the longest bitonic subsequence\nint longestBitonicSequence(vector&lt;int>&amp; arr, int n) {\n    // Initialize two arrays to store the increasing and decreasing subsequences\n    vector&lt;int> dp1(n, 1); // dp1[i] stores the length of the longest increasing subsequence ending at arr[i]\n    vector&lt;int> dp2(n, 1); // dp2[i] stores the length of the longest decreasing subsequence ending at arr[i]\n\n    // Calculate the longest increasing subsequence\n    for (int i = 0; i &lt; n; i++) {\n        for (int prev_index = 0; prev_index &lt; i; prev_index++) {\n            if (arr[prev_index] &lt; arr[i]) {\n                dp1[i] = max(dp1[i], 1 + dp1[prev_index]);\n            }\n        }\n    }\n\n    // Reverse the direction of nested loops to calculate the longest decreasing subsequence\n    for (int i = n - 1; i >= 0; i--) {\n        for (int prev_index = n - 1; prev_index > i; prev_index--) {\n            if (arr[prev_index] &lt; arr[i]) {\n                dp2[i] = max(dp2[i], 1 + dp2[prev_index]);\n            }\n        }\n    }\n\n    int maxi = -1;\n\n    // Find the maximum length of the bitonic subsequence\n    for (int i = 0; i &lt; n; i++) {\n        maxi = max(maxi, dp1[i] + dp2[i] - 1);\n    }\n\n    return maxi;\n}\n\nint main() {\n    vector&lt;int> arr = {1, 11, 2, 10, 4, 5, 2, 1};\n    int n = arr.size();\n\n    cout &lt;&lt; \"The length of the longest bitonic subsequence is \" &lt;&lt; longestBitonicSequence(arr, n) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest bitonic subsequence is 6</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops that are run twice.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are only using two rows of size n.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass TUF {\n    // Function to find the length of the longest bitonic subsequence\n    static int longestBitonicSequence(int[] arr, int n) {\n        // Arrays to store lengths of increasing and decreasing subsequences\n        int[] dp1 = new int[n];\n        int[] dp2 = new int[n];\n\n        // Initialize both arrays with 1, as each element itself is a subsequence of length 1\n        Arrays.fill(dp1, 1);\n        Arrays.fill(dp2, 1);\n\n        // Calculate the lengths of increasing subsequences\n        for (int i = 0; i &lt; n; i++) {\n            for (int prevIndex = 0; prevIndex &lt; i; prevIndex++) {\n                if (arr[prevIndex] &lt; arr[i]) {\n                    dp1[i] = Math.max(dp1[i], 1 + dp1[prevIndex]);\n                }\n            }\n        }\n\n        // Reverse the direction of nested loops and calculate the lengths of decreasing subsequences\n        for (int i = n - 1; i >= 0; i--) {\n            for (int prevIndex = n - 1; prevIndex > i; prevIndex--) {\n                if (arr[prevIndex] &lt; arr[i]) {\n                    dp2[i] = Math.max(dp2[i], 1 + dp2[prevIndex]);\n                }\n            }\n        }\n\n        int maxi = -1;\n\n        // Calculate the length of the longest bitonic subsequence\n        for (int i = 0; i &lt; n; i++) {\n            maxi = Math.max(maxi, dp1[i] + dp2[i] - 1);\n        }\n\n        return maxi;\n    }\n\n    public static void main(String[] args) {\n        int arr[] = {1, 11, 2, 10, 4, 5, 2, 1};\n        int n = arr.length;\n\n        System.out.println(\"The length of the longest bitonic subsequence is \" +\n                longestBitonicSequence(arr, n));\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest bitonic subsequence is 6</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops that are run twice.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are only using two rows of size n.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block\" data-lang=\"python\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def longest_bitonic_sequence(arr):\n    n = len(arr)\n\n    # Initialize two dynamic programming lists for increasing and decreasing subsequences\n    dp1 = [1] * n\n    dp2 = [1] * n\n\n    # Calculate the length of the longest increasing subsequence\n    for i in range(n):\n        for prev_index in range(i):\n            if arr[prev_index] &lt; arr[i]:\n                dp1[i] = max(dp1[i], 1 + dp1[prev_index])\n\n    # Reverse the direction of nested loops to calculate the length of the longest decreasing subsequence\n    for i in range(n - 1, -1, -1):\n        for prev_index in range(n - 1, i, -1):\n            if arr[prev_index] &lt; arr[i]:\n                dp2[i] = max(dp2[i], 1 + dp2[prev_index])\n\n    maxi = -1\n\n    # Find the maximum length of bitonic subsequence by combining increasing and decreasing lengths\n    for i in range(n):\n        maxi = max(maxi, dp1[i] + dp2[i] - 1)\n\n    return maxi\n\n\nif __name__ == \"__main__\":\n    arr = [1, 11, 2, 10, 4, 5, 2, 1]\n    n = len(arr)\n\n    print(\"The length of the longest bitonic subsequence is\", longest_bitonic_sequence(arr))\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest bitonic subsequence is 6</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops that are run twice.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are only using two rows of size n.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>[tabby title=\"JavaScript Code\"]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">function longestBitonicSequence(arr) {\n    const n = arr.length;\n\n    // Initialize two arrays to store increasing and decreasing subsequences\n    const dp1 = new Array(n).fill(1); // dp1[i] stores the length of the longest increasing subsequence ending at index i\n    const dp2 = new Array(n).fill(1); // dp2[i] stores the length of the longest decreasing subsequence starting at index i\n\n    // Compute the longest increasing subsequence from left to right\n    for (let i = 0; i &lt; n; i++) {\n        for (let prevIndex = 0; prevIndex &lt; i; prevIndex++) {\n            if (arr[prevIndex] &lt; arr[i]) {\n                dp1[i] = Math.max(dp1[i], 1 + dp1[prevIndex]);\n            }\n        }\n    }\n\n    // Compute the longest decreasing subsequence from right to left\n    for (let i = n - 1; i >= 0; i--) {\n        for (let prevIndex = n - 1; prevIndex > i; prevIndex--) {\n            if (arr[prevIndex] &lt; arr[i]) {\n                dp2[i] = Math.max(dp2[i], 1 + dp2[prevIndex]);\n            }\n        }\n    }\n\n    let maxi = -1;\n\n    // Calculate the length of the longest bitonic subsequence\n    for (let i = 0; i &lt; n; i++) {\n        maxi = Math.max(maxi, dp1[i] + dp2[i] - 1);\n    }\n\n    return maxi;\n}\n\n// Main function\nfunction main() {\n    const arr = [1, 11, 2, 10, 4, 5, 2, 1];\n\n    const result = longestBitonicSequence(arr);\n    console.log(\"The length of the longest bitonic subsequence is:\", result);\n}\n\n// Call the main function\nmain();\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The length of the longest bitonic subsequence is 6</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are two nested loops that are run twice.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are only using two rows of size n.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Anshuman Sharma</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}