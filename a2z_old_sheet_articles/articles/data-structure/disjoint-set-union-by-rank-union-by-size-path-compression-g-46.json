{
    "dislikes": 3,
    "video": "aBxjDBC4M1U",
    "publishedOn": "Sun Mar 24 2024 22:11:48 GMT+0530 (India Standard Time)",
    "slug": "disjoint-set-union-by-rank-union-by-size-path-compression-g-46",
    "aid": "2165",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/disjoint-set-",
    "title": "Disjoint Set | Union by Rank | Union by Size | Path Compression: G-46",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "category_tag": "data-structure",
    "likes": 207,
    "preview": "In this article, we will discuss the Disjoint Set data structure which is a very important topic in the entire graph series. Let\u2019s first understand why we need a Disjoint Set data structure using t...",
    "content": "<!-- wp:paragraph -->\n<p>In this article, we will discuss the <strong><em>Disjoint Set</em></strong> data structure which is a very important topic in the entire graph series. Let\u2019s first understand <strong><em>why we need a Disjoint Set data structure using the below question:</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Question: </strong>Given two components of an undirected graph</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7031,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-181547.png\" alt=\"\" class=\"wp-image-7031\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>The question is whether node 1 and node 5 are in the same component or not.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, in order to solve this question we can use either the <a href=\"https://takeuforward.org/data-structure/depth-first-search-dfs/\" target=\"_blank\" rel=\"noopener\" title=\"\">DFS</a> or <a href=\"https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/\" target=\"_blank\" rel=\"noopener\" title=\"\">BFS</a> traversal technique like if we traverse the components of the graph we can find that node 1 and node 5 are not in the same component. This is actually the <strong><em>brute force</em></strong> approach whose time complexity is <strong>O(N+E)</strong><em>(N = no. of nodes, E = no. of edges).</em> But <strong><em>using a Disjoint Set data structure we can solve this same problem in constant time</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The disjoint Set data structure is generally used for <strong><em>dynamic graphs</em></strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Dynamic graph:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>A dynamic graph generally refers to a graph that keeps on changing its configuration. Let\u2019s deep dive into it using an example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Let\u2019s consider the edge information for the given graph as: {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}, {3,7}}. Now if we start adding the edges one by one, in each step the structure of the graph will change. So, after each step, if we perform the same operation on the graph while updating the edges, the result might be different. In this case, the graph will be considered a dynamic graph.</li><li>For example, after adding the first 4 edges if we look at the graph, we will find that node 4 and node 1 belong to different components but after adding all 6 edges if we search for the same we will figure out that node 4 and node 1 belong to the same component.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":7032,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-181740.png\" alt=\"\" class=\"wp-image-7032\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><li>So, <strong><em>after any step, if we try to figure out whether two arbitrary nodes u and v belong to the same component or not, Disjoint Set will be able to answer this query in constant time.</em></strong></li></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3>Functionalities of Disjoint Set data structure:</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The disjoint set data structure generally provides two types of functionalities:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Finding the parent for a particular node (<strong><em>findPar()</em></strong><em>)</em></li><li>Union (in broad terms this method basically adds an edge between two nodes)<ul><li>Union by rank</li><li>Union by size</li></ul></li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>First, we will be discussing Union by rank and then Union by size.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Union by rank:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Before discussing Union by rank we need to discuss some terminologies:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Rank:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The rank of a node generally refers to the distance (the number of nodes including the leaf node) between the furthest leaf node and the current node. Basically rank includes all the nodes beneath the current node.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7033,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-182019.png\" alt=\"\" class=\"wp-image-7033\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Ultimate parent:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The parent of a node generally refers to the node right above that particular node. But the ultimate parent refers to the topmost node or the root node.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7034,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/image.png\" alt=\"\" class=\"wp-image-7034\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now let\u2019s discuss the implementation of the union by rank function. In order to implement Union by rank, we basically need two arrays of size N(no. of nodes). One is the <strong><em>rank </em></strong>and the other one is the <strong><em>parent</em></strong>. The rank array basically stores the rank of each node and the parent array stores the ultimate parent for each node.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Algorithm:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>rank array: </strong>This array is initialized with zero.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>parent array: </strong>The array is initialized with the value of nodes i.e. parent[i] = i.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>Firstly, the Union function requires two nodes(<strong><em>let\u2019s say u and v</em></strong>) as arguments. Then we will find the ultimate parent (using the findPar() function that is discussed later) of u and v. Let\u2019s consider the ultimate parent of u is <strong><em>pu </em></strong>and the ultimate parent of v is <strong><em>pv</em></strong>.</li><li>After that, we will find the rank of <strong><em>pu</em></strong> and <strong><em>pv</em></strong>.</li><li>Finally, we will connect the ultimate parent with a smaller rank to the other ultimate parent with a larger rank. But if the ranks are equal, we can connect any parent to the other parent and we will increase the rank by one for the parent node to whom we have connected the other one.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand it further using the below example.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given the edges of a graph are: {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}}</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7035,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-182259.png\" alt=\"\" class=\"wp-image-7035\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>After applying the union by rank function to every edge the graph and the arrays will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Observation 1:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>&nbsp;</strong>If we carefully observe, we are only concerned about the ultimate parent but not the immediate parent.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s see <strong><em>why we need to find the ultimate parents</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>After union by rank operations, if we are asked (refer to the above picture) if node 5 and node 7 belong to the same component or not, the answer must be yes. If we carefully look at their immediate parents, they are not the same but if we consider their ultimate parents they are the same i.e. node 4. So, we can determine the answer by considering the ultimate parent. That is why we need to find the ultimate parent.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>So, here comes the <strong>findPar() function</strong> which will help us to find the ultimate parent for a particular node.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>findPar() function:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>This function actually takes a single node as an argument and finds the ultimate parent for each node.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Observation 2:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Now, if we try to find the ultimate parent(typically using recursion) of each query separately, it will end up taking O(logN) time complexity for each case. But we want the operation to be done in a constant time. This is where the <strong><em>path compression technique </em></strong>comes in.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Using the <strong><em>path compression technique</em></strong> we can reduce the time complexity nearly to constant time. It is discussed later on why the time complexity actually reduces.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><em>What is path compression?</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Basically, connecting each node in a particular path to its ultimate parent refers to path compression. Let\u2019s understand it using the following illustration:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7038,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-183506.png\" alt=\"\" class=\"wp-image-7038\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong><em>How the time complexity reduces:</em></strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:list -->\n<ul><li>Before path compression, if we had tried to find the ultimate parent for node 4, we had to traverse all the way back to node 1 which is basically the height of size logN. But after path compression, we can easily access the ultimate parent with a single step. Thus the traversal reduces and as a result the time complexity also reduces.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Though using the path compression technique it seems like the rank of the node is also changing, we cannot be sure about it. So, we will not make any changes to the rank array while applying path compression. The following example depicts an example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7037,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-182656.png\" alt=\"\" class=\"wp-image-7037\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>We cannot change the ranks while applying path compression.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Overall, findPar() method helps to reduce the time complexity of the <strong><em>union by the rank </em></strong>method as it can find the ultimate parent within constant time.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Algorithm:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This process is done using the backtracking method.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li><strong>Base case: </strong>If the node and the parent of the node become the same, it will return the node.</li><li>We will call the findPar() function for a node until it hits the base case and while backtracking we will update the parent of the current node with the returned value.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>The actual time complexity of union by rank and findPar() is O(4) which is very small and close to 1. So, we can consider 4 as a constant. Now, this 4 term has a long mathematical derivation which is not required for an interview.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code of Union by rank and findPar():</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nclass DisjointSet {\n    vector&lt;int&gt; rank, parent;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] &lt; rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] &lt; rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n};\nint main() {\n    DisjointSet ds(7);\n    ds.unionByRank(1, 2);\n    ds.unionByRank(2, 3);\n    ds.unionByRank(4, 5);\n    ds.unionByRank(6, 7);\n    ds.unionByRank(5, 6);\n    // if 3 and 7 same or not\n    if (ds.findUPar(3) == ds.findUPar(7)) {\n        cout &lt;&lt; \"Same\\n\";\n    }\n    else cout &lt;&lt; \"Not same\\n\";\n\n    ds.unionByRank(3, 7);\n\n    if (ds.findUPar(3) == ds.findUPar(7)) {\n        cout &lt;&lt; \"Same\\n\";\n    }\n    else cout &lt;&lt; \"Not same\\n\";\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Not same<br>Same</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; </strong>The actual time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\nclass DisjointSet {\n    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();\n    public DisjointSet(int n) {\n        for (int i = 0; i &lt;= n; i++) {\n            rank.add(0);\n            parent.add(i);\n        }\n    }\n\n    public int findUPar(int node) {\n        if (node == parent.get(node)) {\n            return node;\n        }\n        int ulp = findUPar(parent.get(node));\n        parent.set(node, ulp);\n        return parent.get(node);\n    }\n\n    public void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {\n            parent.set(ulp_v, ulp_u);\n        } else {\n            parent.set(ulp_v, ulp_u);\n            int rankU = rank.get(ulp_u);\n            rank.set(ulp_u, rankU + 1);\n        }\n    }\n\n}\n\nclass Main {\n    public static void main (String[] args) {\n        DisjointSet ds = new DisjointSet(7);\n        ds.unionByRank(1, 2);\n        ds.unionByRank(2, 3);\n        ds.unionByRank(4, 5);\n        ds.unionByRank(6, 7);\n        ds.unionByRank(5, 6);\n\n        // if 3 and 7 same or not\n        if (ds.findUPar(3) == ds.findUPar(7)) {\n            System.out.println(\"Same\");\n        } else\n            System.out.println(\"Not Same\");\n\n        ds.unionByRank(3, 7);\n        if (ds.findUPar(3) == ds.findUPar(7)) {\n            System.out.println(\"Same\");\n        } else\n            System.out.println(\"Not Same\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Not same<br>Same</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; </strong>The actual time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Follow-up question:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong><em>In the union by rank method, why do we need to connect the smaller rank to the larger rank?</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Let\u2019s understand it using the following example:</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":7039,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-184425.png\" alt=\"\" class=\"wp-image-7039\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>In this case, the traversal time to find the ultimate parent for nodes 3, 4, 5, 6, 7, and 8 increases and so the path compression time also increases. But if we do the following</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7040,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-184535.png\" alt=\"\" class=\"wp-image-7040\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:list -->\n<ul><li>the traversal time to find the ultimate parent for only nodes 1 and 2 increases. So the path compression time becomes relatively lesser than in the previous case. So, we can conclude that we should always connect a smaller rank to a larger one with the goal of<ul><li><strong><em>shrinking the height of the graph.</em></strong></li><li><strong><em>reducing the time complexity as much as we can.</em></strong></li></ul></li></ul>\n<!-- /wp:list -->\n\n<!-- wp:heading {\"level\":5} -->\n<h5><strong>Observation 3:</strong></h5>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>Until now, we have learned union by rank, the findPar() function, and the path compression technique. Now, if we again carefully observe, after applying path compression the rank of the graphs becomes distorted. So, rather than storing the rank, we can just store the size of the components for comparing which component is greater or smaller.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>So, here comes the concept of <strong><em>Union by size</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":4} -->\n<h4><strong>Union by size:</strong></h4>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>This is as same as the Union by rank method except this method uses the size to compare the components while connecting. That is why we need a <strong><em>\u2018size\u2019 </em></strong>array of size N(no. of nodes) instead of a <strong><em>rank</em></strong> array. The size array will be storing the size for each particular node i.e. size[i] will be the size of the component starting from node i.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>Typically, the size of a node refers to the number of nodes that are connected to it.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Algorithm:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>size array: </strong>This array is initialized with one.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>parent array: </strong>The array is initialized with the value of nodes i.e. parent[i] = i.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>Firstly, the Union function requires two nodes(<strong><em>let\u2019s say u and v</em></strong>) as arguments. Then we will find the ultimate parent (using the findPar() function discussed earlier) of u and v. Let\u2019s consider the ultimate parent of u is <strong><em>pu </em></strong>and the ultimate parent of v is <strong><em>pv</em></strong>.<br></li><li>After that, we will find the size of <strong><em>pu</em></strong> and <strong><em>pv</em></strong> i.e. size[pu] and size[pv].<br></li><li>Finally, we will connect the ultimate parent with a smaller size to the other ultimate parent with a larger size. But if the size of the two is equal, we can connect any parent to the other parent.<br>While connecting in both cases we will increase the size of the parent node to whom we have connected by the size of the other parent node which is actually connected.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s understand it further using the below example.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given the edges of a graph are {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}, {3,7}}</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7041,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-184715.png\" alt=\"\" class=\"wp-image-7041\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>After applying the union by size function to every edge the graph and the arrays will look like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7042,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-14-184818.png\" alt=\"\" class=\"wp-image-7042\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>It seems much more intuitive than union by rank as the rank gets distorted after path compression.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>The findPar() function remains the exact same as we have discussed earlier.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Disjoint Set data structure implementation:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nclass DisjointSet {\n    vector&lt;int&gt; rank, parent, size;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] &lt; rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] &lt; rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] &lt; size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\nint main() {\n    DisjointSet ds(7);\n    ds.unionBySize(1, 2);\n    ds.unionBySize(2, 3);\n    ds.unionBySize(4, 5);\n    ds.unionBySize(6, 7);\n    ds.unionBySize(5, 6);\n    // if 3 and 7 same or not\n    if (ds.findUPar(3) == ds.findUPar(7)) {\n        cout &lt;&lt; \"Same\\n\";\n    }\n    else cout &lt;&lt; \"Not same\\n\";\n\n    ds.unionBySize(3, 7);\n\n    if (ds.findUPar(3) == ds.findUPar(7)) {\n        cout &lt;&lt; \"Same\\n\";\n    }\n    else cout &lt;&lt; \"Not same\\n\";\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: </strong><br>Not Same<br>Same</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; </strong>The time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\nclass DisjointSet {\n    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; size = new ArrayList&lt;&gt;();\n    public DisjointSet(int n) {\n        for (int i = 0; i &lt;= n; i++) {\n            rank.add(0);\n            parent.add(i);\n            size.add(1);\n        }\n    }\n\n    public int findUPar(int node) {\n        if (node == parent.get(node)) {\n            return node;\n        }\n        int ulp = findUPar(parent.get(node));\n        parent.set(node, ulp);\n        return parent.get(node);\n    }\n\n    public void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {\n            parent.set(ulp_v, ulp_u);\n        } else {\n            parent.set(ulp_v, ulp_u);\n            int rankU = rank.get(ulp_u);\n            rank.set(ulp_u, rankU + 1);\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size.get(ulp_u) &lt; size.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\n        } else {\n            parent.set(ulp_v, ulp_u);\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\n        }\n    }\n}\n\nclass Main {\n    public static void main (String[] args) {\n        DisjointSet ds = new DisjointSet(7);\n        ds.unionByRank(1, 2);\n        ds.unionByRank(2, 3);\n        ds.unionByRank(4, 5);\n        ds.unionByRank(6, 7);\n        ds.unionByRank(5, 6);\n\n        // if 3 and 7 same or not\n        if (ds.findUPar(3) == ds.findUPar(7)) {\n            System.out.println(\"Same\");\n        } else\n            System.out.println(\"Not Same\");\n\n        ds.unionByRank(3, 7);\n        if (ds.findUPar(3) == ds.findUPar(7)) {\n            System.out.println(\"Same\");\n        } else\n            System.out.println(\"Not Same\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: </strong><br>Not Same<br>Same</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; </strong>The time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}