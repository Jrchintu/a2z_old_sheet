{
    "dislikes": 2,
    "video": "pDCXsbAw5Cg",
    "publishedOn": "Sun Mar 24 2024 22:11:41 GMT+0530 (India Standard Time)",
    "slug": "matrix-chain-multiplication-tabulation-method-dp-49",
    "aid": "2142",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/matrix-chain-multiplication",
    "title": "Matrix Chain Multiplication | Tabulation Method | (DP-49)",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        }
    ],
    "likes": 21,
    "category_tag": "data-structure",
    "preview": "In the previous article, we learned the solution for the problem of \u201cMatrix chain multiplication\u201d. We had discussed the recursive and memoization solution. In this article, we will learn about the...",
    "content": "<!-- wp:paragraph -->\n<p>In the previous article, we learned the solution for the problem of \u201c<strong>Matrix chain multiplication\u201d</strong>. We had discussed the recursive and memoization solution. In this article, we will learn about the tabulation solution.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/matrix-chain-multiplication_624880?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Understanding the dp array</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In the memoization approach, we have taken a dp[N][N]. Let us revise it and understand what dp[i][j] means.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"624\" height=\"343\" src=\"https://lh5.googleusercontent.com/yFeZ5r5OH9QpP-hdPRqRNIHQlMrpExTh3z7PxXoDJm0i68YdRVXiUILPK2HpWkKDEtUHzRKQs_g15zLp7wFkBNxw5mIZXlVqEfeWj7m09uifTuJNhwGToENqgeQMsffrEbIT5zfOLdlu9TKgFwIFiM6mEWvXwI89ZQBf4UQtwH8r8I-w6t9Kyg2xXw\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As we have to find A1.A2.A3.A4, we will return dp[1][4] as our final answer.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Rules to write tabulation solution from the memoization solution</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>Write the base case.</li><li>Write down the changing parameters in terms of loops.</li><li>Write the recursive logic inside the loops.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Base Case</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let us discuss the base case first, in the memoization approach the base case was:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>if (i==j) return 0<br>Now dp[i][i] means minimum operations to get the multiplication of Ai which means a single array which doesn\u2019t mean anything in the context of this problem so we return 0. Therefore we write a loop to set the base case in our dp array as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"379\" height=\"203\" src=\"https://lh6.googleusercontent.com/VGC5nR75MpNwmR-EYCWLGX0C2-YZ0cWvI9UFlw6kiNPZd3BK6alDfXCjc9unZV2UUauDPZ46ZHoxGtOs53NbUoscYq2fpBisJOaXWXaAFYdqn8oy93adD0m69qI5HfZ4kd3ZjpnBbY9Lek7Cy0LSV6RSqtr-KjaYl1WZj_TIAchwbiWE1GJcXRK9_Q\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Changing Parameters</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In tabulation, we follow a bottom-up approach that is we start from a smaller problem to the bigger problem, so here we start from (n-1)th matrix and move towards the first matrix i.e </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">A4_ -&gt; A3_ -&gt; A2_ -&gt; A1_ . </pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>These dashes are the matrix represented by the j pointer.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>As j&gt;i, we will start j from i+1 to N-1, thus the pattern of problem-solving becomes: </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">A4 -&gt; A3.A4 -&gt; A2.A3.A4 -&gt; A1.A2.A3.A4.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>This pattern can be achieved by writing the loops in the following way:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"477\" height=\"316\" src=\"https://lh5.googleusercontent.com/bF5eDdwgz8lzx2O0wVXvQWLfElPG9nYwYSQ5Kl4KxRzP1xu174ZjOAA86hlkGzQswBtaNwoOUpuYTuEJWefwbQ1e9jwEOKXeo2NmWbw1dHtt0Uk1kymsDlwDkaBy8D6aYTR8CmJZ7RW3i7F0e-EbO6VTExxVGygdcWhXpX5ccC4ep3Jv3GqYjEKBkg\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Recursive Logic:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Next, we just copy down the recursive logic and modify it as required.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to find the minimum number of operations for matrix multiplication\nint matrixMultiplication(vector&lt;int>&amp; arr, int N) {\n    // Create a DP table to store the minimum number of operations\n    vector&lt;vector&lt;int>> dp(N, vector&lt;int>(N, -1));\n\n    // Initialize the diagonal elements of the DP table to 0\n    for (int i = 0; i &lt; N; i++) {\n        dp[i][i] = 0;\n    }\n\n    // Loop for the length of the chain\n    for (int len = 2; len &lt; N; len++) {\n        for (int i = 1; i &lt; N - len + 1; i++) {\n            int j = i + len - 1;\n            dp[i][j] = INT_MAX;\n\n            // Try different partition points to find the minimum\n            for (int k = i; k &lt; j; k++) {\n                int cost = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j];\n                dp[i][j] = min(dp[i][j], cost);\n            }\n        }\n    }\n\n    // The result is stored in dp[1][N-1]\n    return dp[1][N - 1];\n}\n\nint main() {\n    vector&lt;int> arr = {10, 20, 30, 40, 50};\n    int n = arr.size();\n\n    cout &lt;&lt; \"The minimum number of operations for matrix multiplication is \" &lt;&lt; matrixMultiplication(arr, n) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The minimum number of operations are 38000</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max \u2018N*N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using a 2D array ( O(N*N)) space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass TUF {\n    // Function to recursively calculate the minimum number of operations for matrix multiplication\n    static int f(int[] arr, int i, int j, int[][] dp) {\n        // Base condition\n        if (i == j) {\n            return 0;\n        }\n\n        // Check if the result is already computed\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n\n        int minOperations = Integer.MAX_VALUE;\n\n        // Partitioning loop to find the optimal split point\n        for (int k = i; k &lt;= j - 1; k++) {\n            int operations = f(arr, i, k, dp) + f(arr, k + 1, j, dp) + arr[i - 1] * arr[k] * arr[j];\n            minOperations = Math.min(minOperations, operations);\n        }\n\n        dp[i][j] = minOperations;\n        return minOperations;\n    }\n\n    // Function to find the minimum number of operations for matrix multiplication\n    static int matrixMultiplication(int[] arr, int N) {\n        int[][] dp = new int[N][N];\n\n        // Initialize the dp array with -1\n        for (int row[] : dp) {\n            Arrays.fill(row, -1);\n        }\n\n        // Initialize the diagonal with 0\n        for (int i = 1; i &lt; N; i++) {\n            dp[i][i] = 0;\n        }\n\n        // Fill in the dp array using bottom-up approach\n        for (int i = N - 1; i >= 1; i--) {\n            for (int j = i + 1; j &lt; N; j++) {\n                int minOperations = Integer.MAX_VALUE;\n\n                // Partitioning loop to find the optimal split point\n                for (int k = i; k &lt;= j - 1; k++) {\n                    int operations = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j];\n                    minOperations = Math.min(minOperations, operations);\n                }\n\n                dp[i][j] = minOperations;\n            }\n        }\n\n        // The result is stored in dp[1][N-1]\n        return dp[1][N - 1];\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {10, 20, 30, 40, 50};\n        int n = arr.length;\n\n        System.out.println(\"The minimum number of operations are \" + matrixMultiplication(arr, n));\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The minimum number of operations are 38000</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max \u2018N*N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using a 2D array ( O(N*N)) space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block\" data-lang=\"python\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def matrix_multiplication(arr):\n    N = len(arr)\n    \n    # Initialize a 2D dp list with -1 values\n    dp = [[-1 for _ in range(N)] for _ in range(N)]\n    \n    # Initialize the diagonal elements of the dp table to 0\n    for i in range(N):\n        dp[i][i] = 0\n    \n    # Loop through the dp table to calculate the minimum number of operations\n    for i in range(N - 1, 0, -1):\n        for j in range(i + 1, N):\n            mini = float('inf')\n            \n            # Partitioning loop\n            for k in range(i, j):\n                ans = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j]\n                mini = min(mini, ans)\n            \n            dp[i][j] = mini\n    \n    # The result is stored in the top-right corner of the dp table\n    return dp[1][N - 1]\n\n\nif __name__ == \"__main__\":\n    arr = [10, 20, 30, 40, 50]\n\n    print(\"The minimum number of operations is:\", matrix_multiplication(arr))\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The minimum number of operations are 38000</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max \u2018N*N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using a 2D array ( O(N*N)) space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>[tabby title=\"JavaScript Code\"]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">function matrixMultiplication(arr) {\n    const N = arr.length;\n    \n    // Create a 2D DP array to store the minimum number of operations\n    const dp = new Array(N).fill(null).map(() => new Array(N).fill(-1));\n\n    // Initialize the base case where i == j\n    for (let i = 0; i &lt; N; i++) {\n        dp[i][i] = 0;\n    }\n\n    // Loop through the matrix chain sizes starting from the smallest chains\n    for (let chainSize = 2; chainSize &lt; N; chainSize++) {\n        for (let i = 1; i &lt; N - chainSize + 1; i++) {\n            const j = i + chainSize - 1; // Ending index of the chain\n            \n            dp[i][j] = Infinity; // Initialize dp[i][j] to a large value\n            \n            // Partitioning loop to find the minimum number of operations\n            for (let k = i; k &lt; j; k++) {\n                const operations = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j];\n                dp[i][j] = Math.min(dp[i][j], operations);\n            }\n        }\n    }\n\n    // The result will be stored in dp[1][N-1], which represents the minimum operations for the entire chain\n    return dp[1][N - 1];\n}\n\n// Main function\nfunction main() {\n    const arr = [10, 20, 30, 40, 50];\n    \n    const result = matrixMultiplication(arr);\n    console.log(\"The minimum number of operations is:\", result);\n}\n\n// Call the main function\nmain();\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The minimum number of operations are 38000</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O(N*N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: There are N*N states and we explicitly run a loop inside the function which will run for N times, therefore at max \u2018N*N*N\u2019 new problems will be solved.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N*N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Reason: We are using a 2D array ( O(N*N)) space.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Anshuman Sharma</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}