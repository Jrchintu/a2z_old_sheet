{
    "dislikes": 2,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:11:52 GMT+0530 (India Standard Time)",
    "slug": "evaluate-boolean-expression-to-true-partition-dp-dp-52",
    "aid": "2184",
    "tuf_plus": "",
    "title": "Evaluate Boolean Expression to True | Partition DP: DP 52",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        }
    ],
    "category_tag": "data-structure",
    "likes": 46,
    "preview": "Problem Statement: Given an expression, A, with operands and operators (OR, AND, XOR), in how many ways can you evaluate the expression to be true, by grouping it in different ways? Operands are on...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given an expression, A, with operands and operators (OR, AND, XOR), in how many ways can you evaluate the expression to be true, by grouping it in different ways?</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Operands are only true and false.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Return the number of ways to evaluate the expression modulo 103 + 3.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-requisite: </strong><a href=\"https://takeuforward.org/dynamic-programming/matrix-chain-multiplication-dp-48/\" target=\"_blank\" rel=\"noopener\" title=\"\">DP-48</a>, <a href=\"https://takeuforward.org/data-structure/matrix-chain-multiplication-tabulation-method-dp-49/\" target=\"_blank\" rel=\"noopener\" title=\"\">DP-49</a>, <a href=\"https://takeuforward.org/data-structure/minimum-cost-to-cut-the-stick-dp-50/\" target=\"_blank\" rel=\"noopener\" title=\"\">DP-50</a>, <a href=\"https://www.youtube.com/watch?v=Yz4LlDSlkns\" target=\"_blank\" rel=\"noopener\" title=\"\">DP-51</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong> expression = \u201cT|T&amp;F\u201d\n<strong>Output</strong>: 1\n<strong>Explanation:</strong> The only way to get the result as true is:\n(T) | (T&amp;F) = T|F = T </pre>\n<pre class=\"wp-block-preformatted\"><strong>Example 2:</strong>\n<strong>Input</strong>: expression = \u201cF|T^F\u201d\n<strong>Output</strong>: 2\n<strong>Explanation</strong>: There are 2 possible ways to get the result as true:\n\t\ti) (F|T) ^ F = T ^ F = T\n\t\tii) F | (T^F) = F | T = T</pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/boolean-evaluation_1214650?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nRecursive approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nMemoization approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nTabulation Approach\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nRecursive Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<p>In the question, it is clearly stated, that the operands are only \u2018true\u2019 and \u2018false\u2019, and the operators are AND(&amp;), OR(|), and XOR(^).</p>\n<p>If we carefully observe, we can easily understand that the given expression can be solved in several ways. And through several ways, we can achieve different results. For example, if the expression, <strong>\u201cT|T&amp;F\u201d</strong> is given, we can solve it in two different ways like the following:</p>\n<ul><li>(T | T) &amp; F = T &amp; F = F. This method gives the result false.</li><li>(T) | (T &amp; F) = T | F = T. This method gives the result true.</li></ul>\n<p>But here, we are concerned only with the ways, through which we can achieve the result of the expression as true. So, for the above example, we will only consider the second approach. Now, in order to solve the problem, we have to figure out the total no. of such ways through which we can get \u2018true\u2019 as our answer.</p>\n<h4><strong>Observation:</strong></h4>\n<p>Let\u2019s consider the following expression:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-161425.png\" alt=\"\" class=\"wp-image-7223\"></figure>\n<p>If we carefully observe, we can easily notice that the given expression both starts and ends with an operand and the expression also follows a certain pattern i.e. an operand followed by an operator.</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-161512.png\" alt=\"\" class=\"wp-image-7224\"></figure>\n<p>Now, this expression can be primarily partitioned in the following possible ways:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-161619.png\" alt=\"\" class=\"wp-image-7225\"></figure>\n<p>From this illustration, we can easily conclude that the number of partitions we can make equals the number of operators that the expression contains. And we can also assume the left side of each operator is the left subproblem and the right side signifies the right subproblem.<br>Now, each subproblem can be again divided into multiple subproblems in similar ways. For example, the given expression can be divided into subproblems like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-161710.png\" alt=\"\" class=\"wp-image-7226\"></figure>\n<p>Now, we are getting a pattern of dividing the whole expression into smaller subproblems. If we continue to divide the expression, at some point we will get a single operand left.</p>\n<h3><strong>Intuition:</strong><strong>&nbsp;</strong></h3>\n<p><em>The intuition is to divide the expression into subproblems and we will break the expression at the position of the operators.</em>&nbsp;</p>\n<p>We have found the right approach until now. Now, let us quickly revise the rules to solve a problem on partition dp.</p>\n<ol><li>Start with the entire block/array/expression and mark it with i, j.</li><li>Try all partitions.</li><li>Return the best possible answer of the two partitions (the answer that comes after dividing the problem into two subproblems and solving them recursively).</li></ol>\n<p>Now let us go through these rules and apply them to this problem.</p>\n<p><strong>Marking the expression with i, j:</strong></p>\n<p>We are given a string or an expression. The entire expression basically represents the range. So, we will place i and j at both ends of the expression.</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-161801.png\" alt=\"\" class=\"wp-image-7227\"></figure>\n<h4><strong>Try all partitions:</strong></h4>\n<p>As we have figured out the logic for marking the i, and j pointers, we will move to the partitioning loop. We can simply write a for loop(say ind) starting from i+1 to j-1, The problem is being broken in the following manner:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-162601.png\" alt=\"\" class=\"wp-image-7228\"></figure>\n<p><strong>Note: </strong>Here f(i, ind-1) is the left sub-problem, and f(ind+1, j) is the right sub-problem. And the ind variable will start from i+1 and runs up to j-1 and it will move 2 steps in each iteration to select each operator at a time like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-162707.png\" alt=\"\" class=\"wp-image-7229\"></figure>\n<p><strong>Base Case 1: </strong>We can say that when i &gt; j this is not a valid partition and so we will return 0.<br>The other base case is discussed later.</p>\n<p><strong>Return the best possible answer:</strong></p>\n<p>Here, in this problem, we are trying to figure out the total number of ways through which we can get the result true for the given expression. So, the final answer will be the summation of all the answers obtained from the subproblems.</p>\n<p><strong>Observation 1:</strong></p>\n<p>Now, if we want the result true for the whole expression, we can easily observe the following three cases:</p>\n<p><strong>Case 1 (If the partition is made at the \u2018AND(&amp;)\u2019 operator):&nbsp;</strong></p>\n<p>The structure will look like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-163116.png\" alt=\"\" class=\"wp-image-7230\"></figure>\n<p>Now, the whole expression will yield true when the subproblem1 and subproblem2 both will yield true. So, the total number of ways will be = (x1 * x3).</p>\n<p><strong>Case 2 (If the partition is made at the \u2018OR(|)\u2019 operator): </strong></p>\n<p>The structure will look like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-164345.png\" alt=\"\" class=\"wp-image-7232\"></figure>\n<p>Now, the whole expression will yield true in three possible ways:</p>\n<ul><li>Subproblem1 yields true, and subproblem2 yields true i.e. (x1 * x3) ways.</li><li>Subproblem1 yields false and subproblem2 yields true i.e. (x2 * x3) ways.</li><li>Subproblem1 yields true and subproblem2 yields false i.e. (x1 * x4) ways.</li></ul>\n<p>So, total number of ways = (x1 * x3) + (x2 * x3) + (x1 * x4).</p>\n<p><strong>Case 3 (If the partition is made at the \u2018XOR(^)\u2019 operator):</strong></p>\n<p>The structure will look like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-164449.png\" alt=\"\" class=\"wp-image-7233\"></figure>\n<p>Now, the whole expression will yield true in two cases:</p>\n<ul><li>Subproblem1 yields false and subproblem2 yields true i.e. (x2 * x3) ways.</li><li>Subproblem1 yields true and subproblem2 yields false i.e. (x1 * x4) ways.</li></ul>\n<p>So, total number of ways = (x2 * x3) + (x1 * x4).</p>\n<p><strong>Observation 2:</strong></p>\n<p><em>Now, we have found that in order to solve the problem, we need to figure out the number of cases the subproblems yield true and the number of cases the subproblems yield false(i.e. The values of x1, x2, x3, and x4).</em></p>\n<p>In order to do so, we will carry a third variable(let\u2019s say <strong>isTrue</strong>) to indicate for which result we are trying to calculate the number of ways. If <strong>isTrue</strong> is 1, we will calculate the number of ways that provide the result true and if <strong>isTrue</strong> is 0, we will calculate the number of ways that give the result false.</p>\n<p>So, the modified function structure will be the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-164556.png\" alt=\"\" class=\"wp-image-7234\"></figure>\n<h5><strong>Observation 3:</strong></h5>\n<p>Now, if we continue to break down the expression into smaller subproblems, at some point we will get such a subproblem that contains only a single operand. Let\u2019s understand it considering the following illustration:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-164653.png\" alt=\"\" class=\"wp-image-7235\"></figure>\n<p>From the example, we can clearly notice that a subproblem that contains only a single operand(i.e. when i and j are equal, i == j) returns either 1 or 0 ways for true and similarly 1 or 0 ways for false. And this will be the <strong><em>2nd base case.</em></strong></p>\n<p><strong>Base case 2:</strong></p>\n<p>If i and j become equal, we will observe two different cases:</p>\n<ul><li><strong>Case 1 (If we want the number of ways for true(i.e. isTrue = 1))</strong>:<br>If the single operand left, is T(true), it will return 1 way and if it is F(false), it will return 0 ways.</li><li><strong>Case 2 (If we want the number of ways for false(i.e. isTrue = 0))</strong>:<br>If the single operand left, is T(true), it will return 0 ways and if it is F(false), it will return 1 way.</li></ul>\n<p>So, the base case 2 will be the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-164744.png\" alt=\"\" class=\"wp-image-7236\"></figure>\n<p>Now let\u2019s move on to the calculation of the no. of ways:<br>Inside the partitioning loop we will calculate the total no. of ways for the subproblems to be true and false like the following:</p>\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-165006.png\" alt=\"\" class=\"wp-image-7237\"></figure>\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<p><strong>Note: </strong><em>Since the number of ways can be a large number, we are doing a modulo of 1000000007.</em></p>\n<p>Let\u2019s discuss the approach and the implementation part:</p>\n<p><strong>Approach</strong>:&nbsp;</p>\n<p><strong>The recursive algorithm steps are as follows:</strong></p>\n<ol><li>Convert the problem to a recursive function marked by the pointers i and j and the isTrue variable discussed above.</li><li>Use a loop to check all possible partitions of the expression and calculate the total number of ways.</li><li>Return the total number of ways calculated.</li><li><strong>Base case 1: </strong>If i &gt; j, we will return 0.<br><strong>Base case 2: </strong>If i and j become equal, we will observe two different cases:</li></ol>\n<ul><li><strong>Case 1 (If we want the number of ways of true(i.e. isTrue = 1))</strong>:<br>If the single operand left is T(true), it will return 1 way and if it is F(false), it will return 0 ways.</li><li><strong>Case 2 (If we want the number of ways of false(i.e. isTrue = 0))</strong>:<br>If the single operand left is T(true), it will return 0 ways and if it is F(false), it will return 1 way.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\nconst int mod = 1000000007;\n\nint f(int i, int j, int isTrue, string &amp;exp) {\n    // Base case 1: If i &gt; j, it's an invalid expression, return 0.\n    if (i &gt; j) return 0;\n    \n    // Base case 2: If i and j are the same, evaluate the single character.\n    if (i == j) {\n        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;\n        else return exp[i] == 'F' ? 1 : 0;\n    }\n    \n    ll ways = 0;\n    \n    // Iterate through the expression.\n    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n        ll lT = f(i, ind - 1, 1, exp);  // Number of ways to make the left expression true.\n        ll lF = f(i, ind - 1, 0, exp);  // Number of ways to make the left expression false.\n        ll rT = f(ind + 1, j, 1, exp);  // Number of ways to make the right expression true.\n        ll rF = f(ind + 1, j, 0, exp);  // Number of ways to make the right expression false.\n\n        // Check the operator at the current index and update ways accordingly.\n        if (exp[ind] == '&amp;') {\n            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;\n            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;\n        }\n        else if (exp[ind] == '|') {\n            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;\n            else ways = (ways + (lF * rF) % mod) % mod;\n        }\n        else {  // XOR operator\n            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;\n            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;\n        }\n    }\n    return ways;\n}\n\nint evaluateExp(string &amp;exp) {\n    int n = exp.size();\n    return f(0, n - 1, 1, exp);  // Start evaluation with isTrue set to true.\n}\n\nint main() {\n    string exp = \"F|T^F\";\n    int ways = evaluateExp(exp);\n    cout &lt;&lt; \"The total number of ways: \" &lt;&lt; ways &lt;&lt; \"\\n\";\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class BooleanExpressionWays {\n    static final int MOD = 1000000007;\n\n    static long evaluateExpressionWays(String exp, int i, int j, int isTrue, Long[][][] dp) {\n        // Base case 1: When the start index is greater than the end index, no ways to evaluate.\n        if (i &gt; j) {\n            return 0;\n        }\n        // Base case 2: When the start and end indices are the same.\n        if (i == j) {\n            if (isTrue == 1) {\n                return exp.charAt(i) == 'T' ? 1 : 0;\n            } else {\n                return exp.charAt(i) == 'F' ? 1 : 0;\n            }\n        }\n        \n        if (dp[i][j][isTrue] != null) {\n            return dp[i][j][isTrue];\n        }\n\n        long ways = 0;\n        for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n            long lT = evaluateExpressionWays(exp, i, ind - 1, 1, dp);\n            long lF = evaluateExpressionWays(exp, i, ind - 1, 0, dp);\n            long rT = evaluateExpressionWays(exp, ind + 1, j, 1, dp);\n            long rF = evaluateExpressionWays(exp, ind + 1, j, 0, dp);\n\n            char operator = exp.charAt(ind);\n            if (operator == '&amp;') {\n                if (isTrue == 1) {\n                    ways = (ways + (lT * rT) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;\n                }\n            } else if (operator == '|') {\n                if (isTrue == 1) {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rF) % MOD) % MOD;\n                }\n            } else {\n                if (isTrue == 1) {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;\n                }\n            }\n        }\n\n        dp[i][j][isTrue] = ways;\n        return ways;\n    }\n\n    static int evaluateExpWays(String exp) {\n        int n = exp.length();\n        Long[][][] dp = new Long[n][n][2]; // dp[i][j][k] stores the number of ways to evaluate the subexpression from index i to j with the result k (0 or 1).\n        return (int) evaluateExpressionWays(exp, 0, n - 1, 1, dp);\n    }\n\n    public static void main(String[] args) {\n        String exp = \"F|T^F\";\n        int ways = evaluateExpWays(exp);\n        System.out.println(\"The total number of ways: \" + ways);\n    }\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef evaluateExp(exp):\n    n = len(exp)\n    mod = 1000000007\n    \n    def f(i, j, isTrue):\n        # Base case 1:\n        if i &gt; j:\n            return 0\n        # Base case 2:\n        if i == j:\n            if isTrue == 1:\n                return int(exp[i] == 'T')\n            else:\n                return int(exp[i] == 'F')\n        \n        ways = 0\n        for ind in range(i + 1, j, 2):\n            lT = f(i, ind - 1, 1)\n            lF = f(i, ind - 1, 0)\n            rT = f(ind + 1, j, 1)\n            rF = f(ind + 1, j, 0)\n\n            if exp[ind] == '&amp;':\n                if isTrue:\n                    ways = (ways + (lT * rT) % mod) % mod\n                else:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod\n            elif exp[ind] == '|':\n                if isTrue:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod\n                else:\n                    ways = (ways + (lF * rF) % mod) % mod\n            else:\n                if isTrue:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod\n                else:\n                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod\n        \n        return ways\n    \n    return f(0, n - 1, 1)\n\nif __name__ == \"__main__\":\n    exp = \"F|T^F\"\n    ways = evaluateExp(exp)\n    print(\"The total number of ways:\", ways)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction countWaysToEvaluateExpression(exp) {\n    // Define constants for the modulo operation\n    const mod = 1000000007;\n\n    // Function f to recursively count the number of ways to evaluate the expression\n    function f(i, j, isTrue, exp) {\n        // Base case 1: If i &gt; j, there are no ways to evaluate the expression.\n        if (i &gt; j) return 0;\n\n        // Base case 2: If i and j are the same, check if it evaluates to the desired result.\n        if (i === j) {\n            if (isTrue === 1) return exp[i] === 'T' ? 1 : 0;\n            else return exp[i] === 'F' ? 1 : 0;\n        }\n\n        let ways = 0;\n\n        // Iterate through operators at odd indices in the expression\n        for (let ind = i + 1; ind &lt;= j - 1; ind += 2) {\n            // Calculate the number of ways to evaluate the left and right subexpressions\n            const lT = f(i, ind - 1, 1, exp);\n            const lF = f(i, ind - 1, 0, exp);\n            const rT = f(ind + 1, j, 1, exp);\n            const rF = f(ind + 1, j, 0, exp);\n\n            if (exp[ind] === '&amp;') {\n                if (isTrue) ways = (ways + (lT * rT) % mod) % mod;\n                else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;\n            }\n            else if (exp[ind] === '|') {\n                if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;\n                else ways = (ways + (lF * rF) % mod) % mod;\n            }\n            else {\n                if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;\n                else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;\n            }\n        }\n        return ways;\n    }\n\n    // Get the length of the expression\n    const n = exp.length;\n\n    // Call the recursive function with initial values\n    return f(0, n - 1, 1, exp);\n}\n\n// Define the input expression\nconst exp = \"F|T^F\";\n\n// Call the function to count the number of ways to evaluate the expression\nconst ways = countWaysToEvaluateExpression(exp);\n\n// Print the result\nconsole.log(\"The total number of ways:\", ways);\n</code>\n</pre>\n</div>\n\n<p>\n<!-- Insert Output of Brute Force Here -->\nThe total number of ways: 2 (Given expression = \"F|T^F\")\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n</p><p><strong>Time Complexity: Exponential</strong></p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemoization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<p><strong>Steps to memoize the recursive solution:</strong></p>\n<ol><li>Create a 3D dp array of size [n][n][2]. i and j can range from 1 to n and isTrue can range from 0 to 1 so we take the size n X n X 2.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j, isTrue)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j][isTrue] != -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j][isTrue] to the solution we get.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\nconst int mod = 1000000007;\n\nint f(int i, int j, int isTrue, string &amp;exp, vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; &amp;dp) {\n    // Base case 1: If i &gt; j, it's an invalid expression, return 0.\n    if (i &gt; j) return 0;\n    \n    // Base case 2: If i and j are the same, evaluate the single character.\n    if (i == j) {\n        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;\n        else return exp[i] == 'F' ? 1 : 0;\n    }\n\n    // If the result for this subproblem has been computed before, return it.\n    if (dp[i][j][isTrue] != -1) return dp[i][j][isTrue];\n    \n    ll ways = 0;\n    \n    // Iterate through the expression.\n    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n        ll lT = f(i, ind - 1, 1, exp, dp);  // Number of ways to make the left expression true.\n        ll lF = f(i, ind - 1, 0, exp, dp);  // Number of ways to make the left expression false.\n        ll rT = f(ind + 1, j, 1, exp, dp);  // Number of ways to make the right expression true.\n        ll rF = f(ind + 1, j, 0, exp, dp);  // Number of ways to make the right expression false.\n\n        // Check the operator at the current index and update ways accordingly.\n        if (exp[ind] == '&amp;') {\n            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;\n            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;\n        }\n        else if (exp[ind] == '|') {\n            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;\n            else ways = (ways + (lF * rF) % mod) % mod;\n        }\n        else {  // XOR operator\n            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;\n            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;\n        }\n    }\n    \n    // Store the result in the DP table and return it.\n    return dp[i][j][isTrue] = ways;\n}\n\nint evaluateExp(string &amp;exp) {\n    int n = exp.size();\n    vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; dp(n, vector&lt;vector&lt;ll&gt;&gt;(n, vector&lt;ll&gt;(2, -1)));\n    return f(0, n - 1, 1, exp, dp);  // Start evaluation with isTrue set to true.\n}\n\nint main() {\n    string exp = \"F|T^F\";\n    int ways = evaluateExp(exp);\n    cout &lt;&lt; \"The total number of ways: \" &lt;&lt; ways &lt;&lt; \"\\n\";\n    return 0;\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class BooleanExpressionWays {\n    static final int MOD = 1000000007;\n\n    static long evaluateExpressionWays(String exp, int i, int j, int isTrue, Long[][][] dp) {\n        // Base case 1: When the start index is greater than the end index, no ways to evaluate.\n        if (i &gt; j) {\n            return 0;\n        }\n        // Base case 2: When the start and end indices are the same.\n        if (i == j) {\n            if (isTrue == 1) {\n                return exp.charAt(i) == 'T' ? 1 : 0;\n            } else {\n                return exp.charAt(i) == 'F' ? 1 : 0;\n            }\n        }\n        \n        if (dp[i][j][isTrue] != null) {\n            return dp[i][j][isTrue];\n        }\n\n        long ways = 0;\n        for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n            long lT = evaluateExpressionWays(exp, i, ind - 1, 1, dp);\n            long lF = evaluateExpressionWays(exp, i, ind - 1, 0, dp);\n            long rT = evaluateExpressionWays(exp, ind + 1, j, 1, dp);\n            long rF = evaluateExpressionWays(exp, ind + 1, j, 0, dp);\n\n            char operator = exp.charAt(ind);\n            if (operator == '&amp;') {\n                if (isTrue == 1) {\n                    ways = (ways + (lT * rT) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;\n                }\n            } else if (operator == '|') {\n                if (isTrue == 1) {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rF) % MOD) % MOD;\n                }\n            } else {\n                if (isTrue == 1) {\n                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;\n                } else {\n                    ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;\n                }\n            }\n        }\n\n        dp[i][j][isTrue] = ways;\n        return ways;\n    }\n\n    static int evaluateExpWays(String exp) {\n        int n = exp.length();\n        Long[][][] dp = new Long[n][n][2]; // dp[i][j][k] stores the number of ways to evaluate the subexpression from index i to j with the result k (0 or 1).\n        return (int) evaluateExpressionWays(exp, 0, n - 1, 1, dp);\n    }\n\n    public static void main(String[] args) {\n        String exp = \"F|T^F\";\n        int ways = evaluateExpWays(exp);\n        System.out.println(\"The total number of ways: \" + ways);\n    }\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef evaluateExp(exp):\n    n = len(exp)\n    mod = 1000000007\n    \n    def f(i, j, isTrue, dp):\n        # Base case 1:\n        if i &gt; j:\n            return 0\n        # Base case 2:\n        if i == j:\n            if isTrue == 1:\n                return int(exp[i] == 'T')\n            else:\n                return int(exp[i] == 'F')\n        \n        if dp[i][j][isTrue] != -1:\n            return dp[i][j][isTrue]\n        \n        ways = 0\n        for ind in range(i + 1, j, 2):\n            lT = f(i, ind - 1, 1, dp)\n            lF = f(i, ind - 1, 0, dp)\n            rT = f(ind + 1, j, 1, dp)\n            rF = f(ind + 1, j, 0, dp)\n\n            if exp[ind] == '&amp;':\n                if isTrue:\n                    ways = (ways + (lT * rT) % mod) % mod\n                else:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod\n            elif exp[ind] == '|':\n                if isTrue:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod\n                else:\n                    ways = (ways + (lF * rF) % mod) % mod\n            else:\n                if isTrue:\n                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod\n                else:\n                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod\n        \n        dp[i][j][isTrue] = ways\n        return ways\n    \n    dp = [[[ -1 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    return f(0, n - 1, 1, dp)\n\nif __name__ == \"__main__\":\n    exp = \"F|T^F\"\n    ways = evaluateExp(exp)\n    print(\"The total number of ways:\", ways)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\n\ndef count_ways(i, j, is_true, exp, dp):\n    # Base case 1: If i &gt; j, there are no ways to evaluate the expression.\n    if i &gt; j:\n        return 0\n    \n    # Base case 2: If i and j are the same, check if it evaluates to the desired result.\n    if i == j:\n        if is_true == 1:\n            return 1 if exp[i] == 'T' else 0\n        else:\n            return 1 if exp[i] == 'F' else 0\n\n    # Check if the result for this subproblem is already computed\n    if dp[i][j][is_true] != -1:\n        return dp[i][j][is_true]\n\n    ways = 0\n\n    # Iterate through operators at odd indices in the expression\n    for ind in range(i + 1, j, 2):\n        # Calculate the number of ways to evaluate the left and right subexpressions\n        lT = count_ways(i, ind - 1, 1, exp, dp)\n        lF = count_ways(i, ind - 1, 0, exp, dp)\n        rT = count_ways(ind + 1, j, 1, exp, dp)\n        rF = count_ways(ind + 1, j, 0, exp, dp)\n\n        if exp[ind] == '&amp;':\n            if is_true:\n                ways = (ways + (lT * rT) % mod) % mod\n            else:\n                ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod\n        elif exp[ind] == '|':\n            if is_true:\n                ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod\n            else:\n                ways = (ways + (lF * rF) % mod) % mod\n        else:\n            if is_true:\n                ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod\n            else:\n                ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod\n    \n    # Store the result in the memoization table and return it\n    dp[i][j][is_true] = ways\n    return ways\n\n# Function to evaluate the expression\ndef evaluate_expression(exp):\n    n = len(exp)\n    # Create a memoization table initialized with -1\n    dp = [[[-1 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    return count_ways(0, n - 1, 1, exp, dp)\n\n# Define the input expression\nexp = \"F|T^F\"\n\n# Call the function to count the number of ways to evaluate the expression\nmod = 1000000007\nways = evaluate_expression(exp)\n\n# Print the result\nprint(\"The total number of ways:\", ways)\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\nThe total number of ways: 2 (Given expression = \"F|T^F\");\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n</p><p><strong>Time Complexity: </strong>O(N*N*2 * N) ~ O(N<sup>3</sup>) There are a total of 2*N<sup>2</sup> no. of states. And for each state, we are running a partitioning loop roughly for N times.</p>\n<p><strong>Space Complexity: </strong>O(2*N<sup>2</sup>) + Auxiliary stack space of O(N), 2*N<sup>2</sup> for the dp array we are using.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Optimal Approach Here -->\n<p><strong>Tabulation:</strong></p>\n<ol><li>First of all, we handle the base case. If (i &gt; j) we return 0. To cover this case we can initialize the entire dp array with 0.</li><li>Next, memoization is a top-down approach, whereas tabulation is bottom-up. Our changing parameters i and j will change in opposite directions, i.e i will change from n\u21921 and j will change from 1\u2192 n. isTrue will change from 0\u21921.</li><li>Next, we copy down the recursive logic(recurrence) inside the nested loops.</li></ol>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define ll long long\nconst int mod = 1000000007;\n\nint evaluateExp(string &amp;exp) {\n    int n = exp.size();\n    vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; dp(n, vector&lt;vector&lt;ll&gt;&gt;(n, vector&lt;ll&gt;(2, 0)));\n    \n    for (int i = n - 1; i &gt;= 0; i--) {\n        for (int j = 0; j &lt;= n - 1; j++) {\n            // Base case 1: i &gt; j is an invalid case, so continue.\n            if (i &gt; j) continue;\n            \n            for (int isTrue = 0; isTrue &lt;= 1; isTrue++) {\n                // Base case 2: i == j, evaluate the single character.\n                if (i == j) {\n                    if (isTrue == 1) dp[i][j][isTrue] = exp[i] == 'T';\n                    else dp[i][j][isTrue] = exp[i] == 'F';\n                    continue;\n                }\n\n                // Recurrence logic:\n                ll ways = 0;\n                for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n                    ll lT = dp[i][ind - 1][1];\n                    ll lF = dp[i][ind - 1][0];\n                    ll rT = dp[ind + 1][j][1];\n                    ll rF = dp[ind + 1][j][0];\n\n                    if (exp[ind] == '&amp;') {\n                        if (isTrue) ways = (ways + (lT * rT) % mod) % mod;\n                        else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;\n                    }\n                    else if (exp[ind] == '|') {\n                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;\n                        else ways = (ways + (lF * rF) % mod) % mod;\n                    }\n                    else {\n                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;\n                        else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;\n                    }\n                }\n                dp[i][j][isTrue] = ways;\n            }\n        }\n    }\n    return dp[0][n - 1][1];\n}\n\nint main() {\n    string exp = \"F|T^F\";\n    int ways = evaluateExp(exp);\n    cout &lt;&lt; \"The total number of ways: \" &lt;&lt; ways &lt;&lt; \"\\n\";\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\n\npublic class BooleanExpressionWays {\n    static final int MOD = 1000000007;\n\n    static int evaluateExp(String exp) {\n        int n = exp.length();\n        long[][][] dp = new long[n][n][2];\n\n        // Initializing the dp array\n        for (int i = n - 1; i &gt;= 0; i--) {\n            for (int j = 0; j &lt;= n - 1; j++) {\n                if (i &gt; j) continue;\n                for (int isTrue = 0; isTrue &lt;= 1; isTrue++) {\n                    // Base case 1:\n                    if (i == j) {\n                        if (isTrue == 1) dp[i][j][isTrue] = exp.charAt(i) == 'T' ? 1 : 0;\n                        else dp[i][j][isTrue] = exp.charAt(i) == 'F' ? 1 : 0;\n                        continue;\n                    }\n\n                    // Recurrence logic:\n                    long ways = 0;\n                    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {\n                        long lT = dp[i][ind - 1][1];\n                        long lF = dp[i][ind - 1][0];\n                        long rT = dp[ind + 1][j][1];\n                        long rF = dp[ind + 1][j][0];\n\n                        char operator = exp.charAt(ind);\n                        if (operator == '&amp;') {\n                            if (isTrue == 1) ways = (ways + (lT * rT) % MOD) % MOD;\n                            else ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;\n                        } else if (operator == '|') {\n                            if (isTrue == 1) ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;\n                            else ways = (ways + (lF * rF) % MOD) % MOD;\n                        } else {\n                            if (isTrue == 1) ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;\n                            else ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;\n                        }\n                    }\n                    dp[i][j][isTrue] = ways;\n                }\n            }\n        }\n        return (int) dp[0][n - 1][1];\n    }\n\n    public static void main(String[] args) {\n        String exp = \"F|T^F\";\n        int ways = evaluateExp(exp);\n        System.out.println(\"The total number of ways: \" + ways);\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\n\ndef evaluateExp(exp):\n    n = len(exp)\n    mod = 1000000007\n    \n    # Create a 3D DP array to store the results of subproblems\n    dp = [[[0 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    \n    # Iterate over the expression string\n    for i in range(n - 1, -1, -1):\n        for j in range(n):\n            # Base case 1: Skip invalid ranges\n            if i &gt; j:\n                continue\n            \n            # Iterate over possible values of 'isTrue' (0 or 1)\n            for isTrue in range(2):\n                # Base case 2: When i == j\n                if i == j:\n                    if isTrue == 1:\n                        dp[i][j][isTrue] = int(exp[i] == 'T')\n                    else:\n                        dp[i][j][isTrue] = int(exp[i] == 'F')\n                    continue\n                \n                # Recurrence logic\n                ways = 0\n                for ind in range(i + 1, j, 2):\n                    lT = dp[i][ind - 1][1]\n                    lF = dp[i][ind - 1][0]\n                    rT = dp[ind + 1][j][1]\n                    rF = dp[ind + 1][j][0]\n\n                    if exp[ind] == '&amp;':\n                        if isTrue:\n                            ways = (ways + (lT * rT) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod\n                    elif exp[ind] == '|':\n                        if isTrue:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rF) % mod) % mod\n                    else:\n                        if isTrue:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod\n                \n                dp[i][j][isTrue] = ways\n    \n    # The final result is stored in dp[0][n - 1][1] when the expression is considered true\n    return dp[0][n - 1][1]\n\nif __name__ == \"__main__\":\n    exp = \"F|T^F\"\n    ways = evaluateExp(exp)\n    print(\"The total number of ways:\", ways)\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\n\n# Function to evaluate the expression\ndef evaluate_expression(exp):\n    mod = 1000000007\n    n = len(exp)\n    \n    # Create a 3D memoization table initialized with 0\n    dp = [[[0 for _ in range(2)] for _ in range(n)] for _ in range(n)]\n    \n    # Loop through the expression in reverse order\n    for i in range(n - 1, -1, -1):\n        for j in range(n):\n            # Base case 1: Skip invalid cases where i &gt; j\n            if i &gt; j:\n                continue\n            \n            for is_true in range(2):\n                # Base case 2: If i and j are the same, calculate the result\n                if i == j:\n                    if is_true == 1:\n                        dp[i][j][is_true] = 1 if exp[i] == 'T' else 0\n                    else:\n                        dp[i][j][is_true] = 1 if exp[i] == 'F' else 0\n                    continue\n\n                # Recurrence logic:\n                ways = 0\n                for ind in range(i + 1, j, 2):\n                    lT = dp[i][ind - 1][1]\n                    lF = dp[i][ind - 1][0]\n                    rT = dp[ind + 1][j][1]\n                    rF = dp[ind + 1][j][0]\n\n                    if exp[ind] == '&amp;':\n                        if is_true:\n                            ways = (ways + (lT * rT) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod\n                    elif exp[ind] == '|':\n                        if is_true:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rF) % mod) % mod\n                    else:\n                        if is_true:\n                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod\n                        else:\n                            ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod\n\n                dp[i][j][is_true] = ways\n    \n    # The result for the entire expression is stored in dp[0][n - 1][1]\n    return dp[0][n - 1][1]\n\n# Main function\ndef main():\n    exp = \"F|T^F\"\n    ways = evaluate_expression(exp)\n    print(\"The total number of ways:\", ways)\n\nif __name__ == \"__main__\":\n    main()\n\n</code>\n</pre>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\nThe total number of ways: 2 (Given expression = \"F|T^F\");\n</p>\n</div>\n</div></details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n</p><p><strong>Time Complexity: </strong>O(N*N*2 * N) ~ O(N<sup>3</sup>) There are a total of 2*N<sup>2</sup> no. of states. And for each state, we are running a partitioning loop roughly for N times.</p>\n<p><strong>Space Complexity: </strong>O(2*N<sup>2</sup>), 2*N<sup>2</sup> for the dp array we are using.</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Evaluate Boolean Expression to True\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/MM7fXopgyjw?si=ZbpkluRrsSgotYXy\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/MM7fXopgyjw?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Evaluate Boolean Expression to True\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/MM7fXopgyjw?si=ZbpkluRrsSgotYXy\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->"
}