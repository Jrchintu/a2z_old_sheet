{
    "dislikes": 5,
    "video": "WAOfKpxYHR8",
    "publishedOn": "Sun Mar 24 2024 22:11:43 GMT+0530 (India Standard Time)",
    "slug": "course-schedule-i-and-ii-pre-requisite-tasks-topological-sort-g-24",
    "aid": "2152",
    "title": "Course Schedule I and II | Pre-requisite Tasks | Topological Sort: G-24",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/course-schedule-i",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement I (Course Schedule):</strong> There are a total of n tasks you have to pick, labeled from 0 to n-1. Some tasks may have prerequisites tasks, for example, to pick task 0 you have to first finish tasks 1, which is expressed as a pair: [0, 1]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given the total number of n tasks and a list of prerequisite pairs of size m. Find the order of tasks you should pick to finish all tasks.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Note: There may be multiple correct orders, you need to return one of them. If it is impossible to finish all tasks, return an empty array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Statement II (Pre-requisite Tasks): </strong>There are a total of N tasks, labeled from 0 to N-1. Some tasks may have prerequisites, for example, to do task 0 you have to first complete task 1, which is expressed as a pair: [0, 1]</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given the total number of tasks N and a list of prerequisite pairs P, find if it is possible to finish all tasks.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>These two questions are linked. The second question asks if it is possible to finish all the tasks and the first question states to return the ordering of the tasks if it is possible to perform all the tasks, otherwise return an empty array.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong> N = 4, P = 3,  array[] = {{1,0},{2,1},{3,2}}\n<strong>Output:</strong> Yes\n<strong>Explanation:</strong> It is possible to finish all the tasks in the order : 3 2 1 0.\nFirst, we will finish task 3. Then we will finish task 2, task 1, and task 0.\n\n<strong>Example 2:</strong>\n<strong>Input:</strong> N = 4, P = 4,  array[] = {{1,2},{4,3},{2,4},{4,1}}\n<strong>Output:</strong> No\n<strong>Explanation:</strong> It is impossible to finish all the tasks. Let\u2019s analyze the pairs:\nFor pair {1, 2} -&gt; we need to finish task 1 first and then task 2. (order : 1 2).\nFor pair{4, 3} -&gt; we need to finish task 4 first and then task 3. (order: 4 3).\nFor pair {2, 4} -&gt; we need to finish task 2 first and then task 4. (order: 1 2 4 3).\nBut for pair {4, 1} -&gt; we need to finish task 4 first and then task 1 but this pair contradicts the previous pair. So, it is not possible to finish all the tasks.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. <br></em><a href=\"https://practice.geeksforgeeks.org/problems/course-schedule/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=course-schedule\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem link 1</em></a><em>.<br></em><a href=\"https://practice.geeksforgeeks.org/problems/prerequisite-tasks/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=prerequisite-tasks\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem link 2</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The solutions will be similar for both questions as we need to check for one, and in the other, we need to print the order. The questions state that the given pairs signify the dependencies of tasks. For example, <em>the pair </em><strong><em>{u, v}</em></strong> signifies that to perform task v, first we need to finish task u. Now, if we closely observe, we can think of a directed edge between u and v(u -&gt; v) where u and v are two nodes. Now, if we can think of each task as a node and every pair as a directed edge between those two nodes, the whole problem becomes a <strong><em>graph problem</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, let\u2019s analyze the examples from the graph point of view:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For example 1, the number of tasks(considered as nodes) is 4, and pairs(considered as edges) are 3. If we draw the graph accordingly, the following illustration is produced:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6891,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-08-172231.png\" alt=\"\" class=\"wp-image-6891\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>And For example 2, the number of tasks(considered as nodes) is 4, and pairs(considered as edges) are 4. If we draw the graph accordingly, the following illustration is produced:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6892,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/11/Screenshot-2022-11-08-172333.png\" alt=\"\" class=\"wp-image-6892\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Analyzing the graphs, we can conclude that performing all the tasks from the first set is possible because the first graph does not contain any cycle but as the second graph contains a cycle, performing all the tasks from the second set is impossible(there exists a cyclic dependency between the tasks). So, first, we need to identify a graph as a <strong><em>directed acyclic graph</em></strong> and if it is so we need to find out the linear ordering of the nodes as well(<em>second part for the question: Course schedule</em>).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, we have successfully reduced the problem to one of our known concepts: <strong><em>Detect cycle in a directed graph</em></strong>. We will solve this problem using the <strong><em>Topological Sort Algorithm or Kahn\u2019s Algorithm</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Topological sorting only exists in <a href=\"https://takeuforward.org/graph/introduction-to-graph/\" target=\"_blank\" rel=\"noopener\" title=\"\">Directed Acyclic Graph (DAG)</a>. If the nodes of a graph are connected through directed edges and the graph does not contain a cycle, it is called a <strong>directed acyclic graph(DAG)</strong>.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The <strong><em>topological sorting</em></strong> of a directed acyclic graph is nothing but the linear ordering of vertices such that if there is an edge between node u and v(u -&gt; v), node u appears before v in that ordering.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For the second problem, we can also apply the algorithm used in the <a href=\"https://takeuforward.org/data-structure/detect-cycle-in-a-directed-graph-using-dfs-g-19/\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>detection of cycles in a directed graph (using DFS)</em></a> where we used to find out if the graph has a cycle or not. But to solve the first question we have to figure out the linear ordering of the task as well. So, we will use the topological sort algorithm for both questions.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For problem I, the intuition is to find the linear ordering in which the tasks will be performed if it is possible to perform all the tasks otherwise, to return an empty array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>For problem II, the intuition is to find if it is possible to perform all the tasks(i.e. The graph contains a cycle or not).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will apply the <a href=\"https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/\" target=\"_blank\" rel=\"noopener\" title=\"\">BFS(Breadth First Search)</a> traversal technique. Breadth First Search or BFS is a traversal technique where we visit the nodes level-wise, i.e., it visits the same level nodes simultaneously, and then moves to the next level.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial Configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Indegree Array: </strong>Initially all elements are set to 0. Then, We will count the incoming edges for a node and store it in this array. For example, if the indegree of node 3 is 2, indegree[3] = 2.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Queue:</strong> As we will use BFS, a queue is required. Initially, the node with indegree 0 will be pushed into the queue.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Answer array:</strong> Initially empty and is used to store the linear ordering.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First, we will form the adjacency list of the graph using the pairs. For example, for the pair {u, v} we will add node v as an adjacent node of u in the list.</li><li>Then, we will calculate the in-degree of each node and store it in the indegree array. We can iterate through the given adj list, and simply for every node u-&gt;v, we can increase the indegree of v by 1 in the indegree array.&nbsp;</li><li>Initially, there will be always at least a single node whose indegree is 0. So, we will push the node(s) with indegree 0 into the queue.</li><li>Then, we will pop a node from the queue including the node in our answer array, and for all its adjacent nodes, we will decrease the indegree of that node by one. For example, if node u that has been popped out from the queue has an edge towards node v(u-&gt;v), we will decrease indegree[v] by 1.</li><li>After that, if for any node the indegree becomes 0, we will push that node again into the queue.</li><li>We will repeat steps 3 and 4 until the queue is completely empty. Now, completing the BFS we will get the linear ordering of the nodes in the answer array.</li><li><strong>For the first problem(Course Schedule):</strong> We will return the answer array if the length of the ordering equals the number of tasks. Otherwise, we will return an empty array.<br><strong>For the Second problem(Prerequisite tasks): </strong>We will return true if the length of the ordering equals the number of tasks. otherwise, we will return false.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em><strong><br></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code (Course Schedule)</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n\nclass Solution\n{\npublic:\n\tvector&lt;int&gt; findOrder(int V, int m, vector&lt;vector&lt;int&gt;&gt; prerequisites)\n\t{\n\t\tvector&lt;int&gt; adj[V];\n\t\tfor (auto it : prerequisites) {\n\t\t\tadj[it[1]].push_back(it[0]);\n\t\t}\n\n\n\n\t\tint indegree[V] = {0};\n\t\tfor (int i = 0; i &lt; V; i++) {\n\t\t\tfor (auto it : adj[i]) {\n\t\t\t\tindegree[it]++;\n\t\t\t}\n\t\t}\n\n\t\tqueue&lt;int&gt; q;\n\t\tfor (int i = 0; i &lt; V; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tvector&lt;int&gt; topo;\n\t\twhile (!q.empty()) {\n\t\t\tint node = q.front();\n\t\t\tq.pop();\n\t\t\ttopo.push_back(node);\n\t\t\t// node is in your topo sort\n\t\t\t// so please remove it from the indegree\n\n\t\t\tfor (auto it : adj[node]) {\n\t\t\t\tindegree[it]--;\n\t\t\t\tif (indegree[it] == 0) q.push(it);\n\t\t\t}\n\t\t}\n\n\t\tif (topo.size() == V) return topo;\n\t\treturn {};\n\t}\n};\n\n\nint main() {\n\n\tint N = 4;\n\tint M = 3;\n\n\tvector&lt;vector&lt;int&gt;&gt; prerequisites(3);\n\tprerequisites[0].push_back(0);\n\tprerequisites[0].push_back(1);\n\n\tprerequisites[1].push_back(1);\n\tprerequisites[1].push_back(2);\n\n\tprerequisites[2].push_back(2);\n\tprerequisites[2].push_back(3);\n\n\tSolution obj;\n\tvector&lt;int&gt; ans = obj.findOrder(N, M, prerequisites);\n\n\tfor (auto task : ans) {\n\t\tcout &lt;&lt; task &lt;&lt; \" \";\n\t}\n\tcout &lt;&lt; endl;\n\treturn 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 3 2 1 0</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass Solution {\n    static int[] findOrder(int n, int m, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; prerequisites) {\n        // Form a graph\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            adj.add(new ArrayList&lt;&gt;());\n        }\n\n        for (int i = 0; i &lt; m; i++) {\n            adj.get(prerequisites.get(i).get(1)).add(prerequisites.get(i).get(0));\n        }\n\n\n\n        int indegree[] = new int[n];\n        for (int i = 0; i &lt; n; i++) {\n            for (int it : adj.get(i)) {\n                indegree[it]++;\n            }\n        }\n\n\n        Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();\n        for (int i = 0; i &lt; n; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n\n\n        int topo[] = new int[n];\n        int ind = 0;\n        // o(v + e)\n        while (!q.isEmpty()) {\n            int node = q.peek();\n\n            q.remove();\n            topo[ind++] = node;\n            // node is in your topo sort\n            // so please remove it from the indegree\n\n            for (int it : adj.get(node)) {\n                indegree[it]--;\n                if (indegree[it] == 0) q.add(it);\n            }\n        }\n\n\n        if (ind == n) return topo;\n        int[] arr = {};\n        return arr;\n    }\n}\n\npublic class tUf {\n    public static void main(String[] args) {\n        int N = 4;\n        int M = 3;\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; prerequisites = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; N; i++) {\n            prerequisites.add(i, new ArrayList&lt;&gt;());\n        }\n\n\n        prerequisites.get(0).add(0);\n        prerequisites.get(0).add(1);\n\n        prerequisites.get(1).add(1);\n        prerequisites.get(1).add(2);\n\n        prerequisites.get(2).add(2);\n        prerequisites.get(2).add(3);\n\n        int[] ans = Solution.findOrder(N, M, prerequisites);\n\n        for (int task : ans) {\n            System.out.print(task + \" \");\n        }\n        System.out.println(\"\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: 3 2 1 0</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code (Pre-requisite Tasks)</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution {\npublic:\n\tbool isPossible(int V, vector&lt;pair&lt;int, int&gt; &gt;&amp; prerequisites) {\n\t\tvector&lt;int&gt; adj[V];\n\t\tfor (auto it : prerequisites) {\n\t\t\tadj[it.first].push_back(it.second);\n\t\t}\n\n\n\n\t\tint indegree[V] = {0};\n\t\tfor (int i = 0; i &lt; V; i++) {\n\t\t\tfor (auto it : adj[i]) {\n\t\t\t\tindegree[it]++;\n\t\t\t}\n\t\t}\n\n\t\tqueue&lt;int&gt; q;\n\t\tfor (int i = 0; i &lt; V; i++) {\n\t\t\tif (indegree[i] == 0) {\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tvector&lt;int&gt; topo;\n\t\twhile (!q.empty()) {\n\t\t\tint node = q.front();\n\t\t\tq.pop();\n\t\t\ttopo.push_back(node);\n\t\t\t// node is in your topo sort\n\t\t\t// so please remove it from the indegree\n\n\t\t\tfor (auto it : adj[node]) {\n\t\t\t\tindegree[it]--;\n\t\t\t\tif (indegree[it] == 0) q.push(it);\n\t\t\t}\n\t\t}\n\n\t\tif (topo.size() == V) return true;\n\t\treturn false;\n\n\n\t}\n};\n\nint main() {\n\n\tvector&lt;pair&lt;int, int&gt;&gt; prerequisites;\n\tint N = 4;\n\tprerequisites.push_back({1, 0});\n\tprerequisites.push_back({2, 1});\n\tprerequisites.push_back({3, 2});\n\n\tSolution obj;\n\tbool ans = obj.isPossible(N, prerequisites);\n\n\tif (ans) cout &lt;&lt; \"YES\";\n\telse cout &lt;&lt; \"NO\";\n\tcout &lt;&lt; endl;\n\n\treturn 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> YES</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+E), where V = no. of nodes and E = no. of edges. This is a simple BFS algorithm.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N) + O(N) <strong>~ </strong>O(2N), O(N) for the indegree array, and O(N) for the queue data structure used in BFS(where N = no.of nodes). Extra O(N) for storing the topological sorting. Total ~ O(3N).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\n\nclass Solution {\n    public boolean isPossible(int V, int[][] prerequisites) {\n        // Form a graph\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; V; i++) {\n            adj.add(new ArrayList&lt;&gt;());\n        }\n        int m = prerequisites.length;\n        for (int i = 0; i &lt; m; i++) {\n            adj.get(prerequisites[i][0]).add(prerequisites[i][1]);\n        }\n\n\n\n        int indegree[] = new int[V];\n        for (int i = 0; i &lt; V; i++) {\n            for (int it : adj.get(i)) {\n                indegree[it]++;\n            }\n        }\n\n\n        Queue&lt;Integer&gt; q = new LinkedList&lt;Integer&gt;();\n        for (int i = 0; i &lt; V; i++) {\n            if (indegree[i] == 0) {\n                q.add(i);\n            }\n        }\n\n\n        List&lt;Integer&gt; topo = new ArrayList&lt;Integer&gt;();\n        // o(v + e)\n        while (!q.isEmpty()) {\n            int node = q.peek();\n\n            q.remove();\n            topo.add(node);\n            // node is in your topo sort\n            // so please remove it from the indegree\n\n            for (int it : adj.get(node)) {\n                indegree[it]--;\n                if (indegree[it] == 0) q.add(it);\n            }\n        }\n\n\n        if (topo.size() == V) return true;\n        return false;\n\n    }\n\n}\n\npublic class tUf {\n    public static void main(String[] args) {\n        int N = 4;\n        int[][] prerequisites = new int[3][2];\n        prerequisites[0][0] = 1;\n        prerequisites[0][1] = 0;\n\n        prerequisites[1][0] = 2;\n        prerequisites[1][1] = 1;\n\n        prerequisites[2][0] = 3;\n        prerequisites[2][1] = 2;\n\n        Solution obj = new Solution();\n        boolean ans = obj.isPossible(N, prerequisites);\n        if (ans)\n            System.out.println(\"YES\");\n        else\n            System.out.println(\"NO\");\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> YES</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(V+E), where V = no. of nodes and E = no. of edges. This is a simple BFS algorithm.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N) + O(N) <strong>~ </strong>O(2N), O(N) for the indegree array, and O(N) for the queue data structure used in BFS(where N = no.of nodes). Extra O(N) for storing the topological sorting. Total ~ O(3N).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 81,
    "preview": "Problem Statement I (Course Schedule): There are a total of n tasks you have to pick, labeled from 0 to n-1. Some tasks may have prerequisites tasks, for example, to pick task 0 you have to first f..."
}