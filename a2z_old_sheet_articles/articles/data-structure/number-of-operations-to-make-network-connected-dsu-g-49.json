{
    "dislikes": 2,
    "video": "FYrl7iz9_ZU",
    "publishedOn": "Sun Mar 24 2024 22:11:49 GMT+0530 (India Standard Time)",
    "slug": "number-of-operations-to-make-network-connected-dsu-g-49",
    "aid": "2169",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/number-of-operations-to-make-network-connected",
    "title": "Number of Operations to Make Network Connected - DSU: G-49.",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 24,
    "category_tag": "data-structure",
    "preview": "Problem Statement: You are given a graph with n vertices and m edges. You can remove one edge from anywhere and add that edge between any two vertices in one operation. Find the minimum number of o...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> You are given a graph with n vertices and m edges. You can remove one edge from anywhere and add that edge between any two vertices in one operation. Find the minimum number of operations that will be required to make the graph connected. If it is not possible to make the graph connected, return -1.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-requisite: </strong><a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\">Disjoint Set data structure</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b> N = 4, M = 3, Edge[] =[ [0,  1], [ 0, 2], [1, 2]]\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-162736.png\" alt=\"\" class=\"wp-image-7085\"/></figure>\n<b>Result:</b> 1\n<b>Explanation:</b> We need a minimum of 1 operation to make the two components connected. We can remove the edge (1,2) and add the edge between node 2 and node 3 like the following:\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-162852.png\" alt=\"\" class=\"wp-image-7086\"/></figure>\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<pre>\n<b>Input Format:</b> N = 9, M = 8, Edge[] = [[0,1],[0,2],[0,3],[1,2],[2,3],[4,5],[5,6],[7,8]]\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163003.png\" alt=\"\" class=\"wp-image-7087\"/></figure>\n<b>Result:</b> 2\n<b>Explanation:</b> We need a minimum of 2 operations to make the two components connected. We can remove the edge (0,2) and add the edge between node 3 and node 4 and we can remove the edge (0,3) and add it between nodes 6 and 8 like the following:\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163101.png\" alt=\"\" class=\"wp-image-7088\"/></figure>\n</pre>\n<!-- /wp:html -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/connecting-the-graph/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=connecting-the-graph\"><em>Problem Link</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Before discussing the solution, let\u2019s understand the question. In the question, it is clearly stated that our objective is to make the given graph connected. Now, we can do this by just connecting the different components of a given graph with some edges like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7089,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163206.png\" alt=\"\" class=\"wp-image-7089\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>But according to the question, we cannot add random edges from outside rather we can remove any given edge and add that to a new position to fulfill the purpose. So, one of the correct ways to connect the above graph will be the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7090,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163310.png\" alt=\"\" class=\"wp-image-7090\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>There may be several other possible ways to make the graph connected. In this graph, We have removed the edge (0,2) and added it between node 3 and node 4 and we have also removed the edge (0,3) and added it between nodes 6 and 8 to make the components connected.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong><em>In order to add any edge to the desired position, we must take it out from somewhere inside the graph. We cannot add any edge randomly from outside. </em><strong><em>So, the intuition is to remove the required minimum number of edges and plant them somewhere in the graph so that the graph becomes connected.&nbsp;</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong><em>Observation 1: How can we connect components to make the graph connected?</em></strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>In order to connect two different components of a graph we need to connect any node of the first component to any node of the second component. For example, if we have a graph like the following we can connect them in several ways like connecting nodes 2 and 3 or connecting nodes 2 and 4, and so on.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7091,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163411.png\" alt=\"\" class=\"wp-image-7091\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Observation 2:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>From the method of connecting the components, discussed above, <strong><em>we can conclude that we need a minimum of nc-1 edges to make the graph connected if the graph contains nc number of different components.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7092,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163510.png\" alt=\"\" class=\"wp-image-7092\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>For example, the above graph has two different components and so to make it connected we need a minimum of 1 edge. <strong><em>Similarly, if a graph contains a single component we need 0 edges to make it connected. </em></strong>We need to remove the edges in such a way that the components remain connected even after removing those edges. We can assume these types of edges as <strong><em>extra-edges</em></strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7093,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-163558.png\" alt=\"\" class=\"wp-image-7093\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><em>Until now, we have found that we need a minimum of nc-1 edges (nc = no. of components of the graph) to make the graph connected. And according to the question, to add these nc-1 edges, the graph must contain a minimum of nc-1 extra edges.</em><strong><em>&nbsp;</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><em>So, we can conclude that if a graph contains nc-1 extra-edges, we can make the graph connected with just nc-1 operations(where nc = no. of components of the graph).</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In order to solve this question we will first find out the number of extra-edges and then we will find out the number of components of the graph. We will be using the <a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\">Disjoint Set data structure</a><strong> </strong>to do so.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First we need to extract all the edge information (<strong><em>If not already given</em></strong>) in the form of the pair (u, v) where u = starting node and v = ending node. We should store all the edge information in an array.</li><li>Then we will iterate through the array selecting every pair and checking the following:<ol><li><strong>If the ultimate parent of u and v(checked using the findPar() method of the Disjoint set) becomes the same</strong>,&nbsp; we should increase the count of extra-edges by 1.<br>Because the same ultimate parent means the nodes are already connected and so we can consider the current edge as an extra edge.</li><li>But if the ultimate parents are different, then we should apply the union(either unionBySize() or unionByRank()) method on those two nodes.</li></ol></li><li>Thus we will get the count of the extra edges. Now it\u2019s time to count the number of components. In order to do so, we will just count the number of the nodes that are the ultimate parent of themselves.</li><li>We will iterate over all the nodes and for each node, we will check the following:<ol><li>If the node is the ultimate parent of itself, we will increase the count of components by 1.</li><li>Otherwise, we will continue to the next node.</li></ol></li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><em>This checking will be done using the parent array inside the Disjoint set.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true,\"start\":5} -->\n<ol start=\"5\"><li>Finally, we will check the count of extra edges and the number of components. If the count of extra-edges is greater or the same, we will return the answer that is (number of components - 1), and otherwise, we will return -1.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n//User function Template for C++\nclass DisjointSet {\npublic:\n    vector&lt;int&gt; rank, parent, size;\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] &lt; rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] &lt; rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] &lt; size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\nclass Solution {\npublic:\n    int Solve(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edge) {\n        DisjointSet ds(n);\n        int cntExtras = 0;\n        for (auto it : edge) {\n            int u = it[0];\n            int v = it[1];\n            if (ds.findUPar(u) == ds.findUPar(v)) {\n                cntExtras++;\n            }\n            else {\n                ds.unionBySize(u, v);\n            }\n        }\n        int cntC = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (ds.parent[i] == i) cntC++;\n        }\n        int ans = cntC - 1;\n        if (cntExtras &gt;= ans) return ans;\n        return -1;\n    }\n};\n\nint main() {\n\n    int V = 9;\n    vector&lt;vector&lt;int&gt;&gt; edge = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {2, 3}, {4, 5}, {5, 6}, {7, 8}};\n\n    Solution obj;\n    int ans = obj.Solve(V, edge);\n    cout &lt;&lt; \"The number of operations needed: \" &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The number of operations needed: 2 (for example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(E*4\u03b1)+O(N*4\u03b1) where E = no. of edges and N = no. of nodes. The first term is to calculate the number of extra edges and the second term is to count the number of components. 4\u03b1 is for the disjoint set operation we have used and this term is so small that it can be considered constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2N) where N = no. of nodes. 2N for the two arrays(parent and size) of size N we have used inside the disjoint set.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\n\n\n\n\nclass DisjointSet {\n    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; size = new ArrayList&lt;&gt;();\n    public DisjointSet(int n) {\n        for (int i = 0; i &lt;= n; i++) {\n            rank.add(0);\n            parent.add(i);\n            size.add(1);\n        }\n    }\n\n    public int findUPar(int node) {\n        if (node == parent.get(node)) {\n            return node;\n        }\n        int ulp = findUPar(parent.get(node));\n        parent.set(node, ulp);\n        return parent.get(node);\n    }\n\n    public void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {\n            parent.set(ulp_v, ulp_u);\n        } else {\n            parent.set(ulp_v, ulp_u);\n            int rankU = rank.get(ulp_u);\n            rank.set(ulp_u, rankU + 1);\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size.get(ulp_u) &lt; size.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\n        } else {\n            parent.set(ulp_v, ulp_u);\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\n        }\n    }\n}\nclass Solution {\n\n    public int Solve(int n, int[][] edge) {\n        DisjointSet ds = new DisjointSet(n);\n        int cntExtras = 0;\n        int m = edge.length;\n        for (int i = 0; i &lt; m ; i++) {\n            int u = edge[i][0];\n            int v = edge[i][1];\n            if (ds.findUPar(u) == ds.findUPar(v)) {\n                cntExtras++;\n            } else {\n                ds.unionBySize(u, v);\n            }\n        }\n        int cntC = 0;\n        for (int i = 0; i &lt; n; i++) {\n            if (ds.parent.get(i) == i) cntC++;\n        }\n        int ans = cntC - 1;\n        if (cntExtras &gt;= ans) return ans;\n        return -1;\n    }\n}\n\n\nclass Main {\n    public static void main (String[] args) {\n        int V = 9;\n        int[][] edge = {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {2, 3}, {4, 5}, {5, 6}, {7, 8}};\n\n        Solution obj = new Solution();\n        int ans = obj.Solve(V, edge);\n        System.out.println(\"The number of operations needed: \" + ans);\n\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: The number of operations needed: 2 (for example 2)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(E*4\u03b1)+O(N*4\u03b1) where E = no. of edges and N = no. of nodes. The first term is to calculate the number of extra edges and the second term is to count the number of components. 4\u03b1 is for the disjoint set operation we have used and this term is so small that it can be considered constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(2N) where N = no. of nodes. 2N for the two arrays(parent and size) of size N we have used inside the disjoint set.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}