{
    "dislikes": 12,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:16 GMT+0530 (India Standard Time)",
    "slug": "zig-zag-traversal-of-binary-tree",
    "aid": "1437",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/zig-zag-or-spiral-traversal",
    "title": "Zig Zag Traversal Of Binary Tree",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "likes": 84,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given a Binary Tree, print the zigzag traversal of the Binary Tree. Zigzag traversal of a binary tree is a way of visiting the nodes of the tree in a zigzag pattern, alternating...",
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Tree, print the zigzag traversal of the Binary Tree.\nZigzag traversal of a binary tree is a way of visiting the nodes of the tree in a zigzag pattern, alternating between left-to-right and right-to-left at each level. \n</p>\n\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 3 4 5 -1 6\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image1-fkiEDFoN\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output:</strong> [[1],[3, 2],[4, 5, 6]]</span>\n\t\t\t\t<span><strong>Explanation: </strong><ol><li>Level 1 (Root): Visit the root node 1 from left to right. Zigzag Traversal: [1]</li><li>Level 2: Visit nodes at this level in a right-to-left order. Zigzag Traversal:  [1], [3, 2]</li><li>Level 3: Visit nodes at this level in a left-to-right order. Zigzag Traversal:  [1], [3, 2], [4, 5, 6]</li></ol></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image2-ATavNI7k\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Example 2:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 -1 4 5 -1 -1 7 8\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image3-hqVEj8-y\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output :</strong> [[1], [2], [4, 5], [8, 7]]</span>\n\t\t\t\t<span><strong>Explanation: </strong><ol><li>Level 1 (Root): Visit the root node 1 from left to right. Zigzag Traversal: [1]</li><li>Level 2: Visit nodes at this level in a right-to-left order. Zigzag Traversal:  [1], [2]</li><li>Level 3: Visit nodes at this level in a left-to-right order. Zigzag Traversal:  [1], [3, 2], [4, 5]</li><li>Level 4: Visit nodes at this level in a right-to-left order. Zigzag Traversal:  [1], [3, 2], [4, 5], [8, 7]</li></ol></span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image4-B908-MAE\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t\n            </pre>\n        </div>\n    </details>\n</div>\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/zigzag-binary-tree-traversal_920532?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\"\n                alt=\"code-studio\">\n        </a>\n    </div>\n    <!--<div class=\"problem-buttons\">\n         Add Problem Link inside href \n        <a href=\"\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp\"\n                alt=\"leetcode\">\n        </a>\n    </div>-->\n</div>\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\n        yourself first. </em></p>\n\n\n<div id=\"brute-force-approach\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Optimal Approach \n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                </path>\n            </svg>\n        </summary>\n        <div class=\"common-drops\">\n            <details class=\"secondary-details\" open=\"\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Algorithm / Intuition\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"approach-algorithm\">\n                    <!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n                    <p>Zigzag traversal is a modification of the traditional <a href=\"https://takeuforward.org/data-structure/level-order-traversal-of-a-binary-tree/\"> level order traversal </a> in a binary tree.\n                    Level Order Traversal explores does at each level from left or right but zigzag traversal adds a twist by alternating the direction of exploration.\n                    At odd levels, we proceed from left to right but for even levels the order is reversed, from right to left. This is achieved by introducing a `leftToRight` flag which controls the order in which nodes are processed at each level.\n                    When `leftToRight` is true, nodes are inserted into the level vector from left to right and when its false, nodes are inserted right to left. </p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image5-DZotXz_M\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    \n                    <p><strong>Algorithm:</strong></p>\n                    <p><strong>Step 1:</strong> Initialise an empty queue data structure to store the nodes during traversal. Create a 2D array or a vector of a vector to store the level order traversal. If the tree is empty, return this empty 2D vector.</p>\n                    \n                    <p><strong>Step 2:</strong> Create a `leftToRight` flag to keep track of the direction of traversal. When `leftToRight` is true, nodes are inserted into the level vector from left to right and when its false, nodes are inserted right to left. </p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image6-AX6DRDHO\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    \n                    <p><strong>Step 3:</strong> Enqueue the root node ie. Add the root node of the binary tree to the queue.</p>\n                    \n                    <p><strong>Step 4:</strong> Iterate until the queue is empty:\n                    <ol><li>Get the current size of the queue. This size indicates the number of nodes at the current level.</li><li>Create a vector \u2018level\u2019 to store the nodes at the current level.</li></ol></p>\n\n                    <p><strong>Step 5:</strong> Iterate through \u2018size\u2019 number of nodes at the current level:\n                    <ol><li>Pop the front node from the queue.</li><li>Store the node\u2019s value in the level vector. Determine the index to insert the node\u2019s value based on the traversal direction \u2018leftToRight\u2019.</li></ol>\n                \tIf \u2018leftToRight\u2019 is true, the index is set to \u2018i\u2019 which means the node\u2019s value will be inserted form left to right. If \u2018rightToLeft\u2019 is false, the index is set to size - 1 - i, meaning the node\u2019s value will be inserted from right to left. </p>\n                    <p><strong>Step 6:</strong> Enqueue the left and right child nodes of the current node (if they exist) into the queue. </p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/zig-zag-image7-sg6MxzsS\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p><strong>Step 7:</strong> After processing all the nodes at the current level, add the \u2018level\u2019 vector to the \u2018ans\u2019 2D vector, representing the current level.\n                    Reverse the direction of traversal for the next level by updating the \u2018leftToRight\u2019 flag to its opposite value. This toggling ensures that the nodes at the next level will be processed in the opposite direction, alternating between left-to-right and right-to-left.</p>\n                    \n                    <p><strong>Step 8:</strong> Once the traversal loop completes ie. all levels have been processed, return the \u2018ans\u2019 2D vector containing the level-order traversal.</p>\n                    \n                </div>\n            </details>\n            <details class=\"code-section secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Code\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"code-tabs\">\n                    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                    <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                        </path>\n                    </svg>\n                </div>\n                <div class=\"code-content\">\n                    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;climits&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to perform zigzag level\n    // order traversal of a binary tree\n    vector&lt;vector&lt;int&gt;&gt; ZigZagLevelOrder(Node* root){\n        // Vector to store the\n        // result of zigzag traversal\n        vector&lt;vector&lt;int&gt;&gt; result;\n        \n        // Check if the root is NULL,\n        // return an empty result\n        if(root == NULL){\n            return result;\n        }\n        \n        // Queue to perform\n        // level order traversal\n        queue&lt;Node*&gt; nodesQueue;\n        nodesQueue.push(root);\n        \n        // Flag to determine the direction of\n        // traversal (left to right or right to left)\n        bool leftToRight = true;\n        \n        // Continue traversal until\n        // the queue is empty\n        while(!nodesQueue.empty()){\n            // Get the number of nodes\n            // at the current level\n            int size = nodesQueue.size();\n            \n            // Vector to store the values\n            // of nodes at the current level\n            vector&lt;int&gt; row(size);\n            \n            // Traverse nodes at \n            // the current level\n            for(int i = 0; i &lt; size; i++){\n                // Get the front node\n                // from the queue\n                Node* node = nodesQueue.front();\n                nodesQueue.pop();\n                \n                // Determine the index to insert the node's\n                // value based on the traversal direction\n                int index = leftToRight ? i : (size - 1 - i);\n                \n                // Insert the node's value at\n                // the determined index\n                row[index] = node-&gt;data;\n                \n                // Enqueue the left and right\n                // children if they exist\n                if(node-&gt;left){\n                    nodesQueue.push(node-&gt;left);\n                }\n                if(node-&gt;right){\n                    nodesQueue.push(node-&gt;right);\n                }\n            }\n            \n            // Switch the traversal\n            // direction for the next level\n            leftToRight = !leftToRight;\n            \n            // Add the current level's\n            // values to the result vector\n            result.push_back(row);\n        }\n        \n        // Return the final result of\n        // zigzag level order traversal\n        return result;\n    }\n};\n\n\n\n// Helper function to print the result\nvoid printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; result) {\n    for (const auto&amp; row : result) {\n        for (int val : row) {\n            cout &lt;&lt; val &lt;&lt; &quot; &quot;;\n        }\n        cout &lt;&lt; endl;\n    }\n}\n\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;right = new Node(3);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(5);\n    root-&gt;right-&gt;left = new Node(6);\n    root-&gt;right-&gt;right = new Node(7);\n\n    Solution solution;\n\n    // Get the zigzag level order traversal\n    vector&lt;vector&lt;int&gt;&gt; result = solution.ZigZagLevelOrder(root);\n\n    // Print the result\n    printResult(result);\n\n    return 0;\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block \" data-lang=\"java\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"java\" class=\"language-java\">\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\n// Node structure for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    // Function to perform zigzag level\n    // order traversal of a binary tree\n    public List&lt;List&lt;Integer&gt;&gt; ZigZagLevelOrder(Node root) {\n        // List to store the\n        // result of zigzag traversal\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n\n        // Check if the root is null,\n        // return an empty result\n        if (root == null) {\n            return result;\n        }\n\n        // Queue to perform\n        // level order traversal\n        Queue&lt;Node&gt; nodesQueue = new LinkedList&lt;&gt;();\n        nodesQueue.add(root);\n\n        // Flag to determine the direction of\n        // traversal (left to right or right to left)\n        boolean leftToRight = true;\n\n        // Continue traversal until\n        // the queue is empty\n        while (!nodesQueue.isEmpty()) {\n            // Get the number of nodes\n            // at the current level\n            int size = nodesQueue.size();\n\n            // List to store the values\n            // of nodes at the current level\n            List&lt;Integer&gt; row = new ArrayList&lt;&gt;();\n\n            // Traverse nodes at \n            // the current level\n            for (int i = 0; i &lt; size; i++) {\n                // Get the front node\n                // from the queue\n                Node node = nodesQueue.poll();\n\n                // Determine the index to insert the node's\n                // value based on the traversal direction\n                int index = leftToRight ? i : (size - 1 - i);\n\n                // Insert the node's value at\n                // the determined index\n                row.add(index, node.data);\n\n                // Enqueue the left and right\n                // children if they exist\n                if (node.left != null) {\n                    nodesQueue.add(node.left);\n                }\n                if (node.right != null) {\n                    nodesQueue.add(node.right);\n                }\n            }\n\n            // Switch the traversal\n            // direction for the next level\n            leftToRight = !leftToRight;\n\n            // Add the current level's\n            // values to the result list\n            result.add(row);\n        }\n\n        // Return the final result of\n        // zigzag level order traversal\n        return result;\n    }\n}\n\n// Helper function to print the result\nclass Main {\n    static void printResult(List&lt;List&lt;Integer&gt;&gt; result) {\n        for (List&lt;Integer&gt; row : result) {\n            for (int val : row) {\n                System.out.print(val + &quot; &quot;);\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n\n        Solution solution = new Solution();\n\n        // Get the zigzag level order traversal\n        List&lt;List&lt;Integer&gt;&gt; result = solution.ZigZagLevelOrder(root);\n\n        // Print the result\n        printResult(result);\n    }\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"python\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"python\" class=\"language-python\">\nfrom collections import deque\n\n# Node class for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # Function to perform zigzag level order traversal of a binary tree\n    def ZigZagLevelOrder(self, root):\n        # List to store the result of zigzag traversal\n        result = []\n        \n        # Check if the root is None, return an empty result\n        if not root:\n            return result\n        \n        # Queue to perform level order traversal\n        nodesQueue = deque()\n        nodesQueue.append(root)\n        \n        # Flag to determine the direction of traversal (left to right or right to left)\n        leftToRight = True\n        \n        # Continue traversal until the queue is empty\n        while nodesQueue:\n            # Get the number of nodes at the current level\n            size = len(nodesQueue)\n            \n            # List to store the values of nodes at the current level\n            row = [0] * size\n            \n            # Traverse nodes at the current level\n            for i in range(size):\n                # Get the front node from the queue\n                node = nodesQueue.popleft()\n                \n                # Determine the index to insert the node's value based on the traversal direction\n                index = i if leftToRight else (size - 1 - i)\n                \n                # Insert the node's value at the determined index\n                row[index] = node.data\n                \n                # Enqueue the left and right children if they exist\n                if node.left:\n                    nodesQueue.append(node.left)\n                if node.right:\n                    nodesQueue.append(node.right)\n            \n            # Switch the traversal direction for the next level\n            leftToRight = not leftToRight\n            \n            # Add the current level's values to the result list\n            result.append(row)\n        \n        # Return the final result of zigzag level order traversal\n        return result\n\n# Helper function to print the result\ndef printResult(result):\n    for row in result:\n        for val in row:\n            print(val, end=&quot; &quot;)\n        print()\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n\nsolution = Solution()\n\n# Get the zigzag level order traversal\nresult = solution.ZigZagLevelOrder(root)\n\n# Print the result\nprintResult(result)\n                           </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node structure for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to perform zigzag level\n    // order traversal of a binary tree\n    ZigZagLevelOrder(root) {\n        // Array to store the\n        // result of zigzag traversal\n        const result = [];\n\n        // Check if the root is null,\n        // return an empty result\n        if (!root) {\n            return result;\n        }\n\n        // Queue to perform\n        // level order traversal\n        const nodesQueue = [];\n        nodesQueue.push(root);\n\n        // Flag to determine the direction of\n        // traversal (left to right or right to left)\n        let leftToRight = true;\n\n        // Continue traversal until\n        // the queue is empty\n        while (nodesQueue.length &gt; 0) {\n            // Get the number of nodes\n            // at the current level\n            const size = nodesQueue.length;\n\n            // Array to store the values\n            // of nodes at the current level\n            const row = Array(size);\n\n            // Traverse nodes at \n            // the current level\n            for (let i = 0; i &lt; size; i++) {\n                // Get the front node\n                // from the queue\n                const node = nodesQueue.shift();\n\n                // Determine the index to insert the node's\n                // value based on the traversal direction\n                const index = leftToRight ? i : (size - 1 - i);\n\n                // Insert the node's value at\n                // the determined index\n                row[index] = node.data;\n\n                // Enqueue the left and right\n                // children if they exist\n                if (node.left) {\n                    nodesQueue.push(node.left);\n                }\n                if (node.right) {\n                    nodesQueue.push(node.right);\n                }\n            }\n\n            // Switch the traversal\n            // direction for the next level\n            leftToRight = !leftToRight;\n\n            // Add the current level's\n            // values to the result array\n            result.push(row);\n        }\n\n        // Return the final result of\n        // zigzag level order traversal\n        return result;\n    }\n}\n\n// Helper function to print the result\nfunction printResult(result) {\n    for (const row of result) {\n        for (const val of row) {\n            process.stdout.write(val + &quot; &quot;);\n        }\n        console.log();\n    }\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.right = new Node(3);\nroot.left.left = new Node(4);\nroot.left.right = new Node(5);\nroot.right.left = new Node(6);\nroot.right.right = new Node(7);\n\nconst solution = new Solution();\n\n// Get the zigzag level order traversal\nconst result = solution.ZigZagLevelOrder(root);\n\n// Print the result\nprintResult(result);\n\n                            </code>\n                        </pre>\n                    </div>\n                    <p>\n                        <!-- Insert Output of Brute Force Here -->\n                       <strong>Output</strong> \n                      1 \n                      3 2\n                      4 5 6 7\n\n                    </p>\n                </div>\n            </details>\n            <details class=\"secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Complexity Analysis\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <p>\n                    <!-- Insert Time and Space Complexity  Here -->\n                    <p><strong>Time Complexity: O(N)</strong> where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.</p>\n\t\t\t\t\t<p><strong>Space Complexity: O(N)</strong> where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well. </p>\n\n                </p>\n            </details>\n        </div>\n    </details>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <!-- Insert iframe embed Link of Youtube Video-->\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/3OXWEdlIGl4?si=MOAIcg0Wj9UYU0Fl\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n        </div>\n    </details>\n</div>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}