{
    "dislikes": 5,
    "video": "ZmlQ3vgAOMo",
    "publishedOn": "Sun Mar 24 2024 22:10:39 GMT+0530 (India Standard Time)",
    "slug": "wildcard-matching-dp-34",
    "aid": "1840",
    "title": "Wildcard Matching | (DP-34)",
    "tuf_plus": "",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        },
        {
            "topic-id": "string",
            "topic-title": "String"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:&nbsp;</strong>Wildcard Matching</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given two strings \u2018S1\u2019 and \u2018S2\u2019. String S1 can have the following two special characters:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>\u2018?\u2019 can be matched to a single character of S2.</li><li>\u2018*\u2019 can be matched to any sequence of characters of S2. (sequence can be of length zero or more).</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>We need to check whether strings S1 and S2 match or not.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example:</strong>\n\n<img width=\"624\" height=\"391\" src=\"https://lh6.googleusercontent.com/zR799fMPurVRIqbURhPX34iIwt7qov7AcczQnqMUfFIywmegsFWSSUg4hbhiVhBa1P6nJ_bM_ssJnm3rmomKuuiUfwhaOe2AqCKvpvoMFTUZ_Vl7sC73-zgrergtC8neAQ4_zfdp\"></pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/wildcard-pattern-matching_701650?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nMemoization approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nTabulation approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nSpace Optimization\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemoization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<h3><strong>Intuition:&nbsp;</strong></h3>\n<p>For every index of string S1, we have different options to match that index with string S2. Therefore, we can think in terms of string matching path as we have done already in previous questions.</p>\n<ul><li>Either the characters match already.</li><li>Or, if there is a \u2018?\u2019, we can explicitly match a single character.</li><li>For a \u2018*\u2019, the following figure explains the scenario.</li></ul>\n<p><img width=\"594\" height=\"324\" src=\"https://lh6.googleusercontent.com/kGVbRjbBazvmgUW4ts7CwAFucszjnw5NLrN2P7V3T8v3j3ULalNaKXY7Cx0lNKOTJB2q2aTUH33TrF75C4R9aCAWGTd5RNQZRm2vIzE4nqZWdUVHBiHAYmaUkjfItqzYPBaAb2EN\"></p>\n<p>As there is no uniformity in data, there is no other way to find out than to <strong>try out all possible ways</strong>. To do so we will need to use <strong>recursion</strong>.</p>\n<p><strong>Steps to form the recursive solution:&nbsp;</strong></p>\n<p>We will first form the recursive solution by the three points mentioned in the <a href=\"https://takeuforward.org/data-structure/dynamic-programming-introduction/\" target=\"_blank\" rel=\"noreferrer noopener\">Dynamic Programming Introduction</a>.&nbsp;</p>\n<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>\n<p>We are given two strings. We can represent them with the help of two indexes i and j. Initially, i=n-1 and j=m-1, where n and m are lengths of strings S1 and S2. Initially, we will call f(n-1,m-1), which means whether string S1[0\u2026n-1] matches with string S2[0\u2026m-1].</p>\n<p>We can generalize this as follows:</p>\n<p><img width=\"624\" height=\"75\" src=\"https://lh6.googleusercontent.com/01N-aEZdemVfox62tFIuacaXzSgTysfhxDXrO-zVCaSsstb6avFu6FklVaSz6zwHctSHdVRe8CdjtCg0TotD6inTK7rBY5b1Md_9X-PGqWxzkrMo57VN3_smi63sOLB3oM3xrAK3\"></p>\n<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>\n<p>Now, i and j represent two characters from strings S1 and S2 respectively. There are only two options that make sense: either the characters represented by i and j match or they don\u2019t.</p>\n<p><strong>(i) When the characters match</strong></p>\n<p><strong>if(S1[i]==S2[j])</strong>,&nbsp;</p>\n<p>If this is true, the characters at i and j match, we can simply move to the next characters of both the strings. So we will just decrement both i and j by 1 and recursively find the answer for the remaining string portions. We return<strong> f(i-1,j-1)</strong>. The following figure makes it clear.</p>\n<p><img width=\"165\" height=\"398\" src=\"https://lh6.googleusercontent.com/r3f3s7LxtiiA0kOH1RzPd_uo8O93UvCojS-KMziK8ekDbxl9VowN-VXa3mP5mERDz7PH98wJwQ9YyxizKvlWV53bQtnxLBDW61TAq-1km2STVGdJmuAEWddOfyujmBNicqTT3c9U\"></p>\n<p><strong>(ii) When the characters don\u2019t match</strong></p>\n<p>If the characters don\u2019t match, there are three possible scenarios:</p>\n<ol><li><strong>S1[i] == \u2018?\u2019</strong></li><li><strong>S1[i] == \u2018*\u2019</strong></li><li><strong>S1[i] is some other character</strong></li></ol>\n<p>Let us discuss them one by one:</p>\n<p><strong>(i) If S1[i] == \u2018?\u2019</strong></p>\n<p>In this case, we can explicitly match \u2018?\u2019 at index i of S1 with the corresponding character at index j of S2. And then recursively call <strong>f(i-1,j-1)</strong> to check for the remaining string.</p>\n<p><strong>(ii) If S1[i] == \u2018*\u2019</strong></p>\n<p>This is an interesting case as now \u2018*\u2019 can be replaced with any sequence of characters( of length 0 or more) from S2.</p>\n<p>We will revisit this example:</p>\n<p><img width=\"624\" height=\"347\" src=\"https://lh4.googleusercontent.com/FGrJwKsUL-SPEoHZf0pVL__IDZu93Gvh9OfUyi15yeVIBTkRZioOv1n3X6PXDybuh0swp_jDgIQJF866VAUI0Eov5Qd3tHypBGv6eW2ewp9gj2tWgVUSxgbWh6TSJDb3K930QfFv\"></p>\n<p>If any of these cases return true, we can say that the characters do match. The next question is <strong>how to try all possible ways</strong>?</p>\n<p>We are using two pointers i and j to represent characters of strings S1 and S2. We can surely write a for loop to compare characters from 0 to j of S2 for the above scenario. <strong>Can we do it more smartly? </strong>Yes, we can. Please understand the approach explained below.</p>\n<p>We are using a recursive function f(i,j). If we do only the following two recursive calls:</p>\n<ul><li>Call <strong>f(i-1,j)</strong>. i.e <strong>replace \u2018*\u2019 with nothing </strong>and act as if it was not present.</li><li>Call <strong>f(i,j-1)</strong>. i.e <strong>replace \u2018*\u2019 with a single character</strong> at index j and make the i pointer to still point at index i. In this, we matched it with a single character (one of the many options that need to be tried) and in the next recursive call, as i still point to \u2018*\u2019, we get the exact two recursive calls again.</li></ul>\n<p>The following recursive tree will help us to understand the recursion better.</p>\n<p><img width=\"677\" height=\"490\" src=\"https://lh6.googleusercontent.com/Byl_svgs9_LoX5OqEgW866sE5Thljle0m07Vv2G6MAplEhjTauie6YDmz-H6hBHru_jiVgXI94z9euGegMBRwpX1CCiPHxDLIU5DchP049LFD4SAv-NcNH9lfjRQTdOlyKy71nQM\"></p>\n<p>So we see how we can tackle all the required cases associated with \u2018*\u2019 by using recursion.</p>\n<p><strong>(iii) If S1[i] is neither \u2018?\u2019 nor \u2018*\u2019</strong>, then we can say as the characters at i and j don\u2019t match then the strings don\u2019t match, so we return false.</p>\n<p>To summarise:</p>\n<ol><li>If S1[i] == \u2018?\u2019, return <strong>f(i-1,j)</strong></li><li>Else if S1[i] == \u2018*\u2019, return <strong>f(i-1,j) || f(i,j-1)</strong></li><li>Else return <strong>false</strong></li></ol>\n<p><strong>Step 3: Return logical OR (||) of all the choices</strong></p>\n<p>If any of the cases return true, we can say that strings do match. We can use OR operator (||) with the recursive calls.</p>\n<p><strong>Base Cases:</strong></p>\n<p>We are reducing i and j in our recursive relation, there can be two possibilities, either i becomes -1 or j becomes -1., i,e we exhaust either S1 or S2 respectively.</p>\n<p><strong>(i) When S1 is exhausted:</strong></p>\n<p>When S1 is exhausted (i&lt;0), we know that in order for the strings to match, String S2 should also exhaust simultaneously. If it does, we return true, else we return false.</p>\n<p>We can say:</p>\n<ul><li>if(i&lt;0 &amp;&amp; j&lt;0), return true.</li><li>if(i&lt;0 &amp;&amp; j&gt;=0), return false.</li></ul>\n<p>(ii) When S2 is exhausted:</p>\n<p>When S2 is exhausted(j&lt;0) and S1 has not, there is only one pattern that can account for true(matching of strings). It is if S1 is like this \u201c*\u201d,\u201d****\u201d,\u201d***\u201d, i.e: S1 contains only stars. Then we can replace every star with a sequence of length 0 and say that the string match.</p>\n<p>If S1 is all-stars, we return true, else return false.</p>\n<p>The final pseudocode after steps 1, 2, and 3:</p>\n<p><img width=\"514\" height=\"594\" src=\"https://lh4.googleusercontent.com/L3h3Wo4Da62FEk-3w0yGG6yWPUyMu01keh7b8OFaKlFspZJVyeN6Oy-PnZyl3sp-OxqPC6BpQdiRauRDPZyRO_ZhAjl2xCsFd4AnftWT0cEjC4Cj0BnYY2MQKtLVMYuXWK8-iFCS\"></p>\n<p><strong>Steps to memoize a recursive solution:</strong></p>\n<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>\n<ol><li>Create a dp array of size [n][m]. The size of S1 and S2 are n and m respectively, so the variable i will always lie between \u20180\u2019 and \u2018n-1\u2019 and the variable j between \u20180\u2019 and \u2018m-1\u2019.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li></ol>\n<!-- /wp:list -->\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring of S1 contains only '*'\nbool isAllStars(string &amp;S1, int i) {\n    for (int j = 0; j &lt;= i; j++) {\n        if (S1[j] != '*')\n            return false;\n    }\n    return true;\n}\n\n// Function to check if S1 matches S2 using wildcard pattern matching\nbool wildcardMatchingUtil(string &amp;S1, string &amp;S2, int i, int j, vector&lt;vector&lt;bool>> &amp;dp) {\n    // Base Cases\n    if (i &lt; 0 &amp;&amp; j &lt; 0)\n        return true;\n    if (i &lt; 0 &amp;&amp; j >= 0)\n        return false;\n    if (j &lt; 0 &amp;&amp; i >= 0)\n        return isAllStars(S1, i);\n\n    // If the result for this state has already been calculated, return it\n    if (dp[i][j] != -1)\n        return dp[i][j];\n\n    // If the characters at the current positions match or S1 has a '?'\n    if (S1[i] == S2[j] || S1[i] == '?')\n        return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);\n    else {\n        if (S1[i] == '*')\n            // Two options: either '*' represents an empty string or it matches a character in S2\n            return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) || wildcardMatchingUtil(S1, S2, i, j - 1, dp);\n        else\n            return false;\n    }\n}\n\n// Main function to check if S1 matches S2 using wildcard pattern matching\nbool wildcardMatching(string &amp;S1, string &amp;S2) {\n    int n = S1.size();\n    int m = S2.size();\n\n    // Create a DP table to memoize results\n    vector&lt;vector&lt;bool>> dp(n, vector&lt;bool>(m, -1));\n    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);\n}\n\nint main() {\n    string S1 = \"ab*cd\";\n    string S2 = \"abdefcd\";\n\n    // Call the wildcardMatching function and print the result\n    if (wildcardMatching(S1, S2))\n        cout &lt;&lt; \"String S1 and S2 do match\";\n    else\n        cout &lt;&lt; \"String S1 and S2 do not match\";\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Helper function to check if all characters from index 0 to i in S1 are '*'\n  static boolean isAllStars(String S1, int i) {\n    for (int j = 0; j &lt;= i; j++) {\n      if (S1.charAt(j) != '*')\n        return false;\n    }\n    return true;\n  }\n\n  // Recursive function to perform wildcard pattern matching\n  static int wildcardMatchingUtil(String S1, String S2, int i, int j, int[][] dp) {\n    // Base Cases\n    if (i &lt; 0 &amp;&amp; j &lt; 0)\n      return 1; // Both strings are empty, and the pattern matches.\n    if (i &lt; 0 &amp;&amp; j >= 0)\n      return 0; // S1 is empty, but there are characters left in S2.\n    if (j &lt; 0 &amp;&amp; i >= 0)\n      return isAllStars(S1, i) ? 1 : 0; // S2 is empty, check if remaining characters in S1 are all '*'.\n\n    // If the result is already computed, return it.\n    if (dp[i][j] != -1) return dp[i][j];\n\n    // If the characters match or S1 has a '?', continue matching the rest of the strings.\n    if (S1.charAt(i) == S2.charAt(j) || S1.charAt(i) == '?')\n      return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);\n\n    else {\n      if (S1.charAt(i) == '*') {\n        // Two possibilities when encountering '*':\n        // 1. '*' matches one or more characters in S2.\n        // 2. '*' matches zero characters in S2.\n        return dp[i][j] = (wildcardMatchingUtil(S1, S2, i - 1, j, dp) == 1 || wildcardMatchingUtil(S1, S2, i, j - 1, dp) == 1) ? 1 : 0;\n      } else {\n        // Characters don't match, and S1[i] is not '*'.\n        return 0;\n      }\n    }\n  }\n\n  // Main function to check if S1 matches the wildcard pattern S2\n  static int wildcardMatching(String S1, String S2) {\n    int n = S1.length();\n    int m = S2.length();\n\n    int dp[][] = new int[n][m];\n    for (int row[]: dp)\n      Arrays.fill(row, -1);\n\n    // Call the recursive helper function\n    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);\n  }\n\n  public static void main(String args[]) {\n    String S1 = \"ab*cd\";\n    String S2 = \"abdefcd\";\n\n    if (wildcardMatching(S1, S2) == 1)\n      System.out.println(\"String S1 and S2 do match\");\n    else\n      System.out.println(\"String S1 and S2 do not match\");\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef isAllStars(S1, i):\n    # Helper function to check if all characters up to index i in S1 are '*'\n    for j in range(i + 1):\n        if S1[j] != '*':\n            return False\n    return True\n\ndef wildcardMatchingUtil(S1, S2, i, j, dp):\n    # Base conditions\n    if i &lt; 0 and j &lt; 0:\n        return True\n    if i &lt; 0 and j >= 0:\n        return False\n    if j &lt; 0 and i >= 0:\n        return isAllStars(S1, i)\n\n    # If the result for this subproblem is already computed, return it\n    if dp[i][j] != -1:\n        return dp[i][j]\n\n    if S1[i] == S2[j] or S1[i] == '?':\n        # Characters match or S1 has a '?'; move to the previous characters in both strings\n        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp)\n    elif S1[i] == '*':\n        # If S1 has a '*', there are two choices:\n        # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).\n        # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).\n        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) or wildcardMatchingUtil(S1, S2, i, j - 1, dp)\n    else:\n        dp[i][j] = False  # Characters don't match, and S1[i] is not '*'\n\n    return dp[i][j]\n\ndef wildcardMatching(S1, S2):\n    n = len(S1)\n    m = len(S2)\n\n    # Initialize a 2D DP array with -1 values\n    dp = [[-1 for _ in range(m)] for _ in range(n)]\n\n    # Calculate and return the result of wildcard matching\n    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp)\n\ndef main():\n    S1 = \"ab*cd\"\n    S2 = \"abdefcd\"\n\n    if wildcardMatching(S1, S2):\n        print(\"String S1 and S2 do match\")\n    else:\n        print(\"String S1 and S2 do not match\")\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction isAllStars(S1, i) {\n    for (let j = 0; j &lt;= i; j++) {\n        if (S1[j] !== '*') {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to perform wildcard pattern matching\nfunction wildcardMatchingUtil(S1, S2, i, j, dp) {\n    // Base Conditions\n    if (i &lt; 0 &amp;&amp; j &lt; 0) {\n        return true;\n    }\n    if (i &lt; 0 &amp;&amp; j >= 0) {\n        return false;\n    }\n    if (j &lt; 0 &amp;&amp; i >= 0) {\n        return isAllStars(S1, i);\n    }\n\n    // Check if the result for the current indices is already calculated\n    if (dp[i][j] !== -1) {\n        return dp[i][j];\n    }\n\n    if (S1[i] === S2[j] || S1[i] === '?') {\n        return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);\n    } else {\n        if (S1[i] === '*') {\n            return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) || wildcardMatchingUtil(S1, S2, i, j - 1, dp);\n        } else {\n            return false;\n        }\n    }\n}\n\n// Function to perform wildcard pattern matching\nfunction wildcardMatching(S1, S2) {\n    const n = S1.length;\n    const m = S2.length;\n\n    // Create a 2D array to store dynamic programming values\n    const dp = new Array(n).fill(null).map(() => new Array(m).fill(-1));\n\n    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);\n}\n\n// Main function\nfunction main() {\n    const S1 = \"ab*cd\";\n    const S2 = \"abdefcd\";\n\n    // Check if S1 matches S2 using wildcard matching\n    if (wildcardMatching(S1, S2)) {\n        console.log(\"String S1 and S2 do match\");\n    } else {\n        console.log(\"String S1 and S2 do not match\");\n    }\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Brute Force Here -->\n<p><strong>Output:</strong> String S1 and S2 do match\n\n\n</p>\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are N*M states therefore at max \u2018N*M\u2019 new problems will be solved.</p>\n<p><strong>Space Complexity: O(N*M) + O(N+M)</strong></p>\n<p>Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<p>In the recursive logic, we set the base case too if(i&lt;0 ) and if(j&lt;0) but we can\u2019t set the dp array\u2019s index to -1. Therefore a hack for this issue is to shift every index by 1 towards the right.</p>\n<p><img width=\"454\" height=\"109\" src=\"https://lh4.googleusercontent.com/Ua6nO0RW4Vy9qZqKfdX06JTdmUQNUoBBXUiatVp3yUAp_85JARJKfDgEE8aEXRmw8Ed9Fov5tVFHpui8iLMO-3_U0b4T6S_vtvF3oc8Fx0QmL3j2ksMkncanNJjgGOkEkasLwgbw\"></p>\n<ul><li>First we initialise the dp array of size [n+1][m+1] as zero.</li><li>Next, we set the base condition (keep in mind 1-based indexing), we set the top-left cell as \u2018true\u2019, then we set the first column\u2019s value as \u2018false\u2019; and for the first row, we will run isAllStars() for every cell value.</li><li>Similarly, we will implement the recursive code by keeping in mind the shifting of indexes, therefore S1[i] will be converted to S1[i-1]. Same for S2.</li><li>At last we will print dp[n][m] as our answer.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring of S1 contains only '*'\nbool isAllStars(string &amp;S1, int i) {\n    // S1 is taken in 1-based indexing\n    for (int j = 1; j &lt;= i; j++) {\n        if (S1[j - 1] != '*')\n            return false;\n    }\n    return true;\n}\n\n// Function to perform wildcard pattern matching between S1 and S2\nbool wildcardMatching(string &amp;S1, string &amp;S2) {\n    int n = S1.size();\n    int m = S2.size();\n\n    // Create a DP table to memoize results\n    vector&lt;vector&lt;bool>> dp(n + 1, vector&lt;bool>(m, false));\n\n    // Initialize the first row and column\n    dp[0][0] = true;\n    for (int j = 1; j &lt;= m; j++) {\n        dp[0][j] = false;\n    }\n    for (int i = 1; i &lt;= n; i++) {\n        dp[i][0] = isAllStars(S1, i);\n    }\n\n    // Fill in the DP table\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                if (S1[i - 1] == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n    }\n\n    // The value at dp[n][m] contains whether S1 matches S2\n    return dp[n][m];\n}\n\nint main() {\n    string S1 = \"ab*cd\";\n    string S2 = \"abdefcd\";\n\n    // Call the wildcardMatching function and print the result\n    if (wildcardMatching(S1, S2))\n        cout &lt;&lt; \"String S1 and S2 do match\";\n    else\n        cout &lt;&lt; \"String S1 and S2 do not match\";\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Helper function to check if all characters from index 1 to i in S1 are '*'\n  static boolean isAllStars(String S1, int i) {\n    for (int j = 1; j &lt;= i; j++) {\n      if (S1.charAt(j - 1) != '*')\n        return false;\n    }\n    return true;\n  }\n\n  // Function to perform wildcard pattern matching\n  static boolean wildcardMatching(String S1, String S2) {\n    int n = S1.length();\n    int m = S2.length();\n\n    // Create a 2D array to store the matching results\n    boolean dp[][] = new boolean[n + 1][m + 1];\n    dp[0][0] = true;\n\n    // Initialize the first row and column based on wildcard '*' in S1\n    for (int j = 1; j &lt;= m; j++) {\n      dp[0][j] = false;\n    }\n    for (int i = 1; i &lt;= n; i++) {\n      dp[i][0] = isAllStars(S1, i);\n    }\n\n    // Fill the dp array using a bottom-up approach\n    for (int i = 1; i &lt;= n; i++) {\n      for (int j = 1; j &lt;= m; j++) {\n        if (S1.charAt(i - 1) == S2.charAt(j - 1) || S1.charAt(i - 1) == '?') {\n          dp[i][j] = dp[i - 1][j - 1]; // Characters match or '?' is encountered.\n        } else {\n          if (S1.charAt(i - 1) == '*') {\n            dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; // '*' matches one or more characters.\n          } else {\n            dp[i][j] = false; // Characters don't match, and S1[i-1] is not '*'.\n          }\n        }\n      }\n    }\n\n    return dp[n][m]; // The final result indicates whether S1 matches S2.\n  }\n\n  public static void main(String args[]) {\n    String S1 = \"ab*cd\";\n    String S2 = \"abdefcd\";\n\n    if (wildcardMatching(S1, S2)) {\n      System.out.println(\"String S1 and S2 do match\");\n    } else {\n      System.out.println(\"String S1 and S2 do not match\");\n    }\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef isAllStars(S1, i):\n    # Helper function to check if all characters up to index i in S1 are '*'\n    for j in range(1, i + 1):\n        if S1[j - 1] != '*':\n            return False\n    return True\n\ndef wildcardMatching(S1, S2):\n    n = len(S1)\n    m = len(S2)\n\n    # Initialize a 2D DP array dp with dimensions (n+1) x m and fill it with False values\n    dp = [[False for _ in range(m)] for _ in range(n + 1)]\n\n    # Initialize dp[0][0] to True since two empty strings match\n    dp[0][0] = True\n\n    # Initialize the first row of dp\n    for j in range(1, m):\n        dp[0][j] = False\n\n    # Initialize the first column of dp based on whether S1 consists of all '*' characters up to that position\n    for i in range(1, n + 1):\n        dp[i][0] = isAllStars(S1, i)\n\n    # Fill in the DP array using dynamic programming\n    for i in range(1, n + 1):\n        for j in range(1, m):\n            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':\n                # Characters match or S1 has a '?'; continue matching with the previous characters\n                dp[i][j] = dp[i - 1][j - 1]\n            elif S1[i - 1] == '*':\n                # If S1 has a '*', there are two choices:\n                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).\n                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).\n                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\n            else:\n                dp[i][j] = False  # Characters don't match, and S1[i-1] is not '*'\n\n    # The final value in dp[n][m-1] is True if the two strings match, False otherwise\n    return dp[n][m-1]\n\ndef main():\n    S1 = \"ab*cd\"\n    S2 = \"abdefcd\"\n\n    if wildcardMatching(S1, S2):\n        print(\"String S1 and S2 do match\")\n    else:\n        print(\"String S1 and S2 do not match\")\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction isAllStars(S1, i) {\n    // S1 is taken in 1-based indexing\n    for (let j = 1; j &lt;= i; j++) {\n        if (S1[j - 1] !== '*') {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to perform wildcard pattern matching\nfunction wildcardMatching(S1, S2) {\n    const n = S1.length;\n    const m = S2.length;\n\n    // Create a 2D array to store dynamic programming values\n    const dp = new Array(n + 1).fill(null).map(() => new Array(m + 1).fill(false));\n\n    dp[0][0] = true;\n\n    for (let j = 1; j &lt;= m; j++) {\n        dp[0][j] = false;\n    }\n\n    for (let i = 1; i &lt;= n; i++) {\n        dp[i][0] = isAllStars(S1, i);\n    }\n\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (S1[i - 1] === S2[j - 1] || S1[i - 1] === '?') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                if (S1[i - 1] === '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\n// Main function\nfunction main() {\n    const S1 = \"ab*cd\";\n    const S2 = \"abdefcd\";\n\n    // Check if S1 matches S2 using wildcard matching\n    if (wildcardMatching(S1, S2)) {\n        console.log(\"String S1 and S2 do match\");\n    } else {\n        console.log(\"String S1 and S2 do not match\");\n    }\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\n<strong>Output:</strong> String S1 and S2 do match\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are two nested loops</p>\n<p><strong>Space Complexity: O(N*M)</strong></p>\n<p>Reason: We are using an external array of size \u2018N*M\u2019. Stack Space is eliminated.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nSpace Optimization Approach \n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Better Approach Here -->\n<p>If we closely look the relation,</p>\n<p><strong>dp[i][j] =&nbsp; dp[i-1][j-1], dp[i][j] = dp[i-1][j] ||dp[i][j-1]&nbsp;</strong></p>\n<p>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev) and current row\u2019s previous columns values. So, we don\u2019t need to store an entire array. Hence we can space optimise it.</p>\n<p><strong>Approach:</strong></p>\n<p>We will space optimize in the following way:</p>\n<ul><li>We take two rows \u2018prev\u2019 and \u2018cur\u2019.</li><li>We initialize it to the base condition. We first initialize the prev row. Its first value needs to be true. Rest all the values of the prev row meeds to be false.</li><li>Moreover, the cur variable whenever declared should have its first cell\u2019s value given by isAllStarts() function.</li><li>Next, we implement the memoization logic. We replace dp[i-1] with prev and dp[i] by cur.</li><li>After every inner loop execution, we set prev=cur, for the next iteration.</li><li>At last, we return prev[m] as our answer.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\n// Function to check if a substring of S1 contains only '*'\nbool isAllStars(string &amp;S1, int i) {\n    // S1 is taken in 1-based indexing\n    for (int j = 1; j &lt;= i; j++) {\n        if (S1[j - 1] != '*')\n            return false;\n    }\n    return true;\n}\n\n// Function to perform wildcard pattern matching between S1 and S2\nbool wildcardMatching(string &amp;S1, string &amp;S2) {\n    int n = S1.size();\n    int m = S2.size();\n\n    // Create two arrays to store previous and current rows of matching results\n    vector&lt;bool> prev(m + 1, false);\n    vector&lt;bool> cur(m + 1, false);\n\n    prev[0] = true; // Initialize the first element of the previous row to true\n\n    for (int i = 1; i &lt;= n; i++) {\n        cur[0] = isAllStars(S1, i); // Initialize the first element of the current row\n        for (int j = 1; j &lt;= m; j++) {\n            if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {\n                cur[j] = prev[j - 1]; // Characters match or S1 has '?'\n            } else {\n                if (S1[i - 1] == '*') {\n                    cur[j] = prev[j] || cur[j - 1]; // '*' represents empty or a character\n                } else {\n                    cur[j] = false; // Characters don't match and S1[i-1] is not '*'\n                }\n            }\n        }\n        prev = cur; // Update the previous row with the current row\n    }\n\n    // The value at prev[m] contains whether S1 matches S2\n    return prev[m];\n}\n\nint main() {\n    string S1 = \"ab*cd\";\n    string S2 = \"abdefcd\";\n\n    // Call the wildcardMatching function and print the result\n    if (wildcardMatching(S1, S2))\n        cout &lt;&lt; \"String S1 and S2 do match\";\n    else\n        cout &lt;&lt; \"String S1 and S2 do not match\";\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n  // Helper function to check if all characters from index 1 to i in S1 are '*'\n  static boolean isAllStars(String S1, int i) {\n    for (int j = 1; j &lt;= i; j++) {\n      if (S1.charAt(j - 1) != '*')\n        return false;\n    }\n    return true;\n  }\n\n  // Function to perform wildcard pattern matching\n  static boolean wildcardMatching(String S1, String S2) {\n    int n = S1.length();\n    int m = S2.length();\n\n    // Create two boolean arrays to store the matching results for the current and previous rows\n    boolean[] prev = new boolean[m + 1];\n    boolean[] cur = new boolean[m + 1];\n\n    // Initialize the first element of prev as true\n    prev[0] = true;\n\n    // Iterate through S1 and S2 to fill the cur array\n    for (int i = 1; i &lt;= n; i++) {\n      // Initialize the first element of cur based on whether S1 contains '*'\n      cur[0] = isAllStars(S1, i);\n      for (int j = 1; j &lt;= m; j++) {\n        if (S1.charAt(i - 1) == S2.charAt(j - 1) || S1.charAt(i - 1) == '?') {\n          cur[j] = prev[j - 1]; // Characters match or '?' is encountered.\n        } else {\n          if (S1.charAt(i - 1) == '*') {\n            cur[j] = prev[j] || cur[j - 1]; // '*' matches one or more characters.\n          } else {\n            cur[j] = false; // Characters don't match, and S1[i-1] is not '*'.\n          }\n        }\n      }\n      // Update prev array to store the current values\n      prev = cur.clone();\n    }\n\n    return prev[m]; // The final result indicates whether S1 matches S2.\n  }\n\n  public static void main(String args[]) {\n    String S1 = \"ab*cd\";\n    String S2 = \"abdefcd\";\n\n    if (wildcardMatching(S1, S2)) {\n      System.out.println(\"String S1 and S2 do match\");\n    } else {\n      System.out.println(\"String S1 and S2 do not match\");\n    }\n  }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\ndef isAllStars(S1, i):\n    # Helper function to check if all characters up to index i in S1 are '*'\n    for j in range(1, i + 1):\n        if S1[j - 1] != '*':\n            return False\n    return True\n\ndef wildcardMatching(S1, S2):\n    n = len(S1)\n    m = len(S2)\n\n    # Initialize two lists, prev and cur, to store the previous and current rows of the DP array\n    prev = [False for _ in range(m + 1)]\n    cur = [False for _ in range(m + 1)]\n\n    prev[0] = True  # Initialize the first element of prev to True\n\n    for i in range(1, n + 1):\n        cur[0] = isAllStars(S1, i)  # Initialize the first element of cur based on '*' characters in S1\n        for j in range(1, m + 1):\n\n            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':\n                # Characters match or S1 has a '?'; continue matching with the previous characters\n                cur[j] = prev[j - 1]\n            elif S1[i - 1] == '*':\n                # If S1 has a '*', there are two choices:\n                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).\n                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).\n                cur[j] = prev[j] or cur[j - 1]\n            else:\n                cur[j] = False  # Characters don't match, and S1[i-1] is not '*'\n\n        prev = cur  # Update prev to be the current row\n\n    # The final value in prev[m] is True if the two strings match, False otherwise\n    return prev[m]\n\ndef main():\n    S1 = \"ab*cd\"\n    S2 = \"abdefcd\"\n\n    if wildcardMatching(S1, S2):\n        print(\"String S1 and S2 do match\")\n    else:\n        print(\"String S1 and S2 do not match\")\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nfunction isAllStars(S1, i) {\n    // S1 is taken in 1-based indexing\n    for (let j = 1; j &lt;= i; j++) {\n        if (S1[j - 1] !== '*') {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to perform wildcard pattern matching\nfunction wildcardMatching(S1, S2) {\n    const n = S1.length;\n    const m = S2.length;\n\n    // Create two arrays, prev and cur, to store dynamic programming values\n    const prev = new Array(m + 1).fill(false);\n    const cur = new Array(m + 1).fill(false);\n\n    prev[0] = true;\n\n    for (let i = 1; i &lt;= n; i++) {\n        cur[0] = isAllStars(S1, i);\n        for (let j = 1; j &lt;= m; j++) {\n            if (S1[i - 1] === S2[j - 1] || S1[i - 1] === '?') {\n                cur[j] = prev[j - 1];\n            } else {\n                if (S1[i - 1] === '*') {\n                    cur[j] = prev[j] || cur[j - 1];\n                } else {\n                    cur[j] = false;\n                }\n            }\n        }\n        // Update the prev array with the values from the cur array for the next iteration\n        for (let j = 0; j &lt;= m; j++) {\n            prev[j] = cur[j];\n        }\n    }\n\n    return prev[m];\n}\n\n// Main function\nfunction main() {\n    const S1 = \"ab*cd\";\n    const S2 = \"abdefcd\";\n\n    // Check if S1 matches S2 using wildcard matching\n    if (wildcardMatching(S1, S2)) {\n        console.log(\"String S1 and S2 do match\");\n    } else {\n        console.log(\"String S1 and S2 do not match\");\n    }\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\n<strong>Output:</strong>String S1 and S2 do match\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are two nested loops.</p>\n<p><strong>Space Complexity: O(M)</strong></p>\n<p>Reason: We are using an external array of size \u2018M+1\u2019 to store two rows.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Wildcard Matching\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/ZmlQ3vgAOMo?si=9uvg_LQLhoHBypEV\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/xvNwoz-ufXA?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Wildcard Matching\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/ZmlQ3vgAOMo?si=9uvg_LQLhoHBypEV\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\">Anshuman Sharma</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\" target=\"_blank\" rel=\"noreferrer noopener\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 59,
    "preview": "Problem Statement: Wildcard Matching We are given two strings \u2018S1\u2019 and \u2018S2\u2019. String S1 can have the following two special characters: 1. \u2018?\u2019 can be matched to a single character of S2. 2. \u2018*\u2019 can b..."
}