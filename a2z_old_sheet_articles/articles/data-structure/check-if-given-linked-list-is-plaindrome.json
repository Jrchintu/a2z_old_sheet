{
    "dislikes": 6,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:53 GMT+0530 (India Standard Time)",
    "slug": "check-if-given-linked-list-is-plaindrome",
    "aid": "1609",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/check-if-ll-is-palindrome-or-not",
    "title": "Check if the given Linked List is Palindrome",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "linked-list",
            "topic-title": "Linked List"
        }
    ],
    "likes": 203,
    "category_tag": "data-structure",
    "preview": "Examples Example 1: Input Format: LL: 1 2 3 2 1 Output: True Explanation: A linked list with values \"1 2 3 2 1\" is a palindrome because its elements read the same from left to right and from right...",
    "content": "<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<p><strong>Example 1:</strong></p>\n<p><strong>Input Format</strong>:</p>\n<p>LL: 1&nbsp; 2&nbsp; 3&nbsp; 2&nbsp; 1</p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-2.19.16-PM-1024x184.png\" alt=\"\" class=\"wp-image-13049\" width=\"768\" height=\"138\"></figure>\n<p><strong>Output</strong>: True</p>\n<p><strong>Explanation: </strong>A linked list with values \"1 2 3 2 1\" is a palindrome because its elements read the same from left to right and from right to left, making it symmetrical and mirroring itself.</p>\n<p><strong>Example 2:</strong></p>\n<p><strong>Input Format:</strong></p>\n<p>LL: 1 2 3 3 2 1&nbsp;</p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-2.24.03-PM-1024x164.png\" alt=\"\" class=\"wp-image-13050\" width=\"768\" height=\"123\"></figure>\n<p><strong>Output: </strong>True</p>\n<p><strong>Explanation</strong>: A linked list with values \"1 2 3 3 2 1\" is a palindrome because it reads the same forwards and backwards.</p>\n<p><strong>Example 3:</strong></p>\n<p><strong>Input Format:</strong></p>\n<p>LL: 1 2 3 2 3</p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-2.26.29-PM-1024x194.png\" alt=\"\" class=\"wp-image-13051\" width=\"768\" height=\"146\"></figure>\n<p><strong>Output: </strong>False</p>\n<p><strong>Explanation</strong>: The linked list \"1 2 3 2 3\" is not a palindrome because it reads differently in reverse order, where \"3 2 3 2 1\" is not the same as the original sequence \"1 2 3 2 3.\"</p>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/check-if-linked-list-is-palindrome_985248?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_two\">\n<a href=\"#brute-force-approach\" class=\"two-boxes box-a\">\nBrute Force Approach\n</a>\n<a href=\"#optimal-approach\" class=\"two-boxes box-c\">\nOptimal Approach\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nBrute Force Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n\n<p>A straightforward approach to checking if the given linked list is a palindrome or not is to <strong>temporarily</strong> <strong>store</strong> the values in an <strong>additional</strong> <strong>data</strong> <strong>structure</strong>. We can use a <strong>stack</strong> for this. By pushing each node onto the stack as we traverse the list, we effectively <strong>store</strong> the <strong>data</strong> <strong>values</strong> in the <strong>reverse</strong> <strong>order</strong>. Once all the nodes are stored in the <strong>stack, </strong>we <strong>traverse</strong> the linked list again comparing each node's value with the values popped from the <strong>top</strong> of the <strong>stack.</strong>&nbsp;</p>\n<h3><strong>Algorithm:</strong></h3>\n<p><strong>Step 1:</strong> Create an empty <strong>stack</strong>. This stack will be used to temporarily store the nodes from the original linked list as we traverse it.</p>\n<p><strong>Step 2: </strong>Traverse the linked list using a temporary variable <strong>`temp`</strong> till it reaches null. At each node, push the value at the current node onto the stack.&nbsp;</p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-2.58.01-PM-1024x916.png\" alt=\"\" class=\"wp-image-13052\" width=\"768\" height=\"687\"></figure>\n<p><strong>Step 3: </strong>Set variable <strong>`temp`</strong> back to the head of the linked list. While the stack is not empty, <strong>compare</strong> the <strong>value</strong> at the <strong>temp</strong> node to the value at the<strong> top</strong> of the stack. <strong>Pop</strong> the stack and move th<strong>e temp</strong> to the <strong>next</strong> <strong>node</strong> till it reaches the end.</p>\n<p>During the <strong>comparison</strong>, if at any point the values do not match, the linked list is <strong>not</strong> a palindrome and hence returns <strong>false.</strong></p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-3.15.29-PM-1024x908.png\" alt=\"\" class=\"wp-image-13053\" width=\"768\" height=\"681\"></figure>\n<p><strong>Step 4: </strong>If all <strong>values</strong> <strong>match</strong> till emp reaches the end, it means that the linked list is a <strong>palindrome</strong>, as the values read the same way both forward and backward hence we return <strong>true.</strong></p>\n\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n// Node class represents a\n// node in a linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;   \n    \n    // Pointer to the next node in the list\n    Node* next;      \n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node* next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to nullptr\n    Node(int data1) {\n        data = data1;\n        next = nullptr;\n    }\n};\n\n\nbool isPalindrome(Node* head) {\n    // Create an empty stack\n    // to store values\n    stack&lt;int&gt; st;\n\n    // Initialize a temporary pointer\n    // to the head of the linked list\n    Node* temp = head;\n\n    // Traverse the linked list and\n    // push values onto the stack\n    while (temp != NULL) {\n        \n        // Push the data from the\n        // current node onto the stack\n        st.push(temp-&gt;data); \n        \n         // Move to the next node\n        temp = temp-&gt;next;  \n    }\n\n    // Reset the temporary pointer back\n    // to the head of the linked list\n    temp = head;\n\n    // Compare values by popping from the stack\n    // and checking against linked list nodes\n    while (temp != NULL) {\n        if (temp-&gt;data != st.top()) {\n            \n            // If values don't match,\n            // it's not a palindrome\n            return false; \n        }\n        \n        // Pop the value from the stack\n        st.pop();         \n        \n        // Move to the next node\n        // in the linked list\n        temp = temp-&gt;next; \n    }\n\n     // If all values match,\n     // it's a palindrome\n    return true;\n}\n\n\n\n// Function to print the linked list\nvoid printLinkedList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    // Create a linked list with\n    // values 1, 5, 2, 5, and 1 (15251, a palindrome)\n    Node* head = new Node(1);\n    head-&gt;next = new Node(5);\n    head-&gt;next-&gt;next = new Node(2);\n    head-&gt;next-&gt;next-&gt;next = new Node(5);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);\n\n    // Print the original linked list\n    cout &lt;&lt; \"Original Linked List: \";\n    printLinkedList(head);\n\n    // Check if the linked list is a palindrome\n    if (isPalindrome(head)) {\n        cout &lt;&lt; \"The linked list is a palindrome.\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"The linked list is not a palindrome.\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.Stack;\n\n// Node class represents a\n// node in a linked list\nclass Node {\n    // Data stored in the node\n    int data;      \n    // Pointer to the next\n    // node in the list\n    Node next;     \n\n    // Constructor with both data\n    // and next node as parameters\n    Node(int data, Node next) {\n        this.data = data;\n        this.next = next;\n    }\n\n    // Constructor with only data as\n    // a parameter, sets next to null\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n\n\n    public boolean isPalindrome(Node head) {\n        // Create an empty stack\n        // to store values\n        Stack&lt;Integer&gt; st = new Stack&lt;&gt;();\n    \n        // Initialize a temporary pointer\n        // to the head of the linked list\n        Node temp = head;\n    \n        // Traverse the linked list and\n        // push values onto the stack\n        while (temp != null) {\n            // Push the data from the\n            // current node onto the stack\n            st.push(temp.data);\n    \n            // Move to the next node\n            temp = temp.next;\n        }\n    \n        // Reset the temporary pointer back\n        // to the head of the linked list\n        temp = head;\n    \n        // Compare values by popping from the stack\n        // and checking against linked list nodes\n        while (temp != null) {\n            if (temp.data != st.peek()) {\n                // If values don't match,\n                // it's not a palindrome\n                return false;\n            }\n    \n            // Pop the value from the stack\n            st.pop();\n    \n            // Move to the next node\n            // in the linked list\n            temp = temp.next;\n        }\n    \n        // If all values match,\n        // it's a palindrome\n        return true;\n    }\n\n\n\n    // Function to print the linked list\n    public static void printLinkedList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" \");\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create a linked list with\n        // values 1, 5, 2, 5, and 1 (15251, a palindrome)\n        Node head = new Node(1);\n        head.next = new Node(5);\n        head.next.next = new Node(2);\n        head.next.next.next = new Node(5);\n        head.next.next.next.next = new Node(1);\n\n        // Print the original linked list\n        System.out.print(\"Original Linked List: \");\n        printLinkedList(head);\n\n        // Check if the linked list is a palindrome\n        if (isPalindrome(head)) {\n            System.out.println(\"The linked list is a palindrome.\");\n        } else {\n            System.out.println(\"The linked list is not a palindrome.\");\n        }\n    }\n\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nfrom collections import deque\n\nclass Node:\n    def __init__(self, data, next_node=None):\n        self.data = data\n        self.next = next_node\n\n\ndef isPalindrome(head):\n    # Create an empty deque\n    # to store values\n    st = deque()\n\n    # Initialize a temporary pointer\n    # to the head of the linked list\n    temp = head\n\n    # Traverse the linked list and\n    # push values onto the deque\n    while temp is not None:\n        # Push the data from the\n        # current node onto the deque\n        st.append(temp.data)\n\n        # Move to the next node\n        temp = temp.next\n\n    # Reset the temporary pointer back\n    # to the head of the linked list\n    temp = head\n\n    # Compare values by popping from the deque\n    # and checking against linked list nodes\n    while temp is not None:\n        if temp.data != st.pop():\n            # If values don't match,\n            # it's not a palindrome\n            return False\n\n        # Move to the next node\n        # in the linked list\n        temp = temp.next\n\n    # If all values match,\n    # it's a palindrome\n    return True\n\n    \n# Function to print the linked list\ndef print_linked_list(head):\n    temp = head\n    while temp is not None:\n        print(temp.data, end=\" \")\n        temp = temp.next\n    print()\n\ndef main():\n    # Create a linked list with\n    # values 1, 5, 2, 5, and 1 (15251, a palindrome)\n    head = Node(1)\n    head.next = Node(5)\n    head.next.next = Node(2)\n    head.next.next.next = Node(5)\n    head.next.next.next.next = Node(1)\n\n    # Print the original linked list\n    print(\"Original Linked List: \", end=\"\")\n    print_linked_list(head)\n\n    # Check if the linked list is a palindrome\n    if is_palindrome(head):\n        print(\"The linked list is a palindrome.\")\n    else:\n        print(\"The linked list is not a palindrome.\")\n\nif __name__ == \"__main__\":\n    main()\n\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nclass Node {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\n\n// Function to check if a linked list\n// is a palindrome\nfunction isPalindrome(head) {\n    // Create an empty stack\n    // to store values\n    const st = [];\n\n    // Initialize a temporary pointer\n    // to the head of the linked list\n    let temp = head;\n\n    // Traverse the linked list and\n    // push values onto the stack\n    while (temp !== null) {\n        // Push the data from the\n        // current node onto the stack\n        st.push(temp.data);\n\n        // Move to the next node\n        temp = temp.next;\n    }\n\n    // Reset the temporary pointer back\n    // to the head of the linked list\n    temp = head;\n\n    // Compare values by popping from the stack\n    // and checking against linked list nodes\n    while (temp !== null) {\n        if (temp.data !== st.pop()) {\n            // If values don't match,\n            // it's not a palindrome\n            return false;\n        }\n\n        // Move to the next node\n        // in the linked list\n        temp = temp.next;\n    }\n\n    // If all values match,\n    // it's a palindrome\n    return true;\n}\n\n\n// Function to print the linked list\nfunction printLinkedList(head) {\n    let temp = head;\n    while (temp !== null) {\n        console.log(temp.data + \" \");\n        temp = temp.next;\n    }\n    console.log();\n}\n\n// Main function\nfunction main() {\n    // Create a linked list with values\n    // 1, 5, 2, 5, and 1 (15251, a palindrome)\n    const head = new Node(1);\n    head.next = new Node(5);\n    head.next.next = new Node(2);\n    head.next.next.next = new Node(5);\n    head.next.next.next.next = new Node(1);\n\n    // Print the original linked list\n    console.log(\"Original Linked List: \");\n    printLinkedList(head);\n\n    // Check if the linked list is a palindrome\n    if (isPalindrome(head)) {\n        console.log(\"The linked list is a palindrome.\");\n    } else {\n        console.log(\"The linked list is not a palindrome.\");\n    }\n}\n\n// Call the main function to start the program\nmain();\n\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Brute Force Here -->\n<strong>Output:</strong> \nOriginal Linked List: 1 5 2 5 1&nbsp;The linked list is a palindrome.\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n</p><p><strong>Time Complexity: O(2 * N)</strong> This is because we <strong>traverse</strong> the linked list <strong>twice</strong>: once to push the values onto the stack, and once to pop the values and compare with the linked list. Both traversals take<strong> O(2*N) ~ O(N) time.</strong></p>\n<p><strong>Space Complexity: O(N) </strong>We use a <strong>stack</strong> to store the values of the linked list, and in the worst case, the stack will have all <strong>N</strong> <strong>values, </strong>&nbsp;ie. storing the complete linked list.&nbsp;</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nOptimal Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Better Approach Here -->\n<p>The previous approach uses<strong> O(N) additional space</strong>, which can be avoided by <strong>reversing</strong> only <strong>half</strong> of the linked list and comparing the <strong>first</strong> and <strong>second</strong> <strong>halves</strong>. If they match, reverse the portion that was originally reversed, and then return <strong>true</strong> else return <strong>false.</strong></p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-6.03.39-PM-1024x908.png\" alt=\"\" class=\"wp-image-13054\" width=\"768\" height=\"681\"></figure>\n<p>To implement this in-order reversal of the second half and its comparison with the first half has to be done in phases. The first step is dividing the first and second half of the linked list by recognizing the middle node using the <strong>Tortoise and Hare Algorithm</strong>. <a href=\"https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/\" target=\"_blank\" rel=\"noopener\" title=\"\">Read more about it here.</a></p>\n<h3><strong>Algorithm:</strong></h3>\n<p><strong>Step 1: </strong>Check if the linked list is empty or has only one node. If that\u2019s the case, it is a palindrome by definition, so return <strong>true</strong>.</p>\n<p><strong>Step 2: </strong>Initialise two pointers, <strong>\u2018slow\u2019 </strong>and <strong>\u2018fast\u2019</strong>, to find the middle of the linked list using the Tortoise and Hare Algorithm. The <strong>\u2018slow\u2019 </strong>pointer advances by one step at a time, while the <strong>\u2018fast\u2019</strong> pointer advances by two steps at a time. Continue this until the <strong>\u2018fast\u2019</strong> pointer reaches the end of the list or is the second last on the list. The \u2018slow\u2019 pointer will now be in the middle of the linked list.</p>\n<figure class=\"wp-block-image size-large is-resized\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/12/Screenshot-2023-11-12-at-9.00.15-PM-1024x377.png\" alt=\"\" class=\"wp-image-13055\" width=\"768\" height=\"283\"></figure>\n<p><strong>Step 3:</strong> <strong>Reverse</strong> the <strong>second</strong> <strong>half</strong> of the linked list starting from the middle (the <strong>\u2018slow-&gt;next\u2019 </strong>node). This is done by calling the reverse linked list function and returning the head of the new reversed linked list. Learn more about <a href=\"https://takeuforward.org/data-structure/reverse-a-linked-list/\" target=\"_blank\" rel=\"noopener\" title=\"\"><strong>reversing the linked list</strong></a>.</p>\n<p><strong>Step 4: </strong>Create two pointers, <strong>\u2018first\u2019 </strong>and <strong>\u2018second\u2019</strong>, where <strong>\u2018first\u2019</strong> points to the head of the linked list, and <strong>\u2018second\u2019</strong> points to the new head of the reversed second half.</p>\n<figure class=\"wp-block-image size-large\"><img src=\"https://static.takeuforward.org/wp/uploads/2024/01/Screenshot-2023-11-12-at-9.17.29-PM-1024x513.png\" alt=\"\" class=\"wp-image-13116\"></figure>\n<p><strong>Step 5: </strong>Compare data values of nodes from both halves. If the values do not match, it means the list is not a palindrome. In this case, return <strong>\u2018false\u2019</strong>. Continue moving both <strong>\u2018first\u2019 </strong>and <strong>\u2018second\u2019</strong> pointers through their <strong>respective</strong> <strong>halves</strong>, comparing the data values until one of them reaches the end of the list.</p>\n<figure class=\"wp-block-image size-large\"><img src=\"https://static.takeuforward.org/wp/uploads/2024/01/Screenshot-2023-11-12-at-9.22.01-PM-1024x549.png\" alt=\"\" class=\"wp-image-13117\"></figure>\n<p><strong>Step 6: </strong>After the comparison, <strong>reverse</strong> the <strong>second</strong> <strong>half</strong> back to its original state using the reverse linked list function and <strong>join</strong> <strong>back</strong> the linked list to its original state. Since all the values matched in the first half and reversed in the second half, return <strong>true</strong>. In case it does not match, return <strong>false.</strong></p>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\n// Node class represents a\n// node in a linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;   \n    \n    // Pointer to the next node in the list\n    Node* next;      \n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node* next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to nullptr\n    Node(int data1) {\n        data = data1;\n        next = nullptr;\n    }\n};\n\n// Function to reverse a linked list\n// using the recursive approach\nNode* reverseLinkedList(Node* head) {\n    // Check if the list is empty\n    // or has only one node\n    if (head == NULL || head-&gt;next == NULL) {\n        \n        // No change is needed;\n        // return the current head\n        return head; \n    }\n\n    // Recursive step: Reverse the remaining \n    // part of the list and get the new head\n    Node* newHead = reverseLinkedList(head-&gt;next);\n\n    // Store the next node in 'front'\n    // to reverse the link\n    Node* front = head-&gt;next;\n\n    // Update the 'next' pointer of 'front' to\n    // point to the current head, effectively\n    // reversing the link direction\n    front-&gt;next = head;\n\n    // Set the 'next' pointer of the\n    // current head to 'null' to\n    // break the original link\n    head-&gt;next = NULL;\n\n    // Return the new head obtained\n    // from the recursion\n    return newHead;\n}\n\nbool isPalindrome(Node* head) {\n    // Check if the linked list is empty\n    // or has only one node\n    if (head == NULL || head-&gt;next == NULL) {\n        \n         // It's a palindrome by definition\n        return true; \n    }\n    \n    // Initialize two pointers, slow and fast,\n    // to find the middle of the linked list\n    Node* slow = head;\n    Node* fast = head;\n    \n    // Traverse the linked list to find the\n    // middle using slow and fast pointers\n    while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL) {\n        \n        // Move slow pointer one step at a time\n        slow = slow-&gt;next;  \n        \n        // Move fast pointer two steps at a time\n        fast = fast-&gt;next-&gt;next;  \n    }\n    \n    // Reverse the second half of the\n    // linked list starting from the middle\n    Node* newHead = reverseLinkedList(slow-&gt;next);\n    \n    // Pointer to the first half\n    Node* first = head;  \n    \n     // Pointer to the reversed second half\n    Node* second = newHead; \n    while (second != NULL) {\n        \n        // Compare data values of \n        // nodes from both halves\n        \n        // If values do not match,\n        // the list is not a palindrome\n        if (first-&gt;data != second-&gt;data) {\n            \n            // Reverse the second half \n            // back to its original state\n            reverseLinkedList(newHead);  \n            \n            // Not a palindrome\n            return false;\n        }\n        \n         // Move the first pointer\n        first = first-&gt;next; \n        \n        // Move the second pointer\n        second = second-&gt;next;  \n    }\n    \n    // Reverse the second half\n    // back to its original state\n    reverseLinkedList(newHead);  \n    \n    // The linked list is a palindrome\n    return true;  \n}\n\n\n\n// Function to print the linked list\nvoid printLinkedList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout &lt;&lt; temp-&gt;data &lt;&lt; \" \";\n        temp = temp-&gt;next;\n    }\n    cout &lt;&lt; endl;\n}\n\nint main() {\n    // Create a linked list with\n    // values 1, 5, 2, 5, and 1 (15251, a palindrome)\n    Node* head = new Node(1);\n    head-&gt;next = new Node(5);\n    head-&gt;next-&gt;next = new Node(2);\n    head-&gt;next-&gt;next-&gt;next = new Node(5);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);\n\n    // Print the original linked list\n    cout &lt;&lt; \"Original Linked List: \";\n    printLinkedList(head);\n\n    // Check if the linked list is a palindrome\n    if (isPalindrome(head)) {\n        cout &lt;&lt; \"The linked list is a palindrome.\" &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"The linked list is not a palindrome.\" &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.Stack;\n\n// Node class represents a\n// node in a linked list\nclass Node {\n    // Data stored in the node\n    int data;      \n    // Pointer to the next\n    // node in the list\n    Node next;     \n\n    // Constructor with both data\n    // and next node as parameters\n    Node(int data, Node next) {\n        this.data = data;\n        this.next = next;\n    }\n\n    // Constructor with only data as\n    // a parameter, sets next to null\n    Node(int data) {\n        this.data = data;\n        this.next = null;\n    }\n}\n    // Function to reverse a linked list\n    // using the recursive approach\n    public Node reverseLinkedList(Node head) {\n        // Check if the list is empty or has only one node\n        if (head == null || head.next == null) {\n\n            // No change is needed;\n            // return the current head\n            return head;\n        }\n\n        // Recursive step: Reverse the remaining\n        // part of the list and get the new head\n        Node newHead = reverseLinkedList(head.next);\n\n        // Store the next node in 'front'\n        // to reverse the link\n        Node front = head.next;\n\n        // Update the 'next' pointer of 'front' to\n        // point to the current head, effectively\n        // reversing the link direction\n        front.next = head;\n\n        // Set the 'next' pointer of the\n        // current head to 'null' to\n        // break the original link\n        head.next = null;\n\n        // Return the new head obtained\n        // from the recursion\n        return newHead;\n    }\n    \n    public static boolean isPalindrome(Node head) {\n        // Check if the linked list is\n        // empty or has only one node\n        if (head == null || head.next == null) {\n            // It's a palindrome by definition\n            return true;\n        }\n    \n        // Initialize two pointers, slow and fast,\n        // to find the middle of the linked list\n        Node slow = head;\n        Node fast = head;\n    \n        // Traverse the linked list to find the\n        // middle using slow and fast pointers\n        while (fast.next != null &amp;&amp; fast.next.next != null) {\n            // Move slow pointer one step at a time\n            slow = slow.next;\n    \n            // Move fast pointer two steps at a time\n            fast = fast.next.next;\n        }\n    \n        // Reverse the second half of the \n        // linked list starting from the middle\n        Node newHead = reverseLinkedList(slow.next);\n    \n        // Pointer to the first half\n        Node first = head;\n    \n        // Pointer to the reversed second half\n        Node second = newHead;\n        while (second != null) {\n            // Compare data values of\n            // nodes from both halves\n    \n            // If values do not match, the\n            // list is not a palindrome\n            if (first.data != second.data) {\n                \n                // Reverse the second half back\n                // to its original state\n                reverseLinkedList(newHead);\n    \n                // Not a palindrome\n                return false;\n            }\n    \n            // Move the first pointer\n            first = first.next;\n    \n            // Move the second pointer\n            second = second.next;\n        }\n    \n        // Reverse the second half back\n        // to its original state\n        reverseLinkedList(newHead);\n    \n        // The linked list is a palindrome\n        return true;\n    }   \n\n\n    // Function to print the linked list\n    public static void printLinkedList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            System.out.print(temp.data + \" \");\n            temp = temp.next;\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Create a linked list with\n        // values 1, 5, 2, 5, and 1 (15251, a palindrome)\n        Node head = new Node(1);\n        head.next = new Node(5);\n        head.next.next = new Node(2);\n        head.next.next.next = new Node(5);\n        head.next.next.next.next = new Node(1);\n\n        // Print the original linked list\n        System.out.print(\"Original Linked List: \");\n        printLinkedList(head);\n\n        // Check if the linked list is a palindrome\n        if (isPalindrome(head)) {\n            System.out.println(\"The linked list is a palindrome.\");\n        } else {\n            System.out.println(\"The linked list is not a palindrome.\");\n        }\n    }\n\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nclass Node:\n    def __init__(self, data, next_node=None):\n        self.data = data\n        self.next = next_node\n\n# Function to reverse linked list\n# using recursion approach\ndef reverse_linked_list(head):\n    # Check if the list is empty\n    # or has only one node\n    if head is None or head.next is None:\n        \n        # No change is needed;\n        # return the current head\n        return head\n\n    # Recursive step: Reverse the remaining part\n    # of the list and obtain the new head\n    new_head = reverse_linked_list(head.next)\n\n    # Store the next node in 'front' to reverse the link\n    front = head.next\n\n    # Update the 'next' pointer of 'front' to \n    # point to the current head, effectively\n    # reversing the link direction\n    front.next = head\n\n    # Set the 'next' pointer of the current\n    # head to 'None' to break the original link\n    head.next = None\n\n    # Return the new head obtained\n    # from the recursion\n    return new_head\n    \ndef is_palindrome(head):\n    # Check if the linked list is empty\n    # or has only one node\n    if head is None or head.next is None:\n        # It's a palindrome by definition\n        return True\n\n    # Initialize two pointers, slow and fast,\n    # to find the middle of the linked list\n    slow = head\n    fast = head\n\n    # Traverse the linked list to find the\n    # middle using slow and fast pointers\n    while fast.next is not None and fast.next.next is not None:\n        # Move slow pointer one step at a time\n        slow = slow.next\n\n        # Move fast pointer two steps at a time\n        fast = fast.next.next\n\n    # Reverse the second half of the\n    # linked list starting from the middle\n    new_head = reverse_linked_list(slow.next)\n\n    # Pointer to the first half\n    first = head\n\n    # Pointer to the reversed second half\n    second = new_head\n    while second is not None:\n        # Compare data values of\n        # nodes from both halves\n\n        # If values do not match,\n        # the list is not a palindrome\n        if first.data != second.data:\n            # Reverse the second half\n            # back to its original state\n            reverse_linked_list(new_head)\n            # Not a palindrome\n            return False\n\n        # Move the first pointer\n        first = first.next\n\n        # Move the second pointer\n        second = second.next\n\n    # Reverse the second half\n    # back to its original state\n    reverse_linked_list(new_head)\n\n    # The linked list is a palindrome\n    return True\n    \n# Function to print the linked list\ndef print_linked_list(head):\n    temp = head\n    while temp is not None:\n        print(temp.data, end=\" \")\n        temp = temp.next\n    print()\n\ndef main():\n    # Create a linked list with\n    # values 1, 5, 2, 5, and 1 (15251, a palindrome)\n    head = Node(1)\n    head.next = Node(5)\n    head.next.next = Node(2)\n    head.next.next.next = Node(5)\n    head.next.next.next.next = Node(1)\n\n    # Print the original linked list\n    print(\"Original Linked List: \", end=\"\")\n    print_linked_list(head)\n\n    # Check if the linked list is a palindrome\n    if is_palindrome(head):\n        print(\"The linked list is a palindrome.\")\n    else:\n        print(\"The linked list is not a palindrome.\")\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nclass Node {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\n// Function to reverse a linked list\n// using the recursive approach\nfunction reverseLinkedList(head) {\n    \n    // Initialize pointer 'temp' at\n    // head of the linked list\n    let temp = head;  \n    \n    // Initialize a pointer 'prev' to null\n    // representing the previous node\n    // (initially none)\n    let prev = null;  \n\n    // Traversing the list, continue until\n    // 'temp' reaches the end (null)\n    while (temp !== null) {  \n        // Store the next node in\n        // 'front' to preserve the reference\n        let front = temp.next;  \n        \n        // Reverse direction of current node's\n        // 'next' pointer to point to 'prev'\n        temp.next = prev;  \n        \n        // Move 'prev' to the current node,\n        // preparing it for the next iteration\n        prev = temp;\n        \n        // Move 'temp' to the 'front' node\n        // (the next node), advancing traversal\n        temp = front;  \n    }\n\n    // Return the new head of\n    // the reversed linked list\n    return prev;  \n}\n\n// Function to check if a linked list\n// is a palindrome\nfunction isPalindrome(head) {\n    // Check if the linked list is empty\n    // or has only one node\n    if (head === null || head.next === null) {\n        // It's a palindrome by definition\n        return true;\n    }\n\n    // Initialize two pointers, slow and fast, \n    // to find the middle of the linked list\n    let slow = head;\n    let fast = head;\n\n    // Traverse the linked list to find\n    // the middle using slow and fast pointers\n    while (fast.next !== null &amp;&amp; fast.next.next !== null) {\n        \n        // Move slow pointer one step at a time\n        slow = slow.next;\n        // Move fast pointer two steps at a time\n        fast = fast.next.next;\n    }\n\n    // Reverse the second half of the\n    // linked list starting from the middle\n    const newHead = reverseLinkedList(slow.next);\n\n    // Pointer to the first half\n    let first = head;\n\n    // Pointer to the reversed second half\n    let second = newHead;\n\n    while (second !== null) {\n        // Compare data values of nodes from both halves\n        if (first.data !== second.data) {\n            \n            // Reverse the second half\n            // back to its original state\n            reverseLinkedList(newHead);\n            // Not a palindrome\n            return false;\n        }\n        // Move the first pointer\n        first = first.next;\n        // Move the second pointer\n        second = second.next;\n    }\n\n    // Reverse the second half\n    // back to its original state\n    reverseLinkedList(newHead);\n\n    // The linked list is a palindrome\n    return true;\n}\n\n// Function to print the linked list\nfunction printLinkedList(head) {\n    let temp = head;\n    while (temp !== null) {\n        console.log(temp.data + \" \");\n        temp = temp.next;\n    }\n    console.log();\n}\n\n// Main function\nfunction main() {\n    // Create a linked list with values\n    // 1, 5, 2, 5, and 1 (15251, a palindrome)\n    const head = new Node(1);\n    head.next = new Node(5);\n    head.next.next = new Node(2);\n    head.next.next.next = new Node(5);\n    head.next.next.next.next = new Node(1);\n\n    // Print the original linked list\n    console.log(\"Original Linked List: \");\n    printLinkedList(head);\n\n    // Check if the linked list is a palindrome\n    if (isPalindrome(head)) {\n        console.log(\"The linked list is a palindrome.\");\n    } else {\n        console.log(\"The linked list is not a palindrome.\");\n    }\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\n<strong>Output:</strong> \nOriginal Linked List: 1 5 2 5 1\nThe linked list is a palindrome.\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n</p><p><strong>Time Complexity: O (2* N) </strong>The algorithm traverses the <strong>linked</strong> <strong>list</strong> <strong>twice</strong>, dividing it into halves. During the <strong>first</strong> <strong>traversal</strong>, it <strong>reverses</strong> one-half of the list, and during the <strong>second</strong> <strong>traversal</strong>, it <strong>compares</strong> the elements of both halves. As each traversal covers<strong> N/2 elements</strong>, the time complexity is calculated as <strong>O(N/2 + N/2 + N/2 + N/2)</strong>, which simplifies to <strong>O(2N)</strong>, ultimately representing <strong>O(N)</strong>.&nbsp;</p>\n<p><strong>Space Complexity: O(1)</strong> The approach uses a <strong>constant</strong> <strong>amount</strong> of <strong>additional</strong> <strong>space</strong> regardless of the size of the input linked list. It <strong>doesn't</strong> <strong>allocate</strong> any new data structures that depend on the input size, resulting in a space complexity of O(1).</p>\n<p></p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Check if a Linked List is Palindrome or Not\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/lRY_G-u_8jk?si=pYVWms-VsnU6Z_r3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/lRY_G-u_8jk?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Check if a Linked List is Palindrome or Not\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/lRY_G-u_8jk?si=pYVWms-VsnU6Z_r3\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:paragraph -->\n<p>In case you are learning DSA, you should check out our free&nbsp;<a href=\"https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2/\" target=\"_blank\" rel=\"noopener\" title=\"\">A2Z DSA Course</a>&nbsp;with videos and blogs.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;</em><strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\" target=\"_blank\" rel=\"noreferrer noopener\">Gauri Tomar</a></strong><em>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam</em>, <a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\" target=\"_blank\" rel=\"noopener\" title=\"\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->"
}