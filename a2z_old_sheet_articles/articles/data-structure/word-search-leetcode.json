{
    "dislikes": 0,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:11:26 GMT+0530 (India Standard Time)",
    "slug": "word-search-leetcode",
    "aid": "2068",
    "title": "Word Search - Leetcode",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/word-search",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "string",
            "topic-title": "String"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p>Given an <strong>m x n</strong> <strong>grid of characters</strong> board and a <strong>string word</strong>, return<strong> true if the word exists</strong> in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong> \n[\n[\"A\", \"B\", \"C\", \"E\"], \n[\"S\", \"F\", \"C\", \"S\"],\n[\"A\", \"D\", \"E\", \"E\"]\n] \nword = \"ABCCED\"\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We can easily find the given word in the matrix.\n\n<strong>Example 2:</strong>\n<strong>Input:</strong>\n[\n[\"A\", \"B\", \"C\", \"E\"],\n[\"S\", \"F\", \"C\", \"S\"],\n[\"A\", \"D\", \"E\", \"E\"]\n]\nword = \"ABCB\"\n<strong>Output:</strong> false\n<strong>Explanation:</strong>  There is no such word in the given matrix.\n</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong>Disclaimer:</strong> <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Prerequisite: </strong>You should be aware of backtracking. If not then follow <a href=\"https://www.youtube.com/watch?v=yVdKa8dnKiE&amp;list=PLgUwDviBIf0rGlzIn_7rsaR2FQ5e6ZOL9\" target=\"_blank\" rel=\"noreferrer noopener\">Backtracking (Basics to Advanced)</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach:</strong>&nbsp; We are going to solve this by using backtracking, in this approach first we will linearly search the entire matrix to find the first letters matching our given string. If we found those letters then we can start backtracking in all four directions to find the rest of the letters of the given string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 1:</strong> Find the first character of the given string.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 2:</strong> Start Backtracking in all four directions until we find all the letters of sequentially adjacent cells.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Step 3:</strong> At the end, If we found our result then return true else return false.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Edge cases:</strong> Now think about what will be our stopping condition, we can stop or return false if we <strong>reach the end of the boundaries </strong>of the matrix or the letter at which we are making recursive calls <strong>is not the required letter</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We will also return if <strong>we found all the letters</strong> of the given word i.e. we found the number of letters equal to the length of the given word.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><em>NOTE: Do not forget that we cannot reuse a cell again.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>That is, we have to somehow keep track of our position so that we cannot find the same letter again and again.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>In this approach, we are going to mark visited cells with some random character that will prevent us from revisiting them again and again.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include&lt;bits/stdc++.h>\nusing namespace std;\n\n    bool searchNext(vector&lt;vector&lt;char>> &amp;board, string word, int row, int col, \n    int index, int m, int n) {\n\n        // if index reaches at the end that means we have found the word\n        if (index == word.length())\n            return true;\n\n        // Checking the boundaries if the character at which we are placed is not \n        //the required character\n        if (row &lt; 0 || col &lt; 0 || row == m || col == n || board[row][col] != \n        word[index] or board[row][col] == '!')\n            return false;\n\n        // this is to prevent reusing of the same character\n        char c = board[row][col];\n        board[row][col] = '!';\n\n        // top direction\n        bool top = searchNext(board, word, row - 1, col, index + 1, m, n);\n        // right direction\n        bool right = searchNext(board, word, row, col + 1, index + 1, m, n);\n        // bottom direction\n        bool bottom = searchNext(board, word, row + 1, col, index + 1, m, n);\n        // left direction\n        bool left = searchNext(board, word, row, col - 1, index + 1, m, n);\n\n        board[row][col] = c; // undo change\n\n        return top || right || bottom || left;\n    }\n    bool exist(vector&lt;vector&lt;char>> board, string word) {\n\n        int m = board.size();\n        int n = board[0].size();\n\n        int index = 0;\n\n        // First search the first character\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n\n                if (board[i][j] == word[index]) {\n                    if (searchNext(board, word, i, j, index, m, n))\n                        return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n\n    int main() {\n        vector&lt;vector&lt;char>> board {{'A','B','C','E'},\n                                    {'S','F','C','S'},\n                                    {'A','D','E','E'}};\n\n        string word = \"ABCCED\";\n\n        bool res = exist(board, word);\n        if(res==1)\n        cout&lt;&lt;\"True\"&lt;&lt;endl;\n        else\n        cout&lt;&lt;\"False\"&lt;&lt;endl;\n    }\n   \n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong>True</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; O(m*n*4^k)</strong>, <em>where \u201cK\u201d is the length of the word. And we are searching for the letter m*n times in the worst case. Here 4 in 4^k is because at each level of our decision tree we are making 4 recursive calls which equal 4^k in the worst case.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(K)</strong>, <em>Where k is the length of the given words.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.lang.*;\n\nclass Solution {\n    public static void main(String[] args) {\n        char[][] board = {{'A','B','C','E'},\n                          {'S','F','C','S'},\n                          {'A','D','E','E'}};\n\n        String word = \"ABCCED\";\n\n        Solution sol = new Solution();\n        boolean res = sol.exist(board, word);\n        System.out.println(res);\n    }\n    public boolean exist(char[][] board, String word) {\n\n        int m = board.length;\n        int n = board[0].length;\n\n        int index = 0;\n\n        // First search the first character\n        for (int i = 0; i &lt; m; i++) {\n            for (int j = 0; j &lt; n; j++) {\n\n                if (board[i][j] == word.charAt(index)) {\n                    if (searchNext(board, word, i, j, index, m, n))\n                        return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean searchNext(char[][] board, String word, int row, int col, \n    int index, int m, int n) {\n\n        // if index reaches at the end that means we have found the word\n        if (index == word.length())\n            return true;\n\n        // Checking the boundaries if the character at which we are placed is not \n        //the required character\n        if (row &lt; 0 || col &lt; 0 || row == m || col == n || board[row][col] != \n        word.charAt(index) || board[row][col] == '!')\n            return false;\n\n        // this is to prevent reusing of the same character\n        char c = board[row][col];\n        board[row][col] = '!';\n\n        // top direction\n        boolean top = searchNext(board, word, row - 1, col, index + 1, m, n);\n        // right direction\n        boolean right = searchNext(board, word, row, col + 1, index + 1, m, n);\n        // bottom direction\n        boolean bottom = searchNext(board, word, row + 1, col, index + 1, m, n);\n        // left direction\n        boolean left = searchNext(board, word, row, col - 1, index + 1, m, n);\n\n        board[row][col] = c; // undo change\n\n        return top || right || bottom || left;\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong>True</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:&nbsp; O(m*n*4^k)</strong>, <em>where \u201cK\u201d is the length of the word. And we are searching for the letter m*n times in the worst case. Here 4 in 4^k is because at each level of our decision tree we are making 4 recursive calls which equal 4^k in the worst case.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(K)</strong>, <em>Where k is the length of the given words.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/ishuprabhakar\" target=\"_blank\" rel=\"noreferrer noopener\"><strong><strong>Ishu Prabhakar</strong></strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 73,
    "preview": "Given an m x n grid of characters board and a string word, return true if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells..."
}