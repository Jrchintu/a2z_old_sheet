{
    "dislikes": 2,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:07 GMT+0530 (India Standard Time)",
    "slug": "check-if-the-binary-tree-is-balanced-binary-tree",
    "aid": "1397",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/check-for-balanced-binary-tree",
    "title": "Check if the Binary Tree is Balanced Binary Tree",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "likes": 112,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given a Binary Tree, return true if it is a Balanced Binary Tree else return false. A Binary Tree is balanced if, for all nodes in the tree, the difference between left and right...",
    "content": "<p><strong>Problem Statement: </strong>  Given a Binary Tree, return true if it is a Balanced Binary Tree else return false. \nA Binary Tree is balanced if, for all nodes in the tree, the difference between left and right subtree height is not more than 1.</p>\n\n\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n                <span><strong>Input:</strong>Binary Tree: 3 9 20 -1 -1 15 7</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image1-EWX-8Niv\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Output:</strong> True, This is a Balanced Binary Tree.</span>\n                <span><strong>Explanation: </strong>The difference in the height of left and right subtree is 1 hence the tree is balanced.</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image2-46UA3Wf3\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Example 2:</strong></span>\n                <span><strong>Input:</strong>Binary Tree: 1 3 2 5 4 -1 -1 7 6 \n                </span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image3-Fjdfx1vW\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Output :</strong> False, this is not a Balanced Binary Tree.</span>\n                <span><strong>Explanation: </strong>The difference in the height of left and right subtree is 2 hence the tree is not balanced.</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image4-srgyTlGy\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\n            </pre>\n        </div>\n    </details>\n</div>\n\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/is-height-balanced-binary-tree_975497?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\" alt=\"code-studio\">\n        </a>\n    </div>\n    \n</div>\n\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out yourself first. </em></p>\n\n\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n    <!-- Approach - 1 Starts from here -->\n    <div id=\"brute-force-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    <!-- Change Name Here -->\n                   Brute Force Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        <p>As a prerequisite, make sure you are thorough with the concepts of Calculating the <a href=\"https://takeuforward.org/data-structure/maximum-depth-of-a-binary-tree/\"> Height of a Binary Tree</a>. </p>\n\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image5-JClWO6-D\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Base Case:</strong>If the root node is null, signifying an empty tree, return true as an empty tree is considered balanced.</p>\n                        <p><strong>Recursive Algorithm: </strong>The `isBalanced` function is used to check if a Binary Tree is balanced, accepting a `root` node. \n                        Calculate the height of the left subtree and store it in a variable. Calculate the height of the right subtree and store it in a variable. \n                        Check if the absolute difference in heights of the left and right subtree is less than or equal to 1.  If true then call the `isBalanced` recursive function for both the left and right child.\n                        <ol><li>If the condition is satisfied and both the left and right subtrees are balanced (recursive calls to isBalanced return true), return true, indicating a balanced tree.</li><li>If the absolute difference of heights is greater than 1 or the recursive calls to left and right subtrees return false then return false.</li></ol></p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image6-0sxtQE1r\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Algorithm:</strong></p>\n                        <p><strong>Step 1:</strong>   Check if the root is null. If so, return true as an empty tree is balanced.</p>\n                    \n                        <p><strong>Step 2:</strong> Recursively calculate the height of the left and right subtrees using the `getHeight` function and store them.\n                        If their absolute height difference is greater than 1, return false.</p>\n                    \n                        <p><strong>Step 3:</strong> If their absolute height difference is less than or equal to 1, recursively call the isBalanced function on the left and right children as well. If the left and right children are also balanced, return true.</p>\n                    \n                        <p><strong>Step 4:</strong> If any of the conditions in Step 2 and Step 3 fail, return false.</p>\n\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to check if a binary tree is balanced\n    bool isBalanced(Node* root) {\n        // If the tree is empty, it's balanced\n        if (root == nullptr) {\n            return true;\n        }\n\n        // Calculate the height of left and right subtrees\n        int leftHeight = getHeight(root-&gt;left);\n        int rightHeight = getHeight(root-&gt;right);\n\n        // Check if the absolute difference in heights\n        // of left and right subtrees is &lt;= 1\n        if (abs(leftHeight - rightHeight) &lt;= 1 &amp;&amp;\n            isBalanced(root-&gt;left) &amp;&amp;\n            isBalanced(root-&gt;right)) {\n            return true;\n        }\n\n        // If any condition fails, the tree is unbalanced\n        return false;\n    }\n\n    // Function to calculate the height of a subtree\n    int getHeight(Node* root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root == nullptr) {\n            return 0;\n        }\n\n        // Recursively calculate the height\n        // of left and right subtrees\n        int leftHeight = getHeight(root-&gt;left);\n        int rightHeight = getHeight(root-&gt;right);\n\n        // Return the maximum height of left and right subtrees\n        // plus 1 (to account for the current node)\n        return max(leftHeight, rightHeight) + 1;\n    }\n};\n\n// Main function\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;right = new Node(3);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(5);\n    root-&gt;left-&gt;right-&gt;right = new Node(6);\n    root-&gt;left-&gt;right-&gt;right-&gt;right = new Node(7);\n\n    // Creating an instance of the Solution class\n    Solution solution;\n\n    // Checking if the tree is balanced\n    if (solution.isBalanced(root)) {\n        cout &lt;&lt; &quot;The tree is balanced.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;The tree is not balanced.&quot; &lt;&lt; endl;\n    }\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\n// Node structure for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    // Function to check if a binary tree is balanced\n    public boolean isBalanced(Node root) {\n        // If the tree is empty, it's balanced\n        if (root == null) {\n            return true;\n        }\n\n        // Calculate the height of left and right subtrees\n        int leftHeight = getHeight(root.left);\n        int rightHeight = getHeight(root.right);\n\n        // Check if the absolute difference in heights\n        // of left and right subtrees is &lt;= 1\n        if (Math.abs(leftHeight - rightHeight) &lt;= 1 &amp;&amp;\n            isBalanced(root.left) &amp;&amp;\n            isBalanced(root.right)) {\n            return true;\n        }\n\n        // If any condition fails, the tree is unbalanced\n        return false;\n    }\n\n    // Function to calculate the height of a subtree\n    public int getHeight(Node root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root == null) {\n            return 0;\n        }\n\n        // Recursively calculate the height\n        // of left and right subtrees\n        int leftHeight = getHeight(root.left);\n        int rightHeight = getHeight(root.right);\n\n        // Return the maximum height of left and right subtrees\n        // plus 1 (to account for the current node)\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n\n// Main function\npublic class Main {\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.left.right.right = new Node(6);\n        root.left.right.right.right = new Node(7);\n\n        // Creating an instance of the Solution class\n        Solution solution = new Solution();\n\n        // Checking if the tree is balanced\n        if (solution.isBalanced(root)) {\n            System.out.println(&quot;The tree is balanced.&quot;);\n        } else {\n            System.out.println(&quot;The tree is not balanced.&quot;);\n        }\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n# Node structure for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # Function to check if a binary tree is balanced\n    def isBalanced(self, root):\n        # If the tree is empty, it's balanced\n        if not root:\n            return True\n        \n        # Calculate the height of left and right subtrees\n        leftHeight = self.getHeight(root.left)\n        rightHeight = self.getHeight(root.right)\n\n        # Check if the absolute difference in heights\n        # of left and right subtrees is &lt;= 1\n        if abs(leftHeight - rightHeight) &lt;= 1 \\\n            and self.isBalanced(root.left) \\\n            and self.isBalanced(root.right):\n            return True\n\n        # If any condition fails, the tree is unbalanced\n        return False\n\n    # Function to calculate the height of a subtree\n    def getHeight(self, root):\n        # Base case: if the current node is NULL,\n        # return 0 (height of an empty tree)\n        if not root:\n            return 0\n        \n        # Recursively calculate the height\n        # of left and right subtrees\n        leftHeight = self.getHeight(root.left)\n        rightHeight = self.getHeight(root.right)\n        \n        # Return the maximum height of left and right subtrees\n        # plus 1 (to account for the current node)\n        return max(leftHeight, rightHeight) + 1\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.right.right = Node(6)\nroot.left.right.right.right = Node(7)\n\n# Creating an instance of the Solution class\nsolution = Solution()\n\n# Checking if the tree is balanced\nif solution.isBalanced(root):\n    print(&quot;The tree is balanced.&quot;)\nelse:\n    print(&quot;The tree is not balanced.&quot;)\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node structure for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to check if a binary tree is balanced\n    isBalanced(root) {\n        // If the tree is empty, it's balanced\n        if (root === null) {\n            return true;\n        }\n\n        // Calculate the height of left and right subtrees\n        const leftHeight = this.getHeight(root.left);\n        const rightHeight = this.getHeight(root.right);\n\n        // Check if the absolute difference in heights\n        // of left and right subtrees is &lt;= 1\n        if (Math.abs(leftHeight - rightHeight) &lt;= 1 &amp;&amp;\n            this.isBalanced(root.left) &amp;&amp;\n            this.isBalanced(root.right)) {\n            return true;\n        }\n\n        // If any condition fails, the tree is unbalanced\n        return false;\n    }\n\n    // Function to calculate the height of a subtree\n    getHeight(root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root === null) {\n            return 0;\n        }\n\n        // Recursively calculate the height\n        // of left and right subtrees\n        const leftHeight = this.getHeight(root.left);\n        const rightHeight = this.getHeight(root.right);\n\n        // Return the maximum height of left and right subtrees\n        // plus 1 (to account for the current node)\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.right = new Node(3);\nroot.left.left = new Node(4);\nroot.left.right = new Node(5);\nroot.left.right.right = new Node(6);\nroot.left.right.right.right = new Node(7);\n\n// Creating an instance of the Solution class\nconst solution = new Solution();\n\n// Checking if the tree is balanced\nif (solution.isBalanced(root)) {\n    console.log(&quot;The tree is balanced.&quot;);\n} else {\n    console.log(&quot;The tree is not balanced.&quot;);\n}\n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                           <strong>Output: </strong> The tree is not balanced.\n                        </p>\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N2)</strong> where N is the number of nodes in the Binary Tree.This arises as we calculate the height of each node and to calculate the height for each node, we traverse the tree which is proportional to the number of nodes. Since this calculation is performed for each node in the tree, the complexity becomes: O(N x N) ~ O(N2).</p>\n\n                        <p><strong>Space Complexity : O(1)</strong> as no additional data structures or memory is allocated.O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree.The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.</p>\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n    <!-- Approach - 1 Ends here -->\n\n\n    <!-- Approach - 2 Starts from here -->\n\n    <div id=\"optimal-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    Optimal Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        <p>The O(N*N) time complexity of the previous approach can be optimised by simultaneously checking the balance condition while traversing the tree.\n                        Instead of repeatedly calculating the heights of left and right subtrees at each node, we can compute these heights in a bottom-up manner. The Postorder method allows us to validate balance conditions efficiently during the traversal.\n                        The postorder traversal operates in a bottom-up manner, calculating subtree information before moving to the parent node. We save on time complexity of calling the height of children over and over again as we have access to the height information of both subtrees when evaluating the balance condition at the parent.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image7-zmjJoPFa\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p>This also allows early detection of unbalanced nodes without unnecessary height calculate if a subtree is already found to be unbalanced, hence avoiding unnecessary function calls.</p>\n                        <p><strong>Algorithm:</strong></p>\n                        <p><strong>Step 1:</strong> Traverse the Binary Tree is post-order manner using recursion. Visit left subtree, then right subtree, and finally the root node.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image8-E4nN_qMW\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    \n                        <p><strong>Step 2:</strong>During the traversal, for each node, calculate the heights of the its left and right subrees. Use the obtained subtree heights to validate the balance conditions for the current node.</p>\n                    \n                        <p><strong>Step 3:</strong> At each node, if the absolute difference between the heights of the left and right subtrees is greater than 1 or if any subtree is unbalanced (returns -1), return -1 immediately indicating an unbalanced tree.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image9-fk4KQVuh\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n                    \n                        <p><strong>Step 4:</strong>  If the tree is balanced, return the height of the current node by considering the maximum height of its left and right subtree plus 1 accounting for the current node.</p>\n                        <p><strong>Step 5:</strong> Complete the traversal until all nodes are visited and return the final result - either the height of the entire tree if balanced or -1 if unbalanced.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/balanced-tree-image10-9oCHe544\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stack&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\n\npublic:\n    // Function to check if a binary tree is balanced\n    bool isBalanced(Node* root) {\n        // Check if the tree's height difference\n        // between subtrees is less than 2\n        // If not, return false; otherwise, return true\n        return dfsHeight(root) != -1;\n    }\n\n    // Recursive function to calculate\n    // the height of the tree\n    int dfsHeight(Node* root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root == NULL) return 0;\n\n        // Recursively calculate the\n        // height of the left subtree\n        int leftHeight = dfsHeight(root-&gt;left);\n\n        // If the left subtree is unbalanced,\n        // propagate the unbalance status\n        if (leftHeight == -1) \n            return -1;\n\n        // Recursively calculate the\n        // height of the right subtree\n        int rightHeight = dfsHeight(root-&gt;right);\n\n        // If the right subtree is unbalanced,\n        // propagate the unbalance status\n        if (rightHeight == -1) \n            return -1;\n\n        // Check if the difference in height between\n        // left and right subtrees is greater than 1\n        // If it's greater, the tree is unbalanced,\n        // return -1 to propagate the unbalance status\n        if (abs(leftHeight - rightHeight) &gt; 1)  \n            return -1;\n\n        // Return the maximum height of left and\n        // right subtrees, adding 1 for the current node\n        return max(leftHeight, rightHeight) + 1;\n    }\n};\n\n\n\n\n\n// Main function\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;right = new Node(3);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(5);\n    root-&gt;left-&gt;right-&gt;right = new Node(6);\n    root-&gt;left-&gt;right-&gt;right-&gt;right = new Node(7);\n\n    // Creating an instance of the Solution class\n    Solution solution;\n\n    // Checking if the tree is balanced\n    if (solution.isBalanced(root)) {\n        cout &lt;&lt; &quot;The tree is balanced.&quot; &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; &quot;The tree is not balanced.&quot; &lt;&lt; endl;\n    }\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.lang.Math;\n\n// Node structure for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n\n    // Function to check if a binary tree is balanced\n    public boolean isBalanced(Node root) {\n        // Check if the tree's height difference\n        // between subtrees is less than 2\n        // If not, return false; otherwise, return true\n        return dfsHeight(root) != -1;\n    }\n\n    // Recursive function to calculate\n    // the height of the tree\n    public int dfsHeight(Node root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root == null) return 0;\n\n        // Recursively calculate the\n        // height of the left subtree\n        int leftHeight = dfsHeight(root.left);\n\n        // If the left subtree is unbalanced,\n        // propagate the unbalance status\n        if (leftHeight == -1) \n            return -1;\n\n        // Recursively calculate the\n        // height of the right subtree\n        int rightHeight = dfsHeight(root.right);\n\n        // If the right subtree is unbalanced,\n        // propagate the unbalance status\n        if (rightHeight == -1) \n            return -1;\n\n        // Check if the difference in height between\n        // left and right subtrees is greater than 1\n        // If it's greater, the tree is unbalanced,\n        // return -1 to propagate the unbalance status\n        if (Math.abs(leftHeight - rightHeight) &gt; 1)  \n            return -1;\n\n        // Return the maximum height of left and\n        // right subtrees, adding 1 for the current node\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n\npublic class Main {\n    // Main function\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.left.right.right = new Node(6);\n        root.left.right.right.right = new Node(7);\n\n        // Creating an instance of the Solution class\n        Solution solution = new Solution();\n\n        // Checking if the tree is balanced\n        if (solution.isBalanced(root)) {\n            System.out.println(&quot;The tree is balanced.&quot;);\n        } else {\n            System.out.println(&quot;The tree is not balanced.&quot;);\n        }\n    }\n}                                   \n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n# Node class for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # Function to check if a binary tree is balanced\n    def isBalanced(self, root):\n        # Check if the tree's height difference\n        # between subtrees is less than 2\n        # If not, return False; otherwise, return True\n        return self.dfsHeight(root) != -1\n\n    # Recursive function to calculate\n    # the height of the tree\n    def dfsHeight(self, root):\n        # Base case: if the current node is None,\n        # return 0 (height of an empty tree)\n        if not root:\n            return 0\n\n        # Recursively calculate the\n        # height of the left subtree\n        left_height = self.dfsHeight(root.left)\n\n        # If the left subtree is unbalanced,\n        # propagate the unbalance status\n        if left_height == -1:\n            return -1\n\n        # Recursively calculate the\n        # height of the right subtree\n        right_height = self.dfsHeight(root.right)\n\n        # If the right subtree is unbalanced,\n        # propagate the unbalance status\n        if right_height == -1:\n            return -1\n\n        # Check if the difference in height between\n        # left and right subtrees is greater than 1\n        # If it's greater, the tree is unbalanced,\n        # return -1 to propagate the unbalance status\n        if abs(left_height - right_height) &gt; 1:\n            return -1\n\n        # Return the maximum height of left and\n        # right subtrees, adding 1 for the current node\n        return max(left_height, right_height) + 1\n\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.left.right.right = Node(6)\nroot.left.right.right.right = Node(7)\n\n# Creating an instance of the Solution class\nsolution = Solution()\n\n# Checking if the tree is balanced\nif solution.isBalanced(root):\n    print(&quot;The tree is balanced.&quot;)\nelse:\n    print(&quot;The tree is not balanced.&quot;)                                   \n\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node structure for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to check if a binary tree is balanced\n    isBalanced(root) {\n        // Check if the tree's height difference\n        // between subtrees is less than 2\n        // If not, return false; otherwise, return true\n        return this.dfsHeight(root) !== -1;\n    }\n\n    // Recursive function to calculate\n    // the height of the tree\n    dfsHeight(root) {\n        // Base case: if the current node is NULL,\n        // return 0 (height of an empty tree)\n        if (root === null) return 0;\n\n        // Recursively calculate the\n        // height of the left subtree\n        const leftHeight = this.dfsHeight(root.left);\n\n        // If the left subtree is unbalanced,\n        // propagate the unbalance status\n        if (leftHeight === -1) \n            return -1;\n\n        // Recursively calculate the\n        // height of the right subtree\n        const rightHeight = this.dfsHeight(root.right);\n\n        // If the right subtree is unbalanced,\n        // propagate the unbalance status\n        if (rightHeight === -1) \n            return -1;\n\n        // Check if the difference in height between\n        // left and right subtrees is greater than 1\n        // If it's greater, the tree is unbalanced,\n        // return -1 to propagate the unbalance status\n        if (Math.abs(leftHeight - rightHeight) &gt; 1)  \n            return -1;\n\n        // Return the maximum height of left and\n        // right subtrees, adding 1 for the current node\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.right = new Node(3);\nroot.left.left = new Node(4);\nroot.left.right = new Node(5);\nroot.left.right.right = new Node(6);\nroot.left.right.right.right = new Node(7);\n\n// Creating an instance of the Solution class\nconst solution = new Solution();\n\n// Checking if the tree is balanced\nif (solution.isBalanced(root)) {\n    console.log(&quot;The tree is balanced.&quot;);\n} else {\n    console.log(&quot;The tree is not balanced.&quot;);\n}                                \n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                            <strong>Output:</strong> The tree is not balanced.\n                        </p>\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N)</strong> where N is the number of nodes in the Binary Tree. This complexity arises from visiting each node exactly once during the postorder traversal.</p>\n                        <p><strong>Space Complexity : O(1)</strong> as no additional space or data structures is created that is proportional to the input size of the tree. O(H) Recursive Stack Auxiliary Space : The recursion stack space is determined by the maximum depth of the recursion, which is the height of the binary tree denoted as H. In the balanced case it is log2N and in the worst case its N.</p>\n\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Yt50Jfbd8Po?si=aeyUcjrBhd_CqnoB\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n        </div>\n    </details>\n</div>\n\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}