{
    "dislikes": 3,
    "video": "FMwpt_aQOGw",
    "publishedOn": "Sun Mar 24 2024 22:11:49 GMT+0530 (India Standard Time)",
    "slug": "accounts-merge-dsu-g-50",
    "aid": "2170",
    "title": "Accounts Merge - DSU: G-50",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/accounts-merge",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given a list of accounts where each element account [ i ] is a list of strings, where the first element account [ i ][ 0 ]&nbsp; is a name, and the rest of the elements are emails representing emails of the account.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:</strong> Accounts themselves can be returned in any order.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-requisite: </strong><a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\" target=\"_blank\" rel=\"noopener\" title=\"\">Disjoint Set data structure</a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong> N = 4\naccounts [ ] =\n[[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],\n[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],\n[\"Mary\",\"mary@mail.com\"],\n[\"John\",\"johnnybravo@mail.com\"]]\n\n<strong>Output:</strong> [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\", \"johnsmith@mail.com\"],\n[\"Mary\",\"mary@mail.com\"],\n[\"John\",\"johnnybravo@mail.com\"]]\n\n<strong>Explanation:</strong> The first and the second John are the same person as they have a common email. But the third Mary and fourth John are not the same as they do not have any common email.  The result can be in any order but the emails must be in sorted order. The following is also a valid result:\n[['Mary', 'mary@mail.com'],\n['John', 'johnnybravo@mail.com'],\n['John', 'john00@mail.com' , 'john_newyork@mail.com', 'johnsmith@mail.com' ]]\n\n<strong>Example 2:</strong>\n<strong>Input:</strong> N = 6\naccounts [ ] =\n[[\"John\",\"j1@com\",\"j2@com\",\"j3@com\"],\n[\"John\",\"j4@com\"],\n[\"Raj\",\u201dr1@com\u201d, \u201cr2@com\u201d],\n[\"John\",\"j1@com\",\"j5@com\"],\n[\"Raj\",\u201dr2@com\u201d, \u201cr3@com\u201d],\n[\"Mary\",\"m1@com\"]]\n\n<strong>Output</strong>: [[\"John\",\"j1@com\",\"j2@com\",\"j3@com\",\"j5@com\"],\n[\"John\",\"j4@com\"],\n[\"Raj\",\u201dr1@com\u201d, \u201cr2@com\u201d,  \u201cr3@com\u201d],\n[\"Mary\",\"m1@com\"]]\n\n<strong>Explanation:</strong> The first and the fourth John are the same person here as they have a common email. And the third and the fifth Raj are also the same person. So, the same accounts are merged.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/account-merge/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=account-merge\" target=\"_blank\" rel=\"noopener\" title=\"\"><em>Problem link</em></a><em>.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Let\u2019s quickly understand the question before moving on to the solution part. According to the question, we can only merge two accounts with the same name only if the accounts contain at least one common email. After merging the accounts accordingly, we should return the answer where for each account the emails must be in the sorted order. But the order of the accounts does not matter. In order to solve this problem we are going to use the <a href=\"https://takeuforward.org/data-structure/disjoint-set-union-by-rank-union-by-size-path-compression-g-46/\" target=\"_blank\" rel=\"noopener\" title=\"\">Disjoint Set data structure</a>. Now, let\u2019s discuss the approach using the following example:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">Given: N = 6\naccounts [ ] =\n[[\"John\",\"j1@com\",\"j2@com\",\"j3@com\"],\n[\"John\",\"j4@com\"],\n[\"Raj\",\u201dr1@com\u201d, \u201cr2@com\u201d],\n[\"John\",\"j1@com\",\"j5@com\"],\n[\"Raj\",\u201dr2@com\u201d, \u201cr3@com\u201d],\n[\"Mary\",\"m1@com\"]]\n</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p>First, we will try to iterate over every single email and add them with their respective indices(i.e. Index of the accounts the email belongs to)&nbsp; in a map data structure. While doing this, when we will reach out to \u201cj1@com\u201d in the fourth account, we will find that it is already mapped with index 0. This incident means that we are currently in an account that can be merged. So, we will perform the union operation between the current index i.e. 3, and index 0(As in this case, we are following 0-based indexing). It will mean that the ultimate parent of index 3 is index 0. Similarly, this incident will repeat in the case of the third and fifth Raj. So we will perform the union of index 2 and 4.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>After completing the above process, the situation will be like the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7097,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-21-190024.png\" alt=\"\" class=\"wp-image-7097\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>Now, it\u2019s time to merge the emails. So, we will iterate over each email and will add them to the ultimate parent of the current account\u2019s index. Like, while adding the emails of account 4, we will add them to index 2 as the ultimate parent of 4 is index 2.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Finally, we will sort the emails for each account individually to get our answers in the format specified in the question.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:&nbsp;</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Here we will perform the disjoint set operations on the indices of the accounts considering them as the nodes.&nbsp;</li><li>As in each account, the first element is the name, we will start iterating from the second element in each account to visit only the emails sequentially.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are the following:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>First, we will <strong><em>create a map data structure.</em></strong> Then we will store each email with the respective index of the account(the email belongs to) in that map data structure.</li><li>While doing so, if we encounter an email again(i.e. If any index is previously assigned for the email), we will perform union(<strong><em>either unionBySize() or unionByRank()</em></strong>) of the current index and the previously assigned index.</li><li>After completing step 2, now it\u2019s time to <strong><em>merge the accounts</em></strong>. For merging, we will iterate over all the emails individually and find the ultimate parent(<strong><em>using the findUPar() method</em></strong>) of the assigned index of every email. Then we will add the email of the current account to the index(account index) that is the ultimate parent. Thus the accounts will be merged.</li><li>Finally, we will <strong><em>sort the emails for every account separately</em></strong> and store the final results in the answer array accordingly.</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n//User function Template for C++\nclass DisjointSet {\n    vector&lt;int&gt; rank, parent, size;\npublic:\n    DisjointSet(int n) {\n        rank.resize(n + 1, 0);\n        parent.resize(n + 1);\n        size.resize(n + 1);\n        for (int i = 0; i &lt;= n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    int findUPar(int node) {\n        if (node == parent[node])\n            return node;\n        return parent[node] = findUPar(parent[node]);\n    }\n\n    void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank[ulp_u] &lt; rank[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n        }\n        else if (rank[ulp_v] &lt; rank[ulp_u]) {\n            parent[ulp_v] = ulp_u;\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            rank[ulp_u]++;\n        }\n    }\n\n    void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size[ulp_u] &lt; size[ulp_v]) {\n            parent[ulp_u] = ulp_v;\n            size[ulp_v] += size[ulp_u];\n        }\n        else {\n            parent[ulp_v] = ulp_u;\n            size[ulp_u] += size[ulp_v];\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; accountsMerge(vector&lt;vector&lt;string&gt;&gt; &amp;details) {\n        int n = details.size();\n        DisjointSet ds(n);\n        sort(details.begin(), details.end());\n        unordered_map&lt;string, int&gt; mapMailNode;\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 1; j &lt; details[i].size(); j++) {\n                string mail = details[i][j];\n                if (mapMailNode.find(mail) == mapMailNode.end()) {\n                    mapMailNode[mail] = i;\n                }\n                else {\n                    ds.unionBySize(i, mapMailNode[mail]);\n                }\n            }\n        }\n\n        vector&lt;string&gt; mergedMail[n];\n        for (auto it : mapMailNode) {\n            string mail = it.first;\n            int node = ds.findUPar(it.second);\n            mergedMail[node].push_back(mail);\n        }\n\n        vector&lt;vector&lt;string&gt;&gt; ans;\n\n        for (int i = 0; i &lt; n; i++) {\n            if (mergedMail[i].size() == 0) continue;\n            sort(mergedMail[i].begin(), mergedMail[i].end());\n            vector&lt;string&gt; temp;\n            temp.push_back(details[i][0]);\n            for (auto it : mergedMail[i]) {\n                temp.push_back(it);\n            }\n            ans.push_back(temp);\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n\nint main() {\n\n    vector&lt;vector&lt;string&gt;&gt; accounts = {{\"John\", \"j1@com\", \"j2@com\", \"j3@com\"},\n        {\"John\", \"j4@com\"},\n        {\"Raj\", \"r1@com\", \"r2@com\"},\n        {\"John\", \"j1@com\", \"j5@com\"},\n        {\"Raj\", \"r2@com\", \"r3@com\"},\n        {\"Mary\", \"m1@com\"}\n    };\n\n\n    Solution obj;\n    vector&lt;vector&lt;string&gt;&gt; ans = obj.accountsMerge(accounts);\n    for (auto acc : ans) {\n        cout &lt;&lt; acc[0] &lt;&lt; \":\";\n        int size = acc.size();\n        for (int i = 1; i &lt; size; i++) {\n            cout &lt;&lt; acc[i] &lt;&lt; \" \";\n        }\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>John:j1@com j2@com j3@com j5@com<br>John:j4@com<br>Mary:m1@com<br>Raj:r1@com r2@com r3@com</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N+E) + O(E*4\u0251) + O(N*(ElogE + E)) where N = no. of indices or nodes and E = no. of emails. The first term is for visiting all the emails. The second term is for merging the accounts. And the third term is for sorting the emails and storing them in the answer array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N)+ O(N) +O(2N) ~ O(N) where N = no. of nodes/indices. The first and second space is for the \u2018mergedMail\u2019 and the \u2018ans\u2019 array. The last term is for the parent and size array used inside the Disjoint set data structure.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.io.*;\nimport java.util.*;\n\n\n\n//User function Template for Java\nclass DisjointSet {\n    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; size = new ArrayList&lt;&gt;();\n    public DisjointSet(int n) {\n        for (int i = 0; i &lt;= n; i++) {\n            rank.add(0);\n            parent.add(i);\n            size.add(1);\n        }\n    }\n\n    public int findUPar(int node) {\n        if (node == parent.get(node)) {\n            return node;\n        }\n        int ulp = findUPar(parent.get(node));\n        parent.set(node, ulp);\n        return parent.get(node);\n    }\n\n    public void unionByRank(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {\n            parent.set(ulp_v, ulp_u);\n        } else {\n            parent.set(ulp_v, ulp_u);\n            int rankU = rank.get(ulp_u);\n            rank.set(ulp_u, rankU + 1);\n        }\n    }\n\n    public void unionBySize(int u, int v) {\n        int ulp_u = findUPar(u);\n        int ulp_v = findUPar(v);\n        if (ulp_u == ulp_v) return;\n        if (size.get(ulp_u) &lt; size.get(ulp_v)) {\n            parent.set(ulp_u, ulp_v);\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));\n        } else {\n            parent.set(ulp_v, ulp_u);\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));\n        }\n    }\n}\nclass Solution {\n    static List&lt;List&lt;String&gt;&gt; accountsMerge(List&lt;List&lt;String&gt;&gt; details) {\n        int n = details.size();\n        DisjointSet ds = new DisjointSet(n);\n        HashMap&lt;String, Integer&gt; mapMailNode = new HashMap&lt;String, Integer&gt;();\n\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 1; j &lt; details.get(i).size(); j++) {\n                String mail = details.get(i).get(j);\n                if (mapMailNode.containsKey(mail) == false) {\n                    mapMailNode.put(mail, i);\n                } else {\n                    ds.unionBySize(i, mapMailNode.get(mail));\n                }\n            }\n        }\n\n        ArrayList&lt;String&gt;[] mergedMail = new ArrayList[n];\n        for (int i = 0; i &lt; n; i++) mergedMail[i] = new ArrayList&lt;String&gt;();\n        for (Map.Entry&lt;String, Integer&gt; it : mapMailNode.entrySet()) {\n            String mail = it.getKey();\n            int node = ds.findUPar(it.getValue());\n            mergedMail[node].add(mail);\n        }\n\n        List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();\n\n        for (int i = 0; i &lt; n; i++) {\n            if (mergedMail[i].size() == 0) continue;\n            Collections.sort(mergedMail[i]);\n            List&lt;String&gt; temp = new ArrayList&lt;&gt;();\n            temp.add(details.get(i).get(0));\n            for (String it : mergedMail[i]) {\n                temp.add(it);\n            }\n            ans.add(temp);\n        }\n        return ans;\n\n    }\n}\n\nclass Main {\n    public static void main (String[] args) {\n        List&lt;List&lt;String&gt;&gt; accounts = new ArrayList() {\n            {\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"John\", \"j1@com\", \"j2@com\", \"j3@com\")));\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"John\", \"j4@com\")));\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"Raj\", \"r1@com\", \"r2@com\")));\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"John\", \"j1@com\", \"j5@com\")));\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"Raj\", \"r2@com\", \"r3@com\")));\n                add(new ArrayList&lt;String&gt;(Arrays.asList(\"Mary\", \"m1@com\")));\n\n            }\n        };\n\n        Solution obj = new Solution();\n        List&lt;List&lt;String&gt;&gt; ans = obj.accountsMerge(accounts);\n\n        int n = ans.size();\n        for (int i = 0; i &lt; n; i++) {\n            System.out.print(ans.get(i).get(0) + \": \");\n            int size = ans.get(i).size();\n            for (int j = 1; j &lt; size; j++) {\n                System.out.print(ans.get(i).get(j) + \" \");\n            }\n\n            System.out.println(\"\");\n        }\n\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>John:j1@com j2@com j3@com j5@com<br>John:j4@com<br>Mary:m1@com<br>Raj:r1@com r2@com r3@com</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N+E) + O(E*4\u0251) + O(N*(ElogE + E)) where N = no. of indices or nodes and E = no. of emails. The first term is for visiting all the emails. The second term is for merging the accounts. And the third term is for sorting the emails and storing them in the answer array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N)+ O(N) +O(2N) ~ O(N) where N = no. of nodes/indices. The first and second space is for the \u2018mergedMail\u2019 and the \u2018ans\u2019 array. The last term is for the parent and size array used inside the Disjoint set data structure.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/kriti39/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>KRITIDIPTA GHOSH</strong></a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 41,
    "preview": "Problem Statement: Given a list of accounts where each element account [ i ] is a list of strings, where the first element account [ i ][ 0 ] is a name, and the rest of the elements are emails repr..."
}