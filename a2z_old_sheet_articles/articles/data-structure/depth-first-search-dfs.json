{
    "dislikes": 3,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:11:36 GMT+0530 (India Standard Time)",
    "slug": "depth-first-search-dfs",
    "aid": "2116",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/traversal-techniques",
    "title": "Depth First Search (DFS)",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "category_tag": "data-structure",
    "likes": 206,
    "preview": "Problem Statement: Given an undirected graph, return a vector of all nodes by traversing the graph using depth-first search (DFS). Pre-req: Recursion, Graph Representation Examples: Example 1: Inpu...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement: </strong>Given an undirected graph, return a vector of all nodes by traversing the graph using depth-first search (DFS).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-req:</strong> Recursion, Graph Representation</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input:</strong>\n<strong><img width=\"145\" height=\"152\" src=\"https://lh6.googleusercontent.com/7aHH23J9pUmANkszovgInsN6NvwzjqLx27LNlBMMTQopgVYULztw0cqdz0KOo0OJWwTL_Ms5K6YgBxCnKZuIx33sRdP_DJDB11Yu3z2gqR_8jie8hN3Ttg0z5MdFNQn9MipUF7ngiEoAl6UbzVGwuzI\"></strong>\n<strong>Output:</strong> 1 2 4 5 3</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 2:</strong>\n<strong>Input:</strong>\n<img width=\"293\" height=\"165\" src=\"https://lh6.googleusercontent.com/yQxrjm3_PAP7YbKRwtyz14xWvOQEFLMsLUarnZFSEm4qpB4gKR4NhlKTsNcF_WUkC2TQWOoT9A75KWG7ISIS5Ger-sCq5enP7vtQPxPJaUDh_3XCb_InMc7dAqWXBtm_-kUNBpN80LnSe7Glirts9TA\">\n<strong>Output:</strong> 1 2 3 4 5 6 7 8 9 10</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>DFS is a traversal technique which involves the idea of recursion and backtracking. DFS goes in-depth, i.e., traverses all nodes by going ahead, and when there are no further nodes to traverse in the current path, then it backtracks on the same path and traverses other unvisited nodes.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list {\"ordered\":true} -->\n<ol><li>In DFS, we start with a node \u2018v\u2019, mark it as visited and store it in the solution vector. It is unexplored as its adjacent nodes are not visited.</li><li>We run through all the adjacent nodes, and call the recursive dfs function to explore the node \u2018v\u2019 which has not been visited previously. This leads to the exploration of another node \u2018u\u2019 which is its adjacent node and is not visited.&nbsp;</li><li>The adjacency list stores the list of neighbours for any node. Pick the neighbour list of node \u2018v\u2019 and run a for loop on the list of neighbours (say nodes \u2018u\u2019 and \u2018w\u2019 are in the list). We go in-depth with each node. When node \u2018u\u2019 is explored completely then it backtracks and explores node \u2018w\u2019.</li><li>This traversal terminates when all the nodes are completely explored.&nbsp;</li></ol>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>In this way, all the nodes are traversed in a depthwise manner.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"602\" height=\"311\" src=\"https://lh5.googleusercontent.com/ViQ3z-uoX7bWIjLW04ppXvkK2emKLv1vfbz-0qqHVqWU96xz7o9UnXA7iKKVpnqCUVbI6T9S5aFaDHGSLFMidFhzgsDd6GCn13k6TkHHA_ikDjrAntI-0S_XS64koRVe7UEkx0Pjugu5OPLdhOLXiBc\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"597\" height=\"466\" src=\"https://lh6.googleusercontent.com/vik8WfOcj6-PKulF6ANSFAxW0j16cw78Xzf3k5HYQHbFsfx-u1VOZfH56T3iblO8KP98z1OEa0iQc_4l8d0WbkIVXnTRVJs53MTBH1X5rPxoeVqkTYHOBPcARVT31gGIsBcsM0RndYOiNCSgjt-2Ppk\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: </strong>For a better understanding of the dry run please check the video listed below.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution {\n  private: \n    void dfs(int node, vector&lt;int&gt; adj[], int vis[], vector&lt;int&gt; &amp;ls) {\n        vis[node] = 1; \n        ls.push_back(node); \n        // traverse all its neighbours\n        for(auto it : adj[node]) {\n            // if the neighbour is not visited\n            if(!vis[it]) {\n                dfs(it, adj, vis, ls); \n            }\n        }\n    }\n  public:\n    // Function to return a list containing the DFS traversal of the graph.\n    vector&lt;int&gt; dfsOfGraph(int V, vector&lt;int&gt; adj[]) {\n        int vis[V] = {0}; \n        int start = 0;\n        // create a list to store dfs\n        vector&lt;int&gt; ls; \n        // call dfs for starting node\n        dfs(start, adj, vis, ls); \n        return ls; \n    }\n};\n\nvoid addEdge(vector &lt;int&gt; adj[], int u, int v) {\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n}\n\nvoid printAns(vector &lt;int&gt; &amp;ans) {\n    for (int i = 0; i &lt; ans.size(); i++) {\n        cout &lt;&lt; ans[i] &lt;&lt; \" \";\n    }\n}\n\nint main() \n{\n    vector &lt;int&gt; adj[5];\n    \n    addEdge(adj, 0, 2);\n    addEdge(adj, 2, 4);\n    addEdge(adj, 0, 1);\n    addEdge(adj, 0, 3);\n\n    Solution obj;\n    vector &lt;int&gt; ans = obj.dfsOfGraph(5, adj);\n    printAns(ans);\n\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: </strong>0 2 4 1 3&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>For an undirected graph, O(N) + O(2E), For a directed graph, O(N) + O(E), Because for every node we are calling the recursive function once, the time taken is O(N) and 2E is for total degrees as we traverse for all adjacent nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(3N) ~ O(N), Space for dfs stack space, visited array and an adjacency list.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\nclass Solution {\n    \n    public static void dfs(int node, boolean vis[], ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj, \n    ArrayList&lt;Integer&gt; ls) {\n        \n        //marking current node as visited\n        vis[node] = true;\n        ls.add(node);\n        \n        //getting neighbour nodes\n        for(Integer it: adj.get(node)) {\n            if(vis[it] == false) {\n                dfs(it, vis, adj, ls);\n            }\n        }\n    }\n    // Function to return a list containing the DFS traversal of the graph.\n    public ArrayList&lt;Integer&gt; dfsOfGraph(int V, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {\n        //boolean array to keep track of visited vertices\n        boolean vis[] = new boolean[V+1];\n        vis[0] = true; \n        ArrayList&lt;Integer&gt; ls = new ArrayList&lt;&gt;();\n        dfs(0, vis, adj, ls); \n        return ls; \n    }\n    \n    public static void main(String args[]) {\n\n        ArrayList &lt; ArrayList &lt; Integer &gt;&gt; adj = new ArrayList &lt; &gt; ();\n        for (int i = 0; i &lt; 5; i++) {\n            adj.add(new ArrayList &lt; &gt; ());\n        }\n        adj.get(0).add(2);\n        adj.get(2).add(0);\n        adj.get(0).add(1);\n        adj.get(1).add(0);\n        adj.get(0).add(3);\n        adj.get(3).add(0);\n        adj.get(2).add(4);\n        adj.get(4).add(2);\n        \n        Solution sl = new Solution(); \n        ArrayList &lt; Integer &gt; ans = sl.dfsOfGraph(5, adj);\n        int n = ans.size(); \n        for(int i = 0;i&lt;n;i++) {\n            System.out.print(ans.get(i)+\" \"); \n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output: </strong>0 2 4 1 3&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>For an undirected graph, O(N) + O(2E), For a directed graph, O(N) + O(E), Because for every node we are calling the recursive function once, the time taken is O(N) and 2E is for total degrees as we traverse for all adjacent nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(3N) ~ O(N), Space for dfs stack space, visited array and an adjacency list.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/vanshika-singh-ba6b15157\" target=\"_blank\" rel=\"noreferrer noopener\">Vanshika Singh Gour</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->\n\n<!-- wp:embed {\"url\":\"https://youtu.be/Qzf1a\\u002d\\u002drhp8\",\"type\":\"video\",\"providerNameSlug\":\"youtube\",\"responsive\":true,\"className\":\"wp-embed-aspect-16-9 wp-has-aspect-ratio\"} -->\n<figure class=\"wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio\"><div class=\"wp-block-embed__wrapper\">\nhttps://youtu.be/Qzf1a--rhp8\n</div></figure>\n<!-- /wp:embed -->"
}