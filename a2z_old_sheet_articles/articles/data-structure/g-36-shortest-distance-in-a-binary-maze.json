{
    "dislikes": 1,
    "video": "U5Mw4eyUmw4",
    "publishedOn": "Sun Mar 24 2024 22:11:51 GMT+0530 (India Standard Time)",
    "slug": "g-36-shortest-distance-in-a-binary-maze",
    "aid": "2178",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/shortest-path-with-minimum-effort",
    "title": "G-36: Shortest Distance in a Binary Maze",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 62,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given an n * m matrix grid where each element can either be 0 or 1. You need to find the shortest distance between a given source cell to a destination cell. The path can only be...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement</strong>:&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Given an <strong>n * m</strong> matrix grid where each element can either be <strong>0</strong> or <strong>1.</strong> You need to find the shortest distance between a given source cell to a destination cell. The path can only be created out of a cell if its value is 1.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If the path is not possible between the source cell and the destination cell, then return <strong>-1</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note:</strong> You can move into an adjacent cell if that adjacent cell is filled with element 1. Two cells are adjacent if they share a side. In other words, you can move in one of four directions, Up, Down, Left, and Right.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\">Example 1:\n\nInput:\ngrid[][] = {{1, 1, 1, 1},\n            {1, 1, 0, 1},\n            {1, 1, 1, 1},\n            {1, 1, 0, 0},\n            {1, 0, 0, 1}}\nsource = {0, 1}\ndestination = {2, 2}\nOutput:\n3\n\nExplanation: \n\n1 1 1 1\n1 1 0 1\n1 1 1 1\n1 1 0 0\n1 0 0 1\nThe highlighted part in the above matrix denotes the shortest path from source to destination cell.\n\nExample 2:\n\nInput:\ngrid[][] = {{1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 1},\n            {1, 1, 1, 1, 0},\n            {1, 0, 1, 0, 1}}\nsource = {0, 0}\ndestination = {3, 4}\nOutput:\n-1 \nExplanation: \nSince, there is no path possible between the source cell and the destination cell, hence we return -1.\n</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong><strong>: </strong><strong><em>Don\u2019t jump directly to the solution, try it out yourself first.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/shortest-path-in-a-binary-maze-1655453161/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=shortest-path-in-a-binary-maze\"><strong><em>Problem Link</em></strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: In case any image/dry run is not clear please refer to the video attached at the bottom.&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach:</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We\u2019ll solve this problem by Dijkstra's Algorithm using a simple queue. Since, there is no adjacency list for this particular problem we can say that the adjacent cell for a coordinate is that cell which is either on the top, bottom, left, or right of the current cell i.e, a cell can have a maximum of 4 cells adjacent to it.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7154,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-174935.png\" alt=\"\" class=\"wp-image-7154\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Source Node and Destination Node: </strong>Before starting off with the Algorithm, we need to define a source node and a destination node, between which we need the shortest possible distance.</li><li><strong>Queue: </strong>Define a Queue which would contain pairs of the type {dist, pair of coordinates of cell }, where \u2018dist\u2019 indicates the currently updated value of the shortest distance from the source to the cell.</li><li><strong>Distance Matrix: </strong>Define a distance matrix that would contain the distance from the source cell to that particular cell. If a cell is marked as \u2018infinity\u2019 then it is treated as unreachable/unvisited.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>The Algorithm consists of the following steps :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Start by creating a queue that stores the distance-node pairs in the form {dist, coordinates of cell pair} and a dist matrix with each cell initialized with a very large number ( to indicate that they\u2019re unvisited initially) and the source cell marked as \u20180\u2019.</li><li>We push the source cell to the queue along with its distance which is also 0.</li><li>Pop the element at the front of the queue and look out for its adjacent nodes (left, right, bottom, and top cell). Also, for each cell, check the validity of the cell if it lies within the limits of the matrix or not.</li><li>If the current reachable distance to a cell from the source is better than the previous distance indicated by the distance matrix, we update the distance and push it into the queue along with cell coordinates.</li><li>A cell with a lower distance would be at the front of the queue as opposed to a node with a higher distance. We repeat the above two steps until the queue becomes empty or until we encounter the destination node.</li><li>Return the calculated distance and stop the algorithm from reaching the destination node. If the queue becomes empty and we don\u2019t encounter the destination node, return \u2018-1\u2019 indicating there\u2019s no path from source to destination.</li><li>Here\u2019s a quick demonstration of the algorithm :</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:image {\"id\":7155,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-175112.png\" alt=\"\" class=\"wp-image-7155\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:image {\"id\":7156,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-175146.png\" alt=\"\" class=\"wp-image-7156\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Note: If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition: </strong>Here in this problem, instead of a graph we have a 2D binary matrix in which we have to reach a destination cell from a source cell. So, we can see that this problem is easily approachable by Dijkstra\u2019s Algorithm. Now, here we use a <strong>queue</strong> instead of a <strong>priority queue</strong> for storing the distance-node pairs. Let\u2019s understand through an illustration why a queue is better here:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7157,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/12/Screenshot-2022-12-26-175241.png\" alt=\"\" class=\"wp-image-7157\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>We can see clearly in the above illustration that the distances are increasing monotonically (because of constant edge weights). Since greater distance comes at the top automatically, so we do not need the priority queue as the pop operation will always pop the smaller distance which is at the front of the queue. This helps us to eliminate an additional log(N) of time needed to perform insertion-deletion operations in a priority queue.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int shortestPath(vector&lt;vector&lt;int&gt;&gt; &amp;grid, pair&lt;int, int&gt; source,\n                     pair&lt;int, int&gt; destination)\n    {\n        // Edge Case: if the source is only the destination.\n        if (source.first == destination.first &amp;&amp;\n            source.second == destination.second)\n            return 0;\n\n        // Create a queue for storing cells with their distances from source\n        // in the form {dist,{cell coordinates pair}}.\n        queue&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; q;\n        int n = grid.size();\n        int m = grid[0].size();\n\n        // Create a distance matrix with initially all the cells marked as\n        // unvisited and the source cell as 0.\n        vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(m, 1e9));\n        dist[source.first][source.second] = 0;\n        q.push({0, {source.first, source.second}});\n\n        // The following delta rows and delts columns array are created such that\n        // each index represents each adjacent node that a cell may have \n        // in a direction.\n        int dr[] = {-1, 0, 1, 0};\n        int dc[] = {0, 1, 0, -1};\n\n        // Iterate through the maze by popping the elements out of the queue\n        // and pushing whenever a shorter distance to a cell is found.\n        while (!q.empty())\n        {\n            auto it = q.front();\n            q.pop();\n            int dis = it.first;\n            int r = it.second.first;\n            int c = it.second.second;\n\n            // Through this loop, we check the 4 direction adjacent nodes\n            // for a shorter path to destination.\n            for (int i = 0; i &lt; 4; i++)\n            {\n                int newr = r + dr[i];\n                int newc = c + dc[i];\n\n                // Checking the validity of the cell and updating if dist is shorter.\n                if (newr &gt;= 0 &amp;&amp; newr &lt; n &amp;&amp; newc &gt;= 0 &amp;&amp; newc &lt; m &amp;&amp; grid[newr][newc] \n                == 1 &amp;&amp; dis + 1 &lt; dist[newr][newc])\n                {\n                    dist[newr][newc] = 1 + dis;\n\n                    // Return the distance until the point when\n                    // we encounter the destination cell.\n                    if (newr == destination.first &amp;&amp;\n                        newc == destination.second)\n                        return dis + 1;\n                    q.push({1 + dis, {newr, newc}});\n                }\n            }\n        }\n        // If no path is found from source to destination.\n        return -1;\n    }\n};\n\nint main()\n{\n    // Driver Code.\n\n    pair&lt;int, int&gt; source, destination;\n    source.first = 0;\n    source.second = 1;\n    destination.first = 2;\n    destination.second = 2;\n\n    vector&lt;vector&lt;int&gt;&gt; grid = {{1, 1, 1, 1},\n                                {1, 1, 0, 1},\n                                {1, 1, 1, 1},\n                                {1, 1, 0, 0},\n                                {1, 0, 0, 1}};\n\n    Solution obj;\n\n    int res = obj.shortestPath(grid, source, destination);\n\n    cout &lt;&lt; res;\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output</strong> <strong>:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>3</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:</strong> O( 4*N*M ) { N*M are the total cells, for each of which we also check 4 adjacent nodes for the shortest path length},&nbsp;Where N = No. of rows of the binary maze and M = No. of columns of the binary maze.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity:</strong> O( N*M ),&nbsp;Where N = No. of rows of the binary maze and M = No. of columns of the binary maze.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass tuple { \n    int first, second, third; \n    tuple(int _first, int _second, int _third) {\n        this.first = _first; \n        this.second = _second; \n        this.third = _third; \n    }\n}\nclass Solution {\n\n    int shortestPath(int[][] grid, int[] source, int[] destination) {\n\n        // Edge Case: if the source is only the destination.\n        if(source[0] == destination[0] &amp;&amp; \n           source[1] == destination[1]) return 0; \n\n        // Create a queue for storing cells with their distances from source\n        // in the form {dist,{cell coordinates pair}}.\n        Queue&lt;tuple&gt; q = new LinkedList&lt;&gt;();  \n        int n = grid.length; \n        int m = grid[0].length;\n\n        // Create a distance matrix with initially all the cells marked as\n        // unvisited and the source cell as 0. \n        int[][] dist = new int[n][m]; \n        for(int i = 0;i&lt;n;i++) {\n            for(int j =0;j&lt;m;j++) {\n                dist[i][j] = (int)(1e9); \n            }\n        }\n        dist[source[0]][source[1]] = 0; \n        q.add(new tuple(0, source[0], source[1])); \n\n        // The following delta rows and delts columns array are created such that\n        // each index represents each adjacent node that a cell may have \n        // in a direction.\n        int dr[] = {-1, 0, 1, 0}; \n        int dc[] = {0, 1, 0, -1}; \n \n        // Iterate through the maze by popping the elements out of the queue\n        // and pushing whenever a shorter distance to a cell is found.\n        while(!q.isEmpty()) {\n            tuple it = q.peek(); \n            q.remove(); \n            int dis = it.first; \n            int r = it.second; \n            int c = it.third; \n            \n            // Through this loop, we check the 4 direction adjacent nodes\n            // for a shorter path to destination.\n            for(int i = 0;i&lt;4;i++) {\n                int newr = r + dr[i]; \n                int newc = c + dc[i]; \n                \n                // Checking the validity of the cell and updating if dist is shorter.\n                if(newr &gt;= 0 &amp;&amp; newr &lt; n &amp;&amp; newc &gt;= 0 &amp;&amp; newc &lt; m \n                &amp;&amp; grid[newr][newc] == 1 &amp;&amp; dis + 1 &lt; dist[newr][newc]) {\n                    dist[newr][newc] = 1 + dis; \n\n                    // Return the distance until the point when\n                    // we encounter the destination cell.\n                    if(newr == destination[0] &amp;&amp; \n                       newc == destination[1]) return dis + 1; \n                    q.add(new tuple(1+dis, newr, newc)); \n                }\n            }\n        }\n        // If no path is found from source to destination.\n        return -1; \n    }\n}\n\nclass tuf {\n\n    public static void main(String[] args) {\n       \n        int[] source={0,1};\n        int[] destination={2,2};\n        \n        int[][] grid={{1, 1, 1, 1},\n            {1, 1, 0, 1},\n            {1, 1, 1, 1},\n            {1, 1, 0, 0},\n            {1, 0, 0, 1}};\n\n        Solution obj = new Solution();\n        int res = obj.shortestPath(grid, source, destination);\n        \n        System.out.print(res);\n        System.out.println();\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output</strong> <strong>:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>3</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity:</strong> O( 4*N*M ) { N*M are the total cells, for each of which we also check 4 adjacent nodes for the shortest path length},&nbsp;Where N = No. of rows of the binary maze and M = No. of columns of the binary maze.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity:</strong> O( N*M ),&nbsp;Where N = No. of rows of the binary maze and M = No. of columns of the binary maze.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/priyanshi-goel-7b6a42210/\" target=\"_blank\" rel=\"noreferrer noopener\">Priyanshi Goel</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\" target=\"_blank\" rel=\"noreferrer noopener\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}