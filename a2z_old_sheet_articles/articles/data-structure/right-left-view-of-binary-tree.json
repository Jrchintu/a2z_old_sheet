{
    "dislikes": 22,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:12 GMT+0530 (India Standard Time)",
    "slug": "right-left-view-of-binary-tree",
    "aid": "1418",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/right-left-view-of-bt",
    "title": "Right/Left view of binary tree",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "queue",
            "topic-title": "Queue"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "category_tag": "data-structure",
    "likes": 75,
    "preview": "Problem Statement: Given a Binary Tree, return its right and left views. The Right View of a Binary Tree is a list of nodes that can be seen when the tree is viewed from the right side. The Left Vi...",
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Tree, return its right and left views.</p>\n<p>\nThe Right View of a Binary Tree is a list of nodes that can be seen when the tree is viewed from the right side. The Left View of a Binary Tree is a list of nodes that can be seen when the tree is viewed from the left side.\n\n</p>\n\n\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n                <span><strong>Input:</strong>Binary Tree: 1 2 3 4 10 9 11 -1 5 -1 -1 -1 -1 -1 -1 -1 6 </span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image1-LK79LuMP\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Output:</strong> Left View: [1, 2, 4, 5, 6] , Right View: [1, 3, 11, 5, 6]</span>\n                \n                <span><strong>Explanation: </strong></span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image2-4lJ-ias4\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                \n                <span><strong>Example 2:</strong></span>\n                <span><strong>Input:</strong>Binary Tree: 2 7 5 2 6 -1 9 -1 -1 5 11 4 -1\n                </span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image3-oyZSMVIG\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Output :</strong>Left View Traversal:[2,7,2,5], Right View Traversal:[2,5,9,4] </span>\n                \n                <span><strong>Explanation: </strong></span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image4-bZR52MA_\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                \n\n            </pre>\n        </div>\n    </details>\n</div>\n\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/left-view-of-binary-tree_625707?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\" alt=\"code-studio\">\n        </a>\n    </div>\n    \n</div>\n\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out yourself first. </em></p>\n\n\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n    <!-- Approach - 1 Starts from here -->\n    <div id=\"brute-force-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    <!-- Change Name Here -->\n                   Brute Force Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        \n\n                        <p><strong>Algorithm:</strong></p>\n                        <p><strong>Step 1:</strong> Initialise an empty queue data structure to store the nodes during traversal. Create a 2D array or a vector of a vector to store the level order traversal. If the tree is empty, return this empty 2D vector.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image5-O-RhX14-\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 2:</strong>Enqueue the root node ie. Add the root node of the binary tree to the queue.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image6-4YlP73eP\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                       \n                        <p><strong>Step 3:</strong>Iterate until the queue is empty:\n                        <ol><li>Get the current size of the queue. This size indicates the number of nodes at the current level.</li><li>Create a vector \u2018level\u2019 to store the nodes at the current level.</li><li>Iterate through \u2018size\u2019 number of nodes at the current level:</li>\n                        <ol><li>Pop the front node from the queue.</li><li>Store the node\u2019s value in the level vector.</li><li>Enqueue the left and right child nodes of the current node (if they exist) into the queue.</li></ol>\n                        <li>After processing all the nodes at the current level, add the \u2018level\u2019 vector to the \u2018ans\u2019 2D vector, representing the current level.</li></ol></p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image7-FelIY9gq\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 4: </strong>Once the traversal loop completes, the 'ans' 2D vector now contains the level order traversal of the binary tree. To obtain the left view and right view we use each level's vector in the 'ans' vector</p>\n                        <p><strong>Left View: </strong>For each level, extract the first element from the vector and store it in a separate array. Return this array as the final left view of the binary tree.</p>\n                        <p><strong>Right View: </strong>For each level, extract the last element from the vector and store it in a separate array. Return this array as the final right view of the binary tree.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image8-4gaBI4XW\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val),\n        left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to return the\n    // Right view of the binary tree\n    vector&lt;int&gt; rightsideView(Node* root) {\n        // Vector to store\n        // the result\n        vector&lt;int&gt; res;\n\n        // Get the level order\n        // traversal of the tree\n        vector&lt;vector&lt;int&gt;&gt; levelTraversal = levelOrder(root);\n\n        // Iterate through each level and\n        // add the last element to the result\n        for (auto level : levelTraversal) {\n            res.push_back(level.back());\n        }\n\n        return res;\n    }\n\n    // Function to return the\n    // Left view of the binary tree\n    vector&lt;int&gt; leftsideView(Node* root) {\n        // Vector to store the result\n        vector&lt;int&gt; res;\n\n        // Get the level order\n        // traversal of the tree\n        vector&lt;vector&lt;int&gt;&gt; levelTraversal = levelOrder(root);\n\n        // Iterate through each level and\n        // add the first element to the result\n        for (auto level : levelTraversal) {\n            res.push_back(level.front());\n        }\n\n        return res;\n    }\n\nprivate:\n    // Function that returns the\n    // level order traversal of a Binary tree \n    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) {\n        vector&lt;vector&lt;int&gt;&gt; ans;\n\n        // Return an empty vector\n        // if the tree is empty\n        if (!root) {\n            return ans;\n        }\n\n        // Use a queue to perform\n        // level order traversal\n        queue&lt;Node*&gt; q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int size = q.size();\n            vector&lt;int&gt; level;\n\n            // Process each node\n            // in the current level\n            for (int i = 0; i &lt; size; i++) {\n                Node* top = q.front();\n                level.push_back(top-&gt;data);\n                q.pop();\n\n                // Enqueue the left\n                // child if it exists\n                if (top-&gt;left != NULL) {\n                    q.push(top-&gt;left);\n                }\n\n                // Enqueue the right\n                // child if it exists\n                if (top-&gt;right != NULL) {\n                    q.push(top-&gt;right);\n                }\n            }\n\n            // Add the current\n            // level to the result\n            ans.push_back(level);\n        }\n\n        return ans;\n    }\n};\n\n\n\n\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(10);\n    root-&gt;left-&gt;left-&gt;right = new Node(5);\n    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);\n    root-&gt;right = new Node(3);\n    root-&gt;right-&gt;right = new Node(10);\n    root-&gt;right-&gt;left = new Node(9);\n\n    Solution solution;\n\n        // Get the Right View traversal\n    vector&lt;int&gt; rightView = solution.rightsideView(root);\n\n    // Print the result for Right View\n    cout &lt;&lt; &quot;Right View Traversal: &quot;;\n    for(auto node: rightView){\n        cout &lt;&lt; node &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n\n    // Get the Left View traversal\n    vector&lt;int&gt; leftView = solution.leftsideView(root);\n\n    // Print the result for Left View\n    cout &lt;&lt; &quot;Left View Traversal: &quot;;\n    for(auto node: leftView){\n        cout &lt;&lt; node &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Node structure for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n\n    // Function to return the Right view of the binary tree\n    public List&lt;Integer&gt; rightsideView(Node root) {\n        // List to store the result\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n\n        // Call the recursive function\n        // to populate the right-side view\n        recursionRight(root, 0, res);\n\n        return res;\n    }\n\n    // Function to return the Left view of the binary tree\n    public List&lt;Integer&gt; leftsideView(Node root) {\n        // List to store the result\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n\n        // Call the recursive function\n        // to populate the left-side view\n        recursionLeft(root, 0, res);\n\n        return res;\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the left-side view\n    private void recursionLeft(Node root, int level, List&lt;Integer&gt; res) {\n        // Check if the current node is null\n        if (root == null) {\n            return;\n        }\n\n        // Check if the size of the result list\n        // is equal to the current level\n        if (res.size() == level) {\n            // If equal, add the value of the\n            // current node to the result list\n            res.add(root.data);\n        }\n\n        // Recursively call the function for the\n        // left child with an increased level\n        recursionLeft(root.left, level + 1, res);\n\n        // Recursively call the function for the\n        // right child with an increased level\n        recursionLeft(root.right, level + 1, res);\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the right-side view\n    private void recursionRight(Node root, int level, List&lt;Integer&gt; res) {\n        // Check if the current node is null\n        if (root == null) {\n            return;\n        }\n\n        // Check if the size of the result list\n        // is equal to the current level\n        if (res.size() == level) {\n            // If equal, add the value of the\n            // current node to the result list\n            res.add(root.data);\n\n            // Recursively call the function for the\n            // right child with an increased level\n            recursionRight(root.right, level + 1, res);\n\n            // Recursively call the function for the\n            // left child with an increased level\n            recursionRight(root.left, level + 1, res);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.left.left = new Node(4);\n        root.left.right = new Node(10);\n        root.left.left.right = new Node(5);\n        root.left.left.right.right = new Node(6);\n        root.right = new Node(3);\n        root.right.right = new Node(10);\n        root.right.left = new Node(9);\n\n        Solution solution = new Solution();\n\n        // Get the Right View traversal\n        List&lt;Integer&gt; rightView = solution.rightsideView(root);\n\n        // Print the result for Right View\n        System.out.print(&quot;Right View Traversal: &quot;);\n        for (int node : rightView) {\n            System.out.print(node + &quot; &quot;);\n        }\n        System.out.println();\n\n        // Get the Left View traversal\n        List&lt;Integer&gt; leftView = solution.leftsideView(root);\n\n        // Print the result for Left View\n        System.out.print(&quot;Left View Traversal: &quot;);\n        for (int node : leftView) {\n            System.out.print(node + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n # Node class for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\n# Solution class to get the left\n# and right view of the binary tree\nclass Solution:\n    def rightsideView(self, root):\n        # Vector to store the result\n        res = []\n        \n        # Call the recursive function\n        # to populate the right-side view\n        self.recursionRight(root, 0, res)\n        \n        return res\n\n    def leftsideView(self, root):\n        # Vector to store the result\n        res = []\n        \n        # Call the recursive function\n        # to populate the left-side view\n        self.recursionLeft(root, 0, res)\n        \n        return res\n\n    # Recursive function to traverse the\n    # binary tree and populate the left-side view\n    def recursionLeft(self, root, level, res):\n        # Check if the current node is None\n        if not root:\n            return\n        \n        # Check if the size of the result list\n        # is equal to the current level\n        if len(res) == level:\n            # If equal, add the value of the\n            # current node to the result list\n            res.append(root.data)\n        \n        # Recursively call the function for the\n        # left child with an increased level\n        self.recursionLeft(root.left, level + 1, res)\n        \n        # Recursively call the function for the\n        # right child with an increased level\n        self.recursionLeft(root.right, level + 1, res)\n\n    # Recursive function to traverse the\n    # binary tree and populate the right-side view\n    def recursionRight(self, root, level, res):\n        # Check if the current node is None\n        if not root:\n            return\n        \n        # Check if the size of the result list\n        # is equal to the current level\n        if len(res) == level:\n            # If equal, add the value of the\n            # current node to the result list\n            res.append(root.data)\n            \n            # Recursively call the function for the\n            # right child with an increased level\n            self.recursionRight(root.right, level + 1, res)\n            \n            # Recursively call the function for the\n            # left child with an increased level\n            self.recursionRight(root.left, level + 1, res)\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.left.left = Node(4)\nroot.left.right = Node(10)\nroot.left.left.right = Node(5)\nroot.left.left.right.right = Node(6)\nroot.right = Node(3)\nroot.right.right = Node(10)\nroot.right.left = Node(9)\n\nsolution = Solution()\n\n# Get the Right View traversal\nrightView = solution.rightsideView(root)\n\n# Print the result for Right View\nprint(&quot;Right View Traversal:&quot;, end=&quot; &quot;)\nfor node in rightView:\n    print(node, end=&quot; &quot;)\nprint()\n\n# Get the Left View traversal\nleftView = solution.leftsideView(root)\n\n# Print the result for Left View\nprint(&quot;Left View Traversal:&quot;, end=&quot; &quot;)\nfor node in leftView:\n    print(node, end=&quot; &quot;)\nprint()\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node class for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to return the\n    // Right view of the binary tree\n    rightsideView(root) {\n        // Array to store the result\n        const res = [];\n\n        // Call the recursive function\n        // to populate the right-side view\n        this.recursionRight(root, 0, res);\n\n        return res;\n    }\n\n    // Function to return the\n    // Left view of the binary tree\n    leftsideView(root) {\n        // Array to store the result\n        const res = [];\n\n        // Call the recursive function\n        // to populate the left-side view\n        this.recursionLeft(root, 0, res);\n\n        return res;\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the left-side view\n    recursionLeft(root, level, res) {\n        // Check if the current node is null\n        if (!root) {\n            return;\n        }\n\n        // Check if the size of the result array\n        // is equal to the current level\n        if (res.length === level) {\n            // If equal, add the value of the\n            // current node to the result array\n            res.push(root.data);\n        }\n\n        // Recursively call the function for the\n        // left child with an increased level\n        this.recursionLeft(root.left, level + 1, res);\n\n        // Recursively call the function for the\n        // right child with an increased level\n        this.recursionLeft(root.right, level + 1, res);\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the right-side view\n    recursionRight(root, level, res) {\n        // Check if the current node is null\n        if (!root) {\n            return;\n        }\n\n        // Check if the size of the result array\n        // is equal to the current level\n        if (res.length === level) {\n            // If equal, add the value of the\n            // current node to the result array\n            res.push(root.data);\n\n            // Recursively call the function for the\n            // right child with an increased level\n            this.recursionRight(root.right, level + 1, res);\n\n            // Recursively call the function for the\n            // left child with an increased level\n            this.recursionRight(root.left, level + 1, res);\n        }\n    }\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.left.left = new Node(4);\nroot.left.right = new Node(10);\nroot.left.left.right = new Node(5);\nroot.left.left.right.right = new Node(6);\nroot.right = new Node(3);\nroot.right.right = new Node(10);\nroot.right.left = new Node(9);\n\nconst solution = new Solution();\n\n// Get the Right View traversal\nconst rightView = solution.rightsideView(root);\n\n// Print the result for Right View\nconsole.log(&quot;Right View Traversal:&quot;, rightView.join(&quot; &quot;));\n\n// Get the Left View traversal\nconst leftView = solution.leftsideView(root);\n\n// Print the result for Left View\nconsole.log(&quot;Left View Traversal:&quot;, leftView.join(&quot; &quot;));\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                           <strong>Output: </strong>Right View Traversal: 1 3 10, Left View Traversal: 1 2 4 5 6 </p>\n\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N)</strong> where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.</p>\n\n                        <p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.</p>\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n    <!-- Approach - 1 Ends here -->\n\n\n    <!-- Approach - 2 Starts from here -->\n\n    <div id=\"optimal-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    Optimal Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        <p>To get the left and right view of a Binary Tree, we perform a depth-first traversal of the Binary Tree while keeping track of the level of each node. For both the left and right view, we\u2019ll ensure that only the first node encountered at each level is added to the result vector.</p>\n                        \n                        <p><strong>Algorithm for Left View</strong></p>\n                        <p><strong>Step 1: </strong>Initialise an empty vector `res` to store the left view nodes.</p>\n                        \n                        <p><strong>Step 2: </strong>Implement a recursive depth-first traversal of the binary tree. </p>\n                        <p><strong>Base Case: </strong>Check if the current node is null, if true, return the function as we have reached the end of that particular vertical level.</p>\n                        <p><strong>Recursive Function: </strong>The recursive function takes in arguments the current node of the Binary Tree, its current level and the result vector.\n                        <ol><li>We check if the size of the result vector is equal to the current level.</li><li>If true, it means that we have not yet encountered any node at this level in the result vector. Add the value of the current node to the result vector.</li><li>Recursively call the function for the current nodes left then right child with an increased level ie. level + 1.</li><li>We call the left child first as we want to traverse the left most nodes. In cases where there is no left child, the recursion function backtracks and explores the right child.</li></ol></p>\n                        \n                        <p><strong>Step 3: </strong>The recursion continues until it reaches the base case. Return the result vector at the end.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image9-xjy_h8re\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n\n                        <p><strong>Algorithm for Right View</strong></p>\n                        <p><strong>Step 1: </strong>Initialise an empty vector `res` to store the left view nodes.</p>\n                        \n                        <p><strong>Step 2: </strong>Implement a recursive depth-first traversal of the binary tree. </p>\n                        <p><strong>Base Case: </strong>Check if the current node is null, if true, return the function as we have reached the end of that particular vertical level.</p>\n                        <p><strong>Recursive Function: </strong>The recursive function takes in arguments the current node of the Binary Tree, its current level and the result vector.\n                        <ol><li>We check if the size of the result vector is equal to the current level.</li><li>If true, it means that we have not yet encountered any node at this level in the result vector. Add the value of the current node to the result vector.</li><li>Recursively call the function for the current nodes right then left child with an increased level ie. level + 1.</li><li>We call the right child first as we want to traverse the right most nodes. In cases where there is no right child, the recursion function backtracks and explores the left child.</li></ol></p>\n                        \n                        <p><strong>Step 3: </strong>The recursion continues until it reaches the base case. Return the result vector at the end.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/right-left-tree-image10-bDzTVkfD\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;set&gt;\n#include &lt;queue&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\n// Node structure for the binary tree\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    // Function to return the Right view of the binary tree\n    vector&lt;int&gt; rightsideView(Node* root){\n        // Vector to store the result\n        vector&lt;int&gt; res;\n        \n        // Call the recursive function\n        // to populate the right-side view\n        recursionRight(root, 0, res);\n        \n        return res;\n    }\n    \n    // Function to return the Left view of the binary tree\n    vector&lt;int&gt; leftsideView(Node* root){\n        // Vector to store the result\n        vector&lt;int&gt; res;\n        \n        // Call the recursive function\n        // to populate the left-side view\n        recursionLeft(root, 0, res);\n        \n        return res;\n    }\n\nprivate:\n    // Recursive function to traverse the\n    // binary tree and populate the left-side view\n    void recursionLeft(Node* root, int level, vector&lt;int&gt;&amp; res){\n        // Check if the current node is NULL\n        if(root == NULL){\n            return;\n        }\n        \n        // Check if the size of the result vector\n        // is equal to the current level\n        if(res.size() == level){\n            // If equal, add the value of the\n            // current node to the result vector\n            res.push_back(root-&gt;data);\n        }\n        \n        // Recursively call the function for the\n        // left child with an increased level\n        recursionLeft(root-&gt;left, level + 1, res);\n        \n        // Recursively call the function for the\n        // right child with an increased level\n        recursionLeft(root-&gt;right, level + 1, res);\n    }\n    \n    // Recursive function to traverse the\n    // binary tree and populate the right-side view\n    void recursionRight(Node* root, int level, vector&lt;int&gt; &amp;res){\n        // Check if the current node is NULL\n        if(root == NULL){\n            return;\n        }\n        \n        // Check if the size of the result vector\n        // is equal to the current level\n        if(res.size() == level){\n            // If equal, add the value of the\n            // current node to the result vector\n            res.push_back(root-&gt;data);\n            \n            // Recursively call the function for the\n            // right child with an increased level\n            recursionRight(root-&gt;right, level + 1, res);\n            \n            // Recursively call the function for the\n            // left child with an increased level\n            recursionRight(root-&gt;left, level + 1, res);\n        }\n    }\n};\n\n\n\nint main() {\n    // Creating a sample binary tree\n    Node* root = new Node(1);\n    root-&gt;left = new Node(2);\n    root-&gt;left-&gt;left = new Node(4);\n    root-&gt;left-&gt;right = new Node(10);\n    root-&gt;left-&gt;left-&gt;right = new Node(5);\n    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);\n    root-&gt;right = new Node(3);\n    root-&gt;right-&gt;right = new Node(10);\n    root-&gt;right-&gt;left = new Node(9);\n\n    Solution solution;\n\n        // Get the Right View traversal\n    vector&lt;int&gt; rightView = solution.rightsideView(root);\n\n    // Print the result for Right View\n    cout &lt;&lt; &quot;Right View Traversal: &quot;;\n    for(auto node: rightView){\n        cout &lt;&lt; node &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n\n    // Get the Left View traversal\n    vector&lt;int&gt; leftView = solution.leftsideView(root);\n\n    // Print the result for Left View\n    cout &lt;&lt; &quot;Left View Traversal: &quot;;\n    for(auto node: leftView){\n        cout &lt;&lt; node &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.ArrayList;\nimport java.util.List;\n\n// Node structure for the binary tree\nclass Node {\n    int data;\n    Node left;\n    Node right;\n\n    // Constructor to initialize\n    // the node with a value\n    Node(int val) {\n        data = val;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n\n    // Function to return the Right view of the binary tree\n    public List&lt;Integer&gt; rightsideView(Node root) {\n        // List to store the result\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n\n        // Call the recursive function\n        // to populate the right-side view\n        recursionRight(root, 0, res);\n\n        return res;\n    }\n\n    // Function to return the Left view of the binary tree\n    public List&lt;Integer&gt; leftsideView(Node root) {\n        // List to store the result\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n\n        // Call the recursive function\n        // to populate the left-side view\n        recursionLeft(root, 0, res);\n\n        return res;\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the left-side view\n    private void recursionLeft(Node root, int level, List&lt;Integer&gt; res) {\n        // Check if the current node is null\n        if (root == null) {\n            return;\n        }\n\n        // Check if the size of the result list\n        // is equal to the current level\n        if (res.size() == level) {\n            // If equal, add the value of the\n            // current node to the result list\n            res.add(root.data);\n        }\n\n        // Recursively call the function for the\n        // left child with an increased level\n        recursionLeft(root.left, level + 1, res);\n\n        // Recursively call the function for the\n        // right child with an increased level\n        recursionLeft(root.right, level + 1, res);\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the right-side view\n    private void recursionRight(Node root, int level, List&lt;Integer&gt; res) {\n        // Check if the current node is null\n        if (root == null) {\n            return;\n        }\n\n        // Check if the size of the result list\n        // is equal to the current level\n        if (res.size() == level) {\n            // If equal, add the value of the\n            // current node to the result list\n            res.add(root.data);\n\n            // Recursively call the function for the\n            // right child with an increased level\n            recursionRight(root.right, level + 1, res);\n\n            // Recursively call the function for the\n            // left child with an increased level\n            recursionRight(root.left, level + 1, res);\n        }\n    }\n\n    public static void main(String[] args) {\n        // Creating a sample binary tree\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.left.left = new Node(4);\n        root.left.right = new Node(10);\n        root.left.left.right = new Node(5);\n        root.left.left.right.right = new Node(6);\n        root.right = new Node(3);\n        root.right.right = new Node(10);\n        root.right.left = new Node(9);\n\n        Solution solution = new Solution();\n\n        // Get the Right View traversal\n        List&lt;Integer&gt; rightView = solution.rightsideView(root);\n\n        // Print the result for Right View\n        System.out.print(&quot;Right View Traversal: &quot;);\n        for (int node : rightView) {\n            System.out.print(node + &quot; &quot;);\n        }\n        System.out.println();\n\n        // Get the Left View traversal\n        List&lt;Integer&gt; leftView = solution.leftsideView(root);\n\n        // Print the result for Left View\n        System.out.print(&quot;Left View Traversal: &quot;);\n        for (int node : leftView) {\n            System.out.print(node + &quot; &quot;);\n        }\n        System.out.println();\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n                     \n# Node class for the binary tree\nclass Node:\n    def __init__(self, val):\n        self.data = val\n        self.left = None\n        self.right = None\n\n# Solution class to get the left\n# and right view of the binary tree\nclass Solution:\n    def rightsideView(self, root):\n        # Vector to store the result\n        res = []\n        \n        # Call the recursive function\n        # to populate the right-side view\n        self.recursionRight(root, 0, res)\n        \n        return res\n\n    def leftsideView(self, root):\n        # Vector to store the result\n        res = []\n        \n        # Call the recursive function\n        # to populate the left-side view\n        self.recursionLeft(root, 0, res)\n        \n        return res\n\n    # Recursive function to traverse the\n    # binary tree and populate the left-side view\n    def recursionLeft(self, root, level, res):\n        # Check if the current node is None\n        if not root:\n            return\n        \n        # Check if the size of the result list\n        # is equal to the current level\n        if len(res) == level:\n            # If equal, add the value of the\n            # current node to the result list\n            res.append(root.data)\n        \n        # Recursively call the function for the\n        # left child with an increased level\n        self.recursionLeft(root.left, level + 1, res)\n        \n        # Recursively call the function for the\n        # right child with an increased level\n        self.recursionLeft(root.right, level + 1, res)\n\n    # Recursive function to traverse the\n    # binary tree and populate the right-side view\n    def recursionRight(self, root, level, res):\n        # Check if the current node is None\n        if not root:\n            return\n        \n        # Check if the size of the result list\n        # is equal to the current level\n        if len(res) == level:\n            # If equal, add the value of the\n            # current node to the result list\n            res.append(root.data)\n            \n            # Recursively call the function for the\n            # right child with an increased level\n            self.recursionRight(root.right, level + 1, res)\n            \n            # Recursively call the function for the\n            # left child with an increased level\n            self.recursionRight(root.left, level + 1, res)\n\n# Creating a sample binary tree\nroot = Node(1)\nroot.left = Node(2)\nroot.left.left = Node(4)\nroot.left.right = Node(10)\nroot.left.left.right = Node(5)\nroot.left.left.right.right = Node(6)\nroot.right = Node(3)\nroot.right.right = Node(10)\nroot.right.left = Node(9)\n\nsolution = Solution()\n\n# Get the Right View traversal\nrightView = solution.rightsideView(root)\n\n# Print the result for Right View\nprint(&quot;Right View Traversal:&quot;, end=&quot; &quot;)\nfor node in rightView:\n    print(node, end=&quot; &quot;)\nprint()\n\n# Get the Left View traversal\nleftView = solution.leftsideView(root)\n\n# Print the result for Left View\nprint(&quot;Left View Traversal:&quot;, end=&quot; &quot;)\nfor node in leftView:\n    print(node, end=&quot; &quot;)\nprint()\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node class for the binary tree\nclass Node {\n    constructor(val) {\n        this.data = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function to return the\n    // Right view of the binary tree\n    rightsideView(root) {\n        // Array to store the result\n        const res = [];\n\n        // Call the recursive function\n        // to populate the right-side view\n        this.recursionRight(root, 0, res);\n\n        return res;\n    }\n\n    // Function to return the\n    // Left view of the binary tree\n    leftsideView(root) {\n        // Array to store the result\n        const res = [];\n\n        // Call the recursive function\n        // to populate the left-side view\n        this.recursionLeft(root, 0, res);\n\n        return res;\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the left-side view\n    recursionLeft(root, level, res) {\n        // Check if the current node is null\n        if (!root) {\n            return;\n        }\n\n        // Check if the size of the result array\n        // is equal to the current level\n        if (res.length === level) {\n            // If equal, add the value of the\n            // current node to the result array\n            res.push(root.data);\n        }\n\n        // Recursively call the function for the\n        // left child with an increased level\n        this.recursionLeft(root.left, level + 1, res);\n\n        // Recursively call the function for the\n        // right child with an increased level\n        this.recursionLeft(root.right, level + 1, res);\n    }\n\n    // Recursive function to traverse the\n    // binary tree and populate the right-side view\n    recursionRight(root, level, res) {\n        // Check if the current node is null\n        if (!root) {\n            return;\n        }\n\n        // Check if the size of the result array\n        // is equal to the current level\n        if (res.length === level) {\n            // If equal, add the value of the\n            // current node to the result array\n            res.push(root.data);\n\n            // Recursively call the function for the\n            // right child with an increased level\n            this.recursionRight(root.right, level + 1, res);\n\n            // Recursively call the function for the\n            // left child with an increased level\n            this.recursionRight(root.left, level + 1, res);\n        }\n    }\n}\n\n// Creating a sample binary tree\nconst root = new Node(1);\nroot.left = new Node(2);\nroot.left.left = new Node(4);\nroot.left.right = new Node(10);\nroot.left.left.right = new Node(5);\nroot.left.left.right.right = new Node(6);\nroot.right = new Node(3);\nroot.right.right = new Node(10);\nroot.right.left = new Node(9);\n\nconst solution = new Solution();\n\n// Get the Right View traversal\nconst rightView = solution.rightsideView(root);\n\n// Print the result for Right View\nconsole.log(&quot;Right View Traversal:&quot;, rightView.join(&quot; &quot;));\n\n// Get the Left View traversal\nconst leftView = solution.leftsideView(root);\n\n// Print the result for Left View\nconsole.log(&quot;Left View Traversal:&quot;, leftView.join(&quot; &quot;));                  \n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                             <strong>Output: </strong>Right View Traversal: 1 3 10, Left View Traversal: 1 2 4 5 6 </p>\n\n                        \n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity:  O(log2N)</strong> where N is the number of nodes in the Binary Tree. This complexity arises as we travel along the height of the Binary Tree. For a balanced binary tree, the height is log2N but in the worst case when the tree is skewed, the complexity becomes O(N). </p>\n                        <p><strong>Space Complexity : O(log2N)</strong>   where N is the number of nodes in the Binary Tree. This complexity arises because we store the leftmost and rightmost nodes in an additional vector. The size of this result vector is proportional to the height of the Binary Tree which will be log2N when the tree is balanced and O(N) in the worst case of a skewed tree.\n                        <ol><li>O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree. </li><li>The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.</li></ol> </p>\n\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KV4mRzTjlAk?si=SxrGZ92mA1SSlTh3\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n        </div>\n    </details>\n</div>\n\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}