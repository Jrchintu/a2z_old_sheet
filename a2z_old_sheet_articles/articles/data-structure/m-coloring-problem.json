{
    "dislikes": 8,
    "video": "wuVwUK25Rfc",
    "publishedOn": "Sun Mar 24 2024 22:09:24 GMT+0530 (India Standard Time)",
    "slug": "m-coloring-problem",
    "aid": "1480",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/m-coloring-problem",
    "title": "M - Coloring Problem",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "category_tag": "data-structure",
    "likes": 69,
    "preview": "Problem Statement: Given an undirected graph and a number m, determine if the graph can be colored with at most m colors such that no two adjacent vertices of the graph are colored with the same co...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong> Given an undirected graph and a number m, determine if the graph can be colored with at most m colors such that no two adjacent vertices of the graph are colored with the same color.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Example 1:</strong>\n<strong>Input: </strong>\nN = 4\nM = 3\nE = 5\nEdges[] = {\n  (0, 1),\n  (1, 2),\n  (2, 3),\n  (3, 0),\n  (0, 2)\n}\n\n<strong>Output:</strong> 1\n\n<strong>Explanation:</strong> It is possible to colour the given graph using 3 colours.\n\n<strong>Example 2:</strong>\n\n<strong>Input:</strong> \nN = 3\nM = 2\nE = 3\nEdges[] = {\n  (0, 1),\n  (1, 2),\n  (0, 2)\n}\n\n<strong>Output:</strong> 0\n\n\n<strong>Explanation:</strong> It is not possible to color.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution 1: Backtracking</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach</strong>: </p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Basically starting from vertex 0 color one by one the different vertices.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Base condition:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>If I have colored all the N nodes return true.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Recursion:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Trying every color from 1 to m with the help of a for a loop.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Is safe function returns true if it is possible to color it with that color i.e none of the adjacent nodes have the same color.<br><br>In case this is an algorithm and follows a certain intuition, please mention it.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Color it with color i then call the recursive function for the next node if it returns true we will return true.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>And If it is false then take off the color.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now if we have tried out every color from 1 to m and it was not possible to color it with any of the m colors then return false.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include&lt;bits/stdc++.h&gt;\n\nusing namespace std;\nbool isSafe(int node, int color[], bool graph[101][101], int n, int col) {\n  for (int k = 0; k &lt; n; k++) {\n    if (k != node &amp;&amp; graph[k][node] == 1 &amp;&amp; color[k] == col) {\n      return false;\n    }\n  }\n  return true;\n}\nbool solve(int node, int color[], int m, int N, bool graph[101][101]) {\n  if (node == N) {\n    return true;\n  }\n\n  for (int i = 1; i &lt;= m; i++) {\n    if (isSafe(node, color, graph, N, i)) {\n      color[node] = i;\n      if (solve(node + 1, color, m, N, graph)) return true;\n      color[node] = 0;\n    }\n\n  }\n  return false;\n}\n\n//Function to determine if graph can be coloured with at most M colours such\n//that no two adjacent vertices of graph are coloured with same colour.\nbool graphColoring(bool graph[101][101], int m, int N) {\n  int color[N] = {\n    0\n  };\n  if (solve(0, color, m, N, graph)) return true;\n  return false;\n}\n\nint main() {\n  int N = 4;\n  int m = 3;\n\n  bool graph[101][101];\n  memset(graph, false, sizeof graph);\n\n  // Edges are (0, 1), (1, 2), (2, 3), (3, 0), (0, 2)\n  graph[0][1] = 1; graph[1][0] = 1;\n  graph[1][2] = 1; graph[2][1] = 1;\n  graph[2][3] = 1; graph[3][2] = 1;\n  graph[3][0] = 1; graph[0][3] = 1;\n  graph[0][2] = 1; graph[2][0] = 1;\n  \n  cout &lt;&lt; graphColoring(graph, m, N);\n\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> 1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O( N^M) (n raised to m)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\nclass TUF {\n    public static boolean graphColoring(List &lt; Integer &gt; [] G, int[] color, int i, int C) {\n        // Your code here\n        int n = G.length;\n        if (solve(i, G, color, n, C) == true) return true;\n        return false;\n    }\n    private static boolean isSafe(int node, List &lt; Integer &gt; [] G, int[] color, int n, int col) {\n        for (int it: G[node]) {\n            if (color[it] == col) return false;\n        }\n        return true;\n    }\n    private static boolean solve(int node, List &lt; Integer &gt; [] G, int[] color, int n, int m) {\n        if (node == n) return true;\n\n        for (int i = 1; i &lt;= m; i++) {\n            if (isSafe(node, G, color, n, i)) {\n                color[node] = i;\n                if (solve(node + 1, G, color, n, m) == true) return true;\n                color[node] = 0;\n            }\n        }\n        return false;\n    }\n    public static void main(String[] args) {\n        int N = 4, M = 3;\n        List &lt; Integer &gt; [] G = new ArrayList[N];\n        for (int i = 0; i &lt; N; i++) {\n            G[i] = new ArrayList &lt; &gt; ();\n        }\n        G[0].add(1);\n        G[1].add(0);\n        G[1].add(2);\n        G[2].add(1);\n        G[2].add(3);\n        G[3].add(2);\n        G[3].add(0);\n        G[0].add(3);\n        G[0].add(2);\n        G[2].add(0);\n        int[] color = new int[N];\n        boolean ans = graphColoring(G, color, 0, M);\n        if (ans == true)\n            System.out.println(\"1\");\n        else\n            System.out.println(\"0\");\n    }\n}</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> 1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O( N^M) (n raised to m)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block\" data-lang=\"python\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">def isSafe(node, color, graph, n, col):\n    for k in range(n):\n        if k != node and graph[k][node] == 1 and color[k] == col:\n            return False\n    return True\n\n\n\n\ndef solve(node, color, m, N, graph):\n    if node == N:\n        return True\n\n\n    for i in range(1, m + 1):\n        if isSafe(node, color, graph, N, i):\n            color[node] = i\n            if solve(node + 1, color, m, N, graph):\n                return True\n            color[node] = 0\n\n\n    return False\n\n\n# Function to determine if graph can be coloured with at most M colours such\n# that no two adjacent vertices of graph are coloured with same colour.\n\n\n\n\ndef graphColoring(graph, m, N):\n    color = [0] * N\n    if solve(0, color, m, N, graph):\n        return True\n    return False\n\n\n\n\nif __name__ == '__main__':\n    N = 4\n    m = 3\n\n\n    graph = [[0 for i in range(101)] for j in range(101)]\n\n\n    # Edges are (0, 1), (1, 2), (2, 3), (3, 0), (0, 2)\n    graph[0][1] = 1\n    graph[1][0] = 1\n    graph[1][2] = 1\n    graph[2][1] = 1\n    graph[2][3] = 1\n    graph[3][2] = 1\n    graph[3][0] = 1\n    graph[0][3] = 1\n    graph[0][2] = 1\n    graph[2][0] = 1\n\n\n    print(1 if graphColoring(graph, m, N) else 0)\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> 1</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: O( N^M) (n raised to m)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: O(N)</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to\u00a0<a href=\"https://www.linkedin.com/in/rushikeshadhav/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Rushikesh Adhav</strong></a>\u00a0<em>and\u00a0<em><a href=\"https://www.linkedin.com/in/imsudip/\" target=\"_blank\" rel=\"noreferrer noopener\"><strong>Sudip Ghosh</strong></a></em></em>\u00a0for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,\u00a0</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->"
}