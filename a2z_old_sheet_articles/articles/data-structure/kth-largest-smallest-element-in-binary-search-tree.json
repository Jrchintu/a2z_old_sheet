{
    "dislikes": 3,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:12 GMT+0530 (India Standard Time)",
    "slug": "kth-largest-smallest-element-in-binary-search-tree",
    "aid": "1421",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/kth-smallest-and-largest-element-in-bst",
    "title": "Kth largest/smallest element in  Binary Search Tree",
    "topics": [
        {
            "topic-id": "binary-search-tree",
            "topic-title": "Binary Search Tree"
        },
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        }
    ],
    "likes": 77,
    "category_tag": "data-structure",
    "preview": "Problem Statement: Given a Binary Search Tree and an integer \u2018K\u2019. Find and return the \u2018K-th\u2019 smallest and \u2018K-th\u2019 largest element in the given Binary Search Tree. Examples Example 1: Input:Binary Se...",
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Search Tree and an integer \u2018K\u2019. Find and return the \u2018K-th\u2019 smallest and \u2018K-th\u2019 largest element in the given Binary Search Tree.\n</p>\n\n\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n                <span><strong>Input:</strong>Binary Search Tree: 5 3 7 1 4 6 8 -1 2, K =3</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/kth-largest-bst-image1-VBUx7XAe\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Output:</strong> 3rd smallest: 3, 3rd largest: 6</span>\n                <span><strong>Explanation: </strong>All the elements of the BST in the sorted order would be: [1, 2, 3, 4, 5, 6, 7, 8]. From this array is it evident that the index of the Kth smallest element would be K-1 and the index of the Kth largest element would be 1-K or (size of elements) - K. Hence 3rd smallest = 3 and 3rd largest = 6.</span>\n                \n                <span><strong>Example 2:</strong></span>\n                <span><strong>Input:</strong>Binary Search Tree: 8 5 12 4 7 10 14 -1 -1 6 -1 -1 -1 13, K = 4\n\n                </span>\n                <!--<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/lca-tree-image2-kwG05v8u\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>-->\n                <span><strong>Output :</strong> 4th smallest: 7, 4th largest: 10</span>\n                <span><strong>Explanation: </strong>All the elements of the BST in the sorted order would be: [4, 5, 6, 7, 8, 10, 12, 13, 14]. From this array is it evident that the index of the Kth smallest element would be K-1 and the index of the Kth largest element would be 1-K or (size of elements) - K. Hence 4th smallest = 7 and 4th largest = 10. </span>\n                \n\n            </pre>\n        </div>\n    </details>\n</div>\n\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/kth-smallest-node-in-bst_920441?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\" alt=\"code-studio\">\n        </a>\n    </div>\n    \n</div>\n\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out yourself first. </em></p>\n\n\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n    <!-- Approach - 1 Starts from here -->\n    <div id=\"brute-force-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    <!-- Change Name Here -->\n                   Brute Force Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        <p>A brute force approach would be to traverse the BST using an inorder traversal which will get us an array containing all node values in the ascending sorted order. \n                        Following this traversal, we retrieve the Kth smallest element by accessing the element at index k-1 in the array considering array indices start from 0. Similarly to determine the Kth largest element, we can access it at index array.length - k.</p>\n\n                        <p><strong>Algorithm:</strong></p>\n                        <p><strong>Step 1:</strong> Initialise an array to store the elements of the BST. Traverse the BST using an inorder traversal and store each node\u2019s value in the array.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/kth-largest-bst-image3-gCAvKB8e\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 2:</strong>Once the traversal is complete, the array will contain elements in ascending order (due to inorder traversal).\n                        <ol><li>To find the Kth smallest element access the element at index \u2018k - 1\u2019 in the array. (As the indices start from 0).</li><li>To find the Kth largest element access the element at index \u2018array.length - K\u2019 index.</li></ol></p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/kth-largest-bst-image4-pIPgHIzX\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 3:</strong>  Return the pair containing the Kth smallest and the Kth largest elements.</p>\n                        \n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt; \nusing namespace std;\n\n// Definition of TreeNode structure\n// for a binary tree node\nstruct TreeNode {\n    // Value of the node\n    int val;\n    \n    // Pointer to the left child node\n    TreeNode* left;\n    \n    // Pointer to the right child node\n    TreeNode* right;\n\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\nprivate:\n    // Inorder traversal to populate\n    // the vector with BST elements\n    void inorder(TreeNode* node, vector&lt;int&gt;&amp; arr){\n        if(!node){\n            return;\n        }\n        // Recursive call to the left subtree\n        inorder(node-&gt;left, arr);\n        \n        // Push the value of current\n        // node into the vector\n        arr.push_back(node-&gt;val);\n        \n        // Recursive call to the right subtree\n        inorder(node-&gt;right, arr);\n        return;\n    }\npublic:\n    // Function to find the Kth\n    // smallest and largest elements in BST\n    pair&lt;int, int&gt; findKth(TreeNode* node, int k){\n        // Vector to store the\n        // elements of the BST\n        vector&lt;int&gt; arr;\n        \n        // Perform inorder traversal\n        // to populate the vector\n        inorder(node, arr);\n        \n        // Calculate Kth largest\n        // and smallest elements\n        int kLargest = arr[arr.size() - k];\n        int kSmallest = arr[k-1]; \n        \n        // Returning a pair containing\n        // Kth smallest and largest elements\n        return make_pair(kSmallest, kLargest);\n    }\n    \n};\n\n\n\n\n// Function to perform an in-order traversal\n// of a binary tree and print its nodes\nvoid printInOrder(TreeNode* root) {\n    // Check if the current node\n    // is null (base case for recursion)\n    if (root == nullptr) {\n        // If null, return and\n        // terminate the function\n        return;\n    }\n\n    // Recursively call printInOrder\n    // for the left subtree\n    printInOrder(root-&gt;left);\n\n    // Print the value of the current node\n    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;\n\n    // Recursively call printInOrder\n    // for the right subtree\n    printInOrder(root-&gt;right);\n}\n\nint main() {\n    // Creating a BST\n    TreeNode* root = new TreeNode(10);\n    root-&gt;left = new TreeNode(5);\n    root-&gt;right = new TreeNode(13);\n    root-&gt;left-&gt;left = new TreeNode(3);\n    root-&gt;left-&gt;left-&gt;left = new TreeNode(2);\n    root-&gt;left-&gt;left-&gt;right = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(6);\n    root-&gt;left-&gt;right-&gt;right = new TreeNode(9);\n    root-&gt;right-&gt;left = new TreeNode(11);\n    root-&gt;right-&gt;right = new TreeNode(14);\n    \n    cout &lt;&lt; &quot;Binary Search Tree: &quot;&lt;&lt; endl;\n    printInOrder(root);\n    cout &lt;&lt; endl;\n    \n  \n    \n    Solution solution;\n\n    // Find the Kth smallest and largest elements\n    int k = 3; \n    cout &lt;&lt; &quot;k: &quot;&lt;&lt; k &lt;&lt;endl;\n    pair&lt;int, int&gt; kthElements = solution.findKth(root, k);\n\n    cout &lt;&lt; &quot;Kth smallest element: &quot; &lt;&lt; kthElements.first &lt;&lt; endl;\n    cout &lt;&lt; &quot;Kth largest element: &quot; &lt;&lt; kthElements.second &lt;&lt; endl;\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\n// Definition of TreeNode structure\n// for a binary tree node\nclass TreeNode {\n    // Value of the node\n    int val;\n    \n    // Pointer to the left child node\n    TreeNode left;\n    \n    // Pointer to the right child node\n    TreeNode right;\n\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    // Inorder traversal to populate\n    // the vector with BST elements\n    private void inorder(TreeNode node, List<Integer> arr) {\n        if (node == null) {\n            return;\n        }\n        // Recursive call to the left subtree\n        inorder(node.left, arr);\n        \n        // Push the value of current\n        // node into the vector\n        arr.add(node.val);\n        \n        // Recursive call to the right subtree\n        inorder(node.right, arr);\n        return;\n    }\n\n    // Function to find the Kth\n    // smallest and largest elements in BST\n    public List<Integer> findKth(TreeNode node, int k) {\n        // List to store the\n        // elements of the BST\n        List<Integer> arr = new ArrayList<>();\n        \n        // Perform inorder traversal\n        // to populate the vector\n        inorder(node, arr);\n        \n        // Calculate Kth largest\n        // and smallest elements\n        int kLargest = arr.get(arr.size() - k);\n        int kSmallest = arr.get(k - 1); \n        \n        // Returning a list containing\n        // Kth smallest and largest elements\n        return Arrays.asList(kSmallest, kLargest);\n    }\n}\n\npublic class Main {\n    // Function to perform an in-order traversal\n    // of a binary tree and print its nodes\n    private static void printInOrder(TreeNode root) {\n        // Check if the current node\n        // is null (base case for recursion)\n        if (root == null) {\n            // If null, return and\n            // terminate the function\n            return;\n        }\n\n        // Recursively call printInOrder\n        // for the left subtree\n        printInOrder(root.left);\n\n        // Print the value of the current node\n        System.out.print(root.val + \" \");\n\n        // Recursively call printInOrder\n        // for the right subtree\n        printInOrder(root.right);\n    }\n\n    public static void main(String[] args) {\n        // Creating a BST\n        TreeNode root = new TreeNode(10);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(13);\n        root.left.left = new TreeNode(3);\n        root.left.left.left = new TreeNode(2);\n        root.left.left.right = new TreeNode(4);\n        root.left.right = new TreeNode(6);\n        root.left.right.right = new TreeNode(9);\n        root.right.left = new TreeNode(11);\n        root.right.right = new TreeNode(14);\n        \n        System.out.println(\"Binary Search Tree: \");\n        printInOrder(root);\n        System.out.println();\n\n        Solution solution = new Solution();\n\n        // Find the Kth smallest and largest elements\n        int k = 3; \n        System.out.println(\"k: \" + k);\n        List<Integer> kthElements = solution.findKth(root, k);\n\n        System.out.println(\"Kth smallest element: \" + kthElements.get(0));\n        System.out.println(\"Kth largest element: \" + kthElements.get(1));\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n# Definition of TreeNode structure\n# for a binary tree node\nclass TreeNode:\n    # Constructor to initialize the node with a\n    # value and set left and right pointers to null\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    # Inorder traversal to populate\n    # the list with BST elements\n    def inorder(self, node, arr):\n        if not node:\n            return\n        # Recursive call to the left subtree\n        self.inorder(node.left, arr)\n        \n        # Append the value of current\n        # node into the list\n        arr.append(node.val)\n        \n        # Recursive call to the right subtree\n        self.inorder(node.right, arr)\n        return\n\n    # Function to find the Kth\n    # smallest and largest elements in BST\n    def findKth(self, node, k):\n        # List to store the\n        # elements of the BST\n        arr = []\n        \n        # Perform inorder traversal\n        # to populate the list\n        self.inorder(node, arr)\n        \n        # Calculate Kth largest\n        # and smallest elements\n        kLargest = arr[len(arr) - k]\n        kSmallest = arr[k - 1]\n        \n        # Returning a tuple containing\n        # Kth smallest and largest elements\n        return (kSmallest, kLargest)\n\n\n# Function to perform an in-order traversal\n# of a binary tree and print its nodes\ndef printInOrder(root):\n    # Check if the current node\n    # is null (base case for recursion)\n    if not root:\n        # If null, return and\n        # terminate the function\n        return\n    \n    # Recursively call printInOrder\n    # for the left subtree\n    printInOrder(root.left)\n    \n    # Print the value of the current node\n    print(root.val, end=&quot; &quot;)\n\n    # Recursively call printInOrder\n    # for the right subtree\n    printInOrder(root.right)\n\n# Creating a BST\nroot = TreeNode(10)\nroot.left = TreeNode(5)\nroot.right = TreeNode(13)\nroot.left.left = TreeNode(3)\nroot.left.left.left = TreeNode(2)\nroot.left.left.right = TreeNode(4)\nroot.left.right = TreeNode(6)\nroot.left.right.right = TreeNode(9)\nroot.right.left = TreeNode(11)\nroot.right.right = TreeNode(14)\n\nprint(&quot;Binary Search Tree:&quot;)\nprintInOrder(root)\nprint()\n\nsolution = Solution()\n\n# Find the Kth smallest and largest elements\nk = 3\nprint(&quot;k:&quot;, k)\nkthElements = solution.findKth(root, k)\n\nprint(&quot;Kth smallest element:&quot;, kthElements[0])\nprint(&quot;Kth largest element:&quot;, kthElements[1])\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Definition of TreeNode structure\n// for a binary tree node\nclass TreeNode {\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Inorder traversal to populate\n    // the array with BST elements\n    inorder(node, arr){\n        if(!node){\n            return;\n        }\n        // Recursive call to the left subtree\n        this.inorder(node.left, arr);\n        \n        // Push the value of current\n        // node into the array\n        arr.push(node.val);\n        \n        // Recursive call to the right subtree\n        this.inorder(node.right, arr);\n        return;\n    }\n\n    // Function to find the Kth\n    // smallest and largest elements in BST\n    findKth(node, k){\n        // Array to store the\n        // elements of the BST\n        let arr = [];\n        \n        // Perform inorder traversal\n        // to populate the array\n        this.inorder(node, arr);\n        \n        // Calculate Kth largest\n        // and smallest elements\n        let kLargest = arr[arr.length + 1 - k];\n        let kSmallest = arr[k - 1]; \n        \n        // Returning a pair containing\n        // Kth smallest and largest elements\n        return [kSmallest, kLargest];\n    }\n}\n\n// Function to perform an in-order traversal\n// of a binary tree and print its nodes\nfunction printInOrder(root) {\n    // Check if the current node\n    // is null (base case for recursion)\n    if (root === null) {\n        // If null, return and\n        // terminate the function\n        return;\n    }\n\n    // Recursively call printInOrder\n    // for the left subtree\n    printInOrder(root.left);\n\n    // Print the value of the current node\n    console.log(root.val + &quot; &quot;);\n\n    // Recursively call printInOrder\n    // for the right subtree\n    printInOrder(root.right);\n}\n\n// Creating a BST\nlet root = new TreeNode(10);\nroot.left = new TreeNode(5);\nroot.right = new TreeNode(13);\nroot.left.left = new TreeNode(3);\nroot.left.left.left = new TreeNode(2);\nroot.left.left.right = new TreeNode(4);\nroot.left.right = new TreeNode(6);\nroot.left.right.right = new TreeNode(9);\nroot.right.left = new TreeNode(11);\nroot.right.right = new TreeNode(14);\n\nconsole.log(&quot;Binary Search Tree: &quot;);\nprintInOrder(root);\nconsole.log();\n\nlet solution = new Solution();\n\n// Find the Kth smallest and largest elements\nlet k = 3;\nconsole.log(&quot;k: &quot;, k);\nlet kthElements = solution.findKth(root, k);\n\nconsole.log(&quot;Kth smallest element: &quot;, kthElements[0]);\nconsole.log(&quot;Kth largest element: &quot;, kthElements[1]);\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                           <strong>Output: </strong>Binary Search Tree: 2 3 4 5 6 9 10 11 13 14 \n                        </p>\n                        <p>k: 3</p>\n                        <p>Kth smallest element: 4</p>\n                        <p>Kth largest element: 11</p>\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N)</strong>  where N is the number of nodes in the Binary Search Tree. because traversing the entire BST to perform an inorder traversal takes linear time. We visit each node once resulting in time complexity proportional to the number of nodes in the BST.</p>\n\n                        <p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the Binary Search Tree as additional space is required to store the elements of the BST in an array.</p>\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n    <!-- Approach - 1 Ends here -->\n\n\n    <!-- Approach - 2 Starts from here -->\n\n    <div id=\"optimal-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    Optimal Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        <p>A more efficient approach for finding the K-th smallest and K-th largest elements in a Binary Search Tree (BST) without using extra space would involve an optimised traversal technique directly targeting the K-th elements without storing all elements in an array. We use two traversal methods (inorder and reverse inorder) to find the Kth smallest and largest elements in the given BST. We maintain a counter variable to track the number of visited nodes, stopping when the Kth element is found in each traversal.</p>\n                        \n\n                        <p><strong>Algorithm for Kth Smallest Element: </strong></p>\n                        <p><strong>Step 1: </strong> Perform inorder traversal from the root node. At every visited node, increment a counter variable to keep track of visited nodes. Inorder Traversal: Traverse the left subtree, then current node then right subtree.</p>\n                    \n                        <p><strong>Step 2: </strong>When the counter reaches K, store the value of the current node as the Kth smallest.</p>\n                        <p><strong>Step 3: </strong>Return this value as the Kth smallest.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/kth-largest-bst-image5--cdqv18c\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n                    \n                        <p><strong>Algorithm for Kth Largest Element: </strong></p>\n                        <p><strong>Step 1: </strong> Perform reverse inorder traversal from the root node. At every visited node, increment a counter variable to keep track of visited nodes. Traverse the right subtree, then current node then left subtree.</p>\n                    \n                        <p><strong>Step 2: </strong>When the counter reaches K, store the value of the current node as the Kth smallest.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/kth-largest-bst-image6-VuQxVPr9\" alt=\"\" class=\"wp-image-8107\" width=\"600\" height=\"1000\"/></figure>\n                        <p><strong>Step 3: </strong>Return this value as the Kth largest.</p>\n                       \n\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;climits&gt; \nusing namespace std;\n\n// Definition of TreeNode structure\n// for a binary tree node\nstruct TreeNode {\n    // Value of the node\n    int val;\n    \n    // Pointer to the left child node\n    TreeNode* left;\n    \n    // Pointer to the right child node\n    TreeNode* right;\n\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\nprivate:\n    // Helper function to perform reverse inorder\n    // traversal to find Kth largest element\n    void reverseInorder(TreeNode* node, int&amp; counter, int k, int&amp; kLargest) {\n        if (!node || counter &gt;= k) return;\n\n        // Traverse right subtree\n        reverseInorder(node-&gt;right, counter, k, kLargest);\n\n        // Increment counter after\n        // visiting right subtree\n        counter++;\n\n        // Check if current node\n        // is the Kth largest\n        if (counter == k) {\n            kLargest = node-&gt;val;\n            return;\n        }\n\n        // Traverse left subtree if\n        // Kth largest is not found yet\n        reverseInorder(node-&gt;left, counter, k, kLargest);\n    }\n\n    // Helper function to perform inorder\n    // traversal to find Kth smallest element\n    void inorder(TreeNode* node, int&amp; counter, int k, int&amp; kSmallest) {\n        if (!node || counter &gt;= k) return;\n\n        // Traverse left subtree\n        inorder(node-&gt;left, counter, k, kSmallest);\n\n        // Increment counter after visiting left subtree\n        counter++;\n\n        // Check if current node is the Kth smallest\n        if (counter == k) {\n            kSmallest = node-&gt;val;\n            return;\n        }\n\n        // Traverse right subtree if\n        // Kth smallest is not found yet\n        inorder(node-&gt;right, counter, k, kSmallest);\n    }\n\npublic:\n    pair&lt;int, int&gt; findKth(TreeNode* root, int k) {\n        int kSmallest = INT_MIN, kLargest = INT_MIN;\n        // Counter to track visited nodes\n        int counter = 0; \n\n        // Find Kth smallest element\n        // (perform inorder traversal)\n        inorder(root, counter, k, kSmallest);\n        \n        // Reset counter for Kth largest element\n        counter = 0; \n        // Find Kth largest element\n        // (perform reverse inorder traversal)\n        reverseInorder(root, counter, k, kLargest);\n\n        return make_pair(kSmallest, kLargest);\n    }\n};\n\n\n\n\n\n// Function to perform an in-order traversal\n// of a binary tree and print its nodes\nvoid printInOrder(TreeNode* root) {\n    // Check if the current node\n    // is null (base case for recursion)\n    if (root == nullptr) {\n        // If null, return and\n        // terminate the function\n        return;\n    }\n\n    // Recursively call printInOrder\n    // for the left subtree\n    printInOrder(root-&gt;left);\n\n    // Print the value of the current node\n    cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot;;\n\n    // Recursively call printInOrder\n    // for the right subtree\n    printInOrder(root-&gt;right);\n}\n\nint main() {\n    // Creating a BST\n    TreeNode* root = new TreeNode(10);\n    root-&gt;left = new TreeNode(5);\n    root-&gt;right = new TreeNode(13);\n    root-&gt;left-&gt;left = new TreeNode(3);\n    root-&gt;left-&gt;left-&gt;left = new TreeNode(2);\n    root-&gt;left-&gt;left-&gt;right = new TreeNode(4);\n    root-&gt;left-&gt;right = new TreeNode(6);\n    root-&gt;left-&gt;right-&gt;right = new TreeNode(9);\n    root-&gt;right-&gt;left = new TreeNode(11);\n    root-&gt;right-&gt;right = new TreeNode(14);\n    \n    cout &lt;&lt; &quot;Binary Search Tree: &quot;&lt;&lt; endl;\n    printInOrder(root);\n    cout &lt;&lt; endl;\n    \n  \n    \n    Solution solution;\n\n    // Find the Kth smallest and largest elements\n    int k = 3; \n    cout &lt;&lt; &quot;k: &quot;&lt;&lt; k &lt;&lt;endl;\n    pair&lt;int, int&gt; kthElements = solution.findKth(root, k);\n\n    cout &lt;&lt; &quot;Kth smallest element: &quot; &lt;&lt; kthElements.first &lt;&lt; endl;\n    cout &lt;&lt; &quot;Kth largest element: &quot; &lt;&lt; kthElements.second &lt;&lt; endl;\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\n// Definition of TreeNode structure\n// for a binary tree node\nclass TreeNode {\n    // Value of the node\n    int val;\n    \n    // Pointer to the left child node\n    TreeNode left;\n    \n    // Pointer to the right child node\n    TreeNode right;\n\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\nclass Solution {\n    private void reverseInorder(TreeNode node, int[] counter, int k, int[] kLargest) {\n        if (node == null || counter[0] &gt;= k) return;\n\n        // Traverse right subtree\n        reverseInorder(node.right, counter, k, kLargest);\n\n        // Increment counter after\n        // visiting right subtree\n        counter[0]++;\n\n        // Check if current node\n        // is the Kth largest\n        if (counter[0] == k) {\n            kLargest[0] = node.val;\n            return;\n        }\n\n        // Traverse left subtree if\n        // Kth largest is not found yet\n        reverseInorder(node.left, counter, k, kLargest);\n    }\n\n    private void inorder(TreeNode node, int[] counter, int k, int[] kSmallest) {\n        if (node == null || counter[0] &gt;= k) return;\n\n        // Traverse left subtree\n        inorder(node.left, counter, k, kSmallest);\n\n        // Increment counter after visiting left subtree\n        counter[0]++;\n\n        // Check if current node is the Kth smallest\n        if (counter[0] == k) {\n            kSmallest[0] = node.val;\n            return;\n        }\n\n        // Traverse right subtree if\n        // Kth smallest is not found yet\n        inorder(node.right, counter, k, kSmallest);\n    }\n\n    public int[] findKth(TreeNode root, int k) {\n        int[] kSmallest = new int[]{Integer.MIN_VALUE};\n        int[] kLargest = new int[]{Integer.MIN_VALUE};\n        // Counter to track visited nodes\n        int[] counter = new int[]{0};\n\n        // Find Kth smallest element\n        // (perform inorder traversal)\n        inorder(root, counter, k, kSmallest);\n        \n        // Reset counter for Kth largest element\n        counter[0] = 0; \n        // Find Kth largest element\n        // (perform reverse inorder traversal)\n        reverseInorder(root, counter, k, kLargest);\n\n        return new int[]{kSmallest[0], kLargest[0]};\n    }\n}\n\n// Function to perform an in-order traversal\n// of a binary tree and print its nodes\nclass BinaryTree {\n    // Recursive function to perform in-order traversal\n    private void printInOrder(TreeNode root) {\n        // Check if the current node\n        // is null (base case for recursion)\n        if (root == null) {\n            // If null, return and\n            // terminate the function\n            return;\n        }\n\n        // Recursively call printInOrder\n        // for the left subtree\n        printInOrder(root.left);\n\n        // Print the value of the current node\n        System.out.print(root.val + &quot; &quot;);\n\n        // Recursively call printInOrder\n        // for the right subtree\n        printInOrder(root.right);\n    }\n\n    public static void main(String[] args) {\n        // Creating a BST\n        TreeNode root = new TreeNode(10);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(13);\n        root.left.left = new TreeNode(3);\n        root.left.left.left = new TreeNode(2);\n        root.left.left.right = new TreeNode(4);\n        root.left.right = new TreeNode(6);\n        root.left.right.right = new TreeNode(9);\n        root.right.left = new TreeNode(11);\n        root.right.right = new TreeNode(14);\n        \n        System.out.println(&quot;Binary Search Tree: &quot;);\n        new BinaryTree().printInOrder(root);\n        System.out.println();\n        \n        Solution solution = new Solution();\n\n        // Find the Kth smallest and largest elements\n        int k = 3; \n        System.out.println(&quot;k: &quot; + k);\n        int[] kthElements = solution.findKth(root, k);\n\n        System.out.println(&quot;Kth smallest element: &quot; + kthElements[0]);\n        System.out.println(&quot;Kth largest element: &quot; + kthElements[1]);\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n                     \n# Definition of TreeNode class\n# for a binary tree node\nclass TreeNode:\n    def __init__(self, x):\n        # Value of the node\n        self.val = x\n        \n        # Pointer to the left child node\n        self.left = None\n        \n        # Pointer to the right child node\n        self.right = None\n\n# Solution class to find Kth smallest and largest elements\nclass Solution:\n    def __init__(self):\n        pass\n\n    # Helper function to perform reverse inorder\n    # traversal to find Kth largest element\n    def reverse_inorder(self, node, counter, k, k_largest):\n        if not node or counter[0] &gt;= k:\n            return\n        \n        # Traverse right subtree\n        self.reverse_inorder(node.right, counter, k, k_largest)\n\n        # Increment counter after\n        # visiting right subtree\n        counter[0] += 1\n\n        # Check if current node\n        # is the Kth largest\n        if counter[0] == k:\n            k_largest[0] = node.val\n            return\n\n        # Traverse left subtree if\n        # Kth largest is not found yet\n        self.reverse_inorder(node.left, counter, k, k_largest)\n\n    # Helper function to perform inorder\n    # traversal to find Kth smallest element\n    def inorder(self, node, counter, k, k_smallest):\n        if not node or counter[0] &gt;= k:\n            return\n\n        # Traverse left subtree\n        self.inorder(node.left, counter, k, k_smallest)\n\n        # Increment counter after visiting left subtree\n        counter[0] += 1\n\n        # Check if current node is the Kth smallest\n        if counter[0] == k:\n            k_smallest[0] = node.val\n            return\n\n        # Traverse right subtree if\n        # Kth smallest is not found yet\n        self.inorder(node.right, counter, k, k_smallest)\n\n    def find_kth(self, root, k):\n        k_smallest = [float('inf')]\n        k_largest = [float('-inf')]\n        # Counter to track visited nodes\n        counter = [0]\n\n        # Find Kth smallest element\n        # (perform inorder traversal)\n        self.inorder(root, counter, k, k_smallest)\n        \n        # Reset counter for Kth largest element\n        counter[0] = 0\n        # Find Kth largest element\n        # (perform reverse inorder traversal)\n        self.reverse_inorder(root, counter, k, k_largest)\n\n        return k_smallest[0], k_largest[0]\n\n\n# Function to perform an in-order traversal\n# of a binary tree and print its nodes\ndef print_in_order(root):\n    # Check if the current node\n    # is null (base case for recursion)\n    if not root:\n        # If null, return and\n        # terminate the function\n        return\n    \n    # Recursively call printInOrder\n    # for the left subtree\n    print_in_order(root.left)\n\n    # Print the value of the current node\n    print(root.val, end=&quot; &quot;)\n\n    # Recursively call printInOrder\n    # for the right subtree\n    print_in_order(root.right)\n\n# Creating a BST\nroot = TreeNode(10)\nroot.left = TreeNode(5)\nroot.right = TreeNode(13)\nroot.left.left = TreeNode(3)\nroot.left.left.left = TreeNode(2)\nroot.left.left.right = TreeNode(4)\nroot.left.right = TreeNode(6)\nroot.left.right.right = TreeNode(9)\nroot.right.left = TreeNode(11)\nroot.right.right = TreeNode(14)\n\nprint(&quot;Binary Search Tree:&quot;)\nprint_in_order(root)\nprint()\n\nsolution = Solution()\n\n# Find the Kth smallest and largest elements\nk = 3\nprint(&quot;k:&quot;, k)\nkth_elements = solution.find_kth(root, k)\n\nprint(&quot;Kth smallest element:&quot;, kth_elements[0])\nprint(&quot;Kth largest element:&quot;, kth_elements[1])\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Definition of TreeNode structure\n// for a binary tree node\nclass TreeNode {\n    // Constructor to initialize the node with a\n    // value and set left and right pointers to null\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Helper function to perform reverse inorder\n    // traversal to find Kth largest element\n    reverseInorder(node, counter, k, kLargest) {\n        if (!node || counter &gt;= k) return;\n\n        // Traverse right subtree\n        this.reverseInorder(node.right, counter, k, kLargest);\n\n        // Increment counter after\n        // visiting right subtree\n        counter++;\n\n        // Check if current node\n        // is the Kth largest\n        if (counter === k) {\n            kLargest[0] = node.val;\n            return;\n        }\n\n        // Traverse left subtree if\n        // Kth largest is not found yet\n        this.reverseInorder(node.left, counter, k, kLargest);\n    }\n\n    // Helper function to perform inorder\n    // traversal to find Kth smallest element\n    inorder(node, counter, k, kSmallest) {\n        if (!node || counter &gt;= k) return;\n\n        // Traverse left subtree\n        this.inorder(node.left, counter, k, kSmallest);\n\n        // Increment counter after visiting left subtree\n        counter++;\n\n        // Check if current node is the Kth smallest\n        if (counter === k) {\n            kSmallest[0] = node.val;\n            return;\n        }\n\n        // Traverse right subtree if\n        // Kth smallest is not found yet\n        this.inorder(node.right, counter, k, kSmallest);\n    }\n\n    findKth(root, k) {\n        const kSmallest = [Number.MIN_SAFE_INTEGER];\n        const kLargest = [Number.MIN_SAFE_INTEGER];\n        // Counter to track visited nodes\n        let counter = 0;\n\n        // Find Kth smallest element\n        // (perform inorder traversal)\n        this.inorder(root, counter, k, kSmallest);\n\n        // Reset counter for Kth largest element\n        counter = 0;\n        // Find Kth largest element\n        // (perform reverse inorder traversal)\n        this.reverseInorder(root, counter, k, kLargest);\n\n        return [kSmallest[0], kLargest[0]];\n    }\n}\n\n// Function to perform an in-order traversal\n// of a binary tree and print its nodes\nfunction printInOrder(root) {\n    // Check if the current node\n    // is null (base case for recursion)\n    if (root === null) {\n        // If null, return and\n        // terminate the function\n        return;\n    }\n\n    // Recursively call printInOrder\n    // for the left subtree\n    printInOrder(root.left);\n\n    // Print the value of the current node\n    console.log(root.val + &quot; &quot;);\n\n    // Recursively call printInOrder\n    // for the right subtree\n    printInOrder(root.right);\n}\n\n// Creating a BST\nconst root = new TreeNode(10);\nroot.left = new TreeNode(5);\nroot.right = new TreeNode(13);\nroot.left.left = new TreeNode(3);\nroot.left.left.left = new TreeNode(2);\nroot.left.left.right = new TreeNode(4);\nroot.left.right = new TreeNode(6);\nroot.left.right.right = new TreeNode(9);\nroot.right.left = new TreeNode(11);\nroot.right.right = new TreeNode(14);\n\nconsole.log(&quot;Binary Search Tree:&quot;);\nprintInOrder(root);\nconsole.log();\n\nconst solution = new Solution();\n\n// Find the Kth smallest and largest elements\nconst k = 3;\nconsole.log(&quot;k: &quot; + k);\nconst kthElements = solution.findKth(root, k);\n\nconsole.log(&quot;Kth smallest element: &quot; + kthElements[0]);\nconsole.log(&quot;Kth largest element: &quot; + kthElements[1]);\n                    \n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                             <strong>Output: </strong>Binary Search Tree: 2 3 4 5 6 9 10 11 13 14 \n                        </p>\n                        <p>k: 3</p>\n                        <p>Kth smallest element: 4</p>\n                        <p>Kth largest element: 11</p>\n                        \n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N)</strong>  where N is the number of nodes in the Binary Search Tree as we traverse in inorder and reverse inorder fashion to get to the required nodes. We visit each node once resulting in time complexity proportional to the number of nodes in the BST.</p>\n                        <p><strong>Space Complexity :</strong>  as no additional space is allocated or data structures used to store any values.</p>\n\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n           <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/9TJYWh0adfk?si=h83K6K3TEQMSOI95\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n        </div>\n    </details>\n</div>\n\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}