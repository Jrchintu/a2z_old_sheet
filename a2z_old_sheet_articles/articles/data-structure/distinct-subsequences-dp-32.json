{
    "dislikes": 1,
    "video": "nVG7eTiD2bY",
    "publishedOn": "Sun Mar 24 2024 22:10:31 GMT+0530 (India Standard Time)",
    "slug": "distinct-subsequences-dp-32",
    "aid": "1801",
    "title": "Distinct Subsequences| (DP-32)",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/distinct-subsequences",
    "topics": [
        {
            "topic-id": "arrays",
            "topic-title": "Arrays"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "dynamic-programming",
            "topic-title": "Dynamic Programming"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement:</strong>&nbsp;Distinct Subsequences</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Problem Link: </strong><a href=\"https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbmxyQ3hISUZ6X1pTc0hNZGc1UmJOX2o2SXptUXxBQ3Jtc0tuSy13bVhSRlNjZDcxNXcycDQ2R3VXay1vYUh6RXlSXzk3Z2IzNTc1dHVOVGZVR1NLLWV5MW1VdzhjdFNuelJ5cFVmYk9La2puUjA2SzBZSkZVV3E2eUlGWUlQRHZtT2l4cExyR1AteS1yLWtQMlZxOA&amp;q=https%3A%2F%2Fbit.ly%2F3nZNxy7\" target=\"_blank\" rel=\"noreferrer noopener nofollow\"><strong>Subsequence Counting</strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>We are given two strings S1 and S2, we want to know how many distinct subsequences of S2 are present in S1.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:html -->\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n<details class=\"article_example_details\">\n<summary class=\"article_example_summary\">\n<span><strong>\nExamples\n</strong>\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"atricle_example_content\">\n<pre class=\"wp-block-preformatted\"><!-- Insert New Examples Here -->\n<pre class=\"wp-block-preformatted\"><strong>Example:</strong>\n\n<img width=\"458\" height=\"304\" src=\"https://lh4.googleusercontent.com/xo9fySafqrICbnFuGmCaAooWdzSJFDUV0Vm_1-yyA_z23Qega-BRMN0NVWIYrmF9jnDKTKU1I07NhGhT5D5dmJc-5OTYXpzlwTXIseopikjJY-QM8VPJSrmhSaCDyXCZIwF-ABjr\">\n</pre>\n</pre>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Practice Section-->\n<div class=\"practice\">\n<span><strong>Practice: </strong></span>\n<div class=\"problem-buttons\">\n\n<!-- Add Problem Link inside href -->\n<a href=\"https://www.codingninjas.com/studio/problems/subsequence-counting_3755256?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n<span>Solve Problem</span>\n<img src=\"https://static.takeuforward.org/wp/uploads/2023/04/Group-11-5.png\" alt=\"code-studio\">\n</a>\n</div>\n</div>\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\nyourself first. </em></p>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<div class=\"horizontal_navbar_dsa_article\">\n<div class=\"grid_container_three\">\n<a href=\"#brute-force-approach\" class=\"three-boxes box-a\">\nMemoization approach\n</a>\n<a href=\"#better-approach\" class=\"three-boxes box-b\">\nTabulation approach\n</a>\n<a href=\"#optimal-approach\" class=\"three-boxes box-c\">\nSpace Optimization\n</a>\n<a href=\"#dsa_article_video_explanation\" class=\"three-boxes box-d\">\n<svg width=\"26\" height=\"26\" viewBox=\"0 0 20 14\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z\" fill=\"red\"></path>\n</svg>\n\n</a>\n<div class=\"box-e tooltip\">\n<svg viewBox=\"0 0 20 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z\" fill=\"black\"></path>\n</svg>\n<div class=\"bottom\">\n<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,\ncloses all other expands. You can manually expand more than one approach at a time</p>\n<i></i>\n</div>\n\n</div>\n</div>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n<!-- Brute Force Approach Starts from here -->\n<div id=\"brute-force-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nMemoization Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n<p>We have to find distinct subsequences of S2 in S1. As there is no uniformity in data, there is no other way to find out than to <strong>try out all possible ways</strong>. To do so we will need to use <strong>recursion</strong>.</p>\n<p><strong>Steps to form the recursive solution:&nbsp;</strong></p>\n<p>We will first form the recursive solution by the three points mentioned in the <a href=\"https://takeuforward.org/data-structure/dynamic-programming-introduction/\" target=\"_blank\" rel=\"noreferrer noopener\">Dynamic Programming Introduction</a>.&nbsp;</p>\n<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>\n<p>We are given two strings. We can represent them with the help of two indexes i and j. Initially, i=n-1 and j=m-1, where n and m are lengths of strings S1 and S2. Initially, we will call f(n-1,j-1), which means the count of all subsequences of string S2[0\u2026m-1] in string S1[0\u2026n-1]. We can generalize it as follows:</p>\n<p><img width=\"579\" height=\"87\" src=\"https://lh5.googleusercontent.com/J7lvKCuhgX2rh2zF8qRWCCgnGucSXWG5jRUuFGy2VFORQXfOM6kl4mWHhwKRGUq0JWCH7YO4W3OpJajo7bUxwZ5ZYDQv10ALbFNsvzp8Dtf95WQiWuVurS_Zrlg54QImgsYn1LCl\"></p>\n<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>\n<p>Now, i and j represent two characters from strings S1 and S2 respectively. We want to find distinct subsequences. There are only two options that make sense: either the characters represented by i and j match or they don\u2019t.</p>\n<p><strong>Case 1: When the characters match</strong></p>\n<p><strong>if(S1[i]==S2[j])</strong>, let\u2019s understand it with the following example:</p>\n<p><img width=\"182\" height=\"186\" src=\"https://lh4.googleusercontent.com/0EI17GLO1SHm89AdUypq09qE5JelMuh4R9FN_h_AUl6s6bPCkgH1oTTCgM8oCUgyMQQgtAh-YVNeJ4GrjwiXHf7FaatJ4rBm1GAUNX8_6SIy5CfET8-S1M5nVPhicslmgCveP89d\"></p>\n<p>S1[i] == S2[j], now as the characters at i and j match, we would want to check the possibility of the remaining characters of S2 in S1 therefore we reduce the length of both the strings by 1 and call the function recursively.</p>\n<p><img width=\"526\" height=\"439\" src=\"https://lh5.googleusercontent.com/TzWbDBVCoVEa2s1IwkyXXguU1qs48QlZp3jE_e6DLbbisyPwtFuDYPSbxvbtbM06HAhfoNkYGvBMHpqYZwMHLogS4C7Z4HgSwVZAZ2vi-cr_nbjpp5uz2W921BRE2cIOaoD6RyZa\"></p>\n<p>Now, if we only make the above single recursive call, we are rejecting the opportunities to find more than one subsequences because it can happen that the jth character may match with more characters in S1[0\u2026i-1], for example where there are more occurrences of \u2018g\u2019 in S1 from which also an answer needs to be explored.</p>\n<p><img width=\"527\" height=\"281\" src=\"https://lh3.googleusercontent.com/4MX-5_vIorB5c7wCTl3GFVXn2bORpYfBzBcliFi0q_qRIrvCBFL_EIk3lxpFnbbmLEqMtmh6BP5gmoviOIGiMJjSBR1tFF7KRVU9EUeQ2WBQ2ZHTKRXNMaO7n0HXlfo4gToQbgln\"></p>\n<p>To explore all such possibilities, we make another recursive call in which we reduce the length of the S1 string by 1 but keep the S2 string the same, i.e we call f(i-1,j).</p>\n<p><img width=\"527\" height=\"433\" src=\"https://lh4.googleusercontent.com/AxbPsD141koyb5TDBHaGyoFLamxWUCs_UOMgayl10M6TKq1AZUBL77aPfQhVj7efUgFXqj1lI2O1CBcrbtGw-q1rqkmsa8lKVV7si79HtABJfX_3HlnUi5vCnUeECMk0KshJa6LY\"></p>\n<p><strong>Case 2: When the characters don\u2019t match</strong></p>\n<p><strong>if(S1[i] != S2[j]), </strong>it means that we don\u2019t have any other choice than to try the next character of S1 and match it with the current character S2.</p>\n<p><img width=\"257\" height=\"594\" src=\"https://lh5.googleusercontent.com/0UhxnkMwFa8KWMkZ-iD7923-2H4_jDcN2D7r53FgCbnBzm6Ys-A4KJSQLXjzj6jAAlqMJdI9qvnZA3dYiuIBct__M-7MAhGDMKHsOF0o5s1jzWqcVd2STLTDFpFHp0yaNEHS-dmO\"></p>\n<p>This can be summarized as :</p>\n<ul><li><strong>if(S1[i]==S2[j]), </strong>call f(i-1,j-1) and f(i-1,j).</li><li><strong>if(S1[i]!=S2[j]), </strong>call f(i-1,j).</li></ul>\n<p><strong>Step 3:&nbsp; Return the sum of choices&nbsp;</strong></p>\n<p>As we have to return the total count, we will return the <strong>sum</strong> of f(i-1,j-1) and f(i-1,j) in case 1 and simply return f(i-1,j) in case 2.&nbsp;</p>\n<p><strong>Base Cases:</strong></p>\n<p>We are reducing i and j in our recursive relation, there can be two possibilities, either i becomes -1 or j becomes -1.</p>\n<ul><li>if j&lt;0, it means we have matched all characters of S2 with characters of S1, so we return 1.</li><li>if i&lt;0, it means we have checked all characters of S1 but we are not able to match all characters of S2, therefore we return 0.</li></ul>\n<p>The final pseudocode after steps 1, 2, and 3:</p>\n<p><img width=\"481\" height=\"521\" src=\"https://lh4.googleusercontent.com/N73r8VcJ0n0lOM_z1uIPvLE_TQYX1_0p2jDL7R-D7hX6c5krmFYhMDxVDYm-9-u6GCRitcqtaCTBz0Z8wSfK7GnuxA_6EId2FSM-EBTBreUJXyzzO_26mnMgB7QUaH4g-YgT8iRp\"></p>\n<p><strong>Steps to memoize a recursive solution:</strong></p>\n<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>\n<ol><li>Create a dp array of size [n][m]. The size of S1 and S2 are n and m respectively, so the variable i will always lie between \u20180\u2019 and \u2018n-1\u2019 and the variable j between \u20180\u2019 and \u2018m-1\u2019.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li></ol>\n<!-- /wp:list -->\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\nconst int prime = 1e9 + 7;\n\n// Function to count the number of distinct subsequences of s2 in s1\nint countUtil(string s1, string s2, int ind1, int ind2, vector&lt;vector&lt;int>>&amp; dp) {\n    // If s2 has been completely matched, return 1 (found a valid subsequence)\n    if (ind2 &lt; 0)\n        return 1;\n    \n    // If s1 has been completely traversed but s2 hasn't, return 0\n    if (ind1 &lt; 0)\n        return 0;\n\n    // If the result for this state has already been calculated, return it\n    if (dp[ind1][ind2] != -1)\n        return dp[ind1][ind2];\n\n    int result = 0;\n\n    // If the characters match, consider two options: either leave one character in s1 and s2\n    // or leave one character in s1 and continue matching s2\n    if (s1[ind1] == s2[ind2]) {\n        int leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);\n        int stay = countUtil(s1, s2, ind1 - 1, ind2, dp);\n\n        result = (leaveOne + stay) % prime;\n    } else {\n        // If characters don't match, just leave one character in s1 and continue matching s2\n        result = countUtil(s1, s2, ind1 - 1, ind2, dp);\n    }\n\n    // Store the result and return it\n    dp[ind1][ind2] = result;\n    return result;\n}\n\n// Function to count the number of distinct subsequences of s2 in s1\nint subsequenceCounting(string &amp;s1, string &amp;s2, int lt, int ls) {\n    vector&lt;vector&lt;int>> dp(lt, vector&lt;int>(ls, -1));\n    return countUtil(s1, s2, lt - 1, ls - 1, dp);\n}\n\nint main() {\n    string s1 = \"babgbag\";\n    string s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    cout &lt;&lt; \"The Count of Distinct Subsequences is \" &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    static int prime = (int) (Math.pow(10, 9) + 7);\n\n    // Function to count the number of distinct subsequences of s1 that are equal to s2\n    static int countUtil(String s1, String s2, int ind1, int ind2, int[][] dp) {\n        // If we have exhausted s2, there's one valid subsequence (empty string) in s1.\n        if (ind2 &lt; 0)\n            return 1;\n        // If we have exhausted s1 but not s2, there are no valid subsequences.\n        if (ind1 &lt; 0)\n            return 0;\n\n        // If the result is already computed, return it.\n        if (dp[ind1][ind2] != -1)\n            return dp[ind1][ind2];\n\n        // If the characters at the current positions match, we can either leave one character from s1\n        // or continue to the next character in s1 while staying at the same character in s2.\n        if (s1.charAt(ind1) == s2.charAt(ind2)) {\n            int leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);\n            int stay = countUtil(s1, s2, ind1 - 1, ind2, dp);\n\n            // Add the two possibilities and take modulo prime to avoid integer overflow.\n            return dp[ind1][ind2] = (leaveOne + stay) % prime;\n        } else {\n            // If the characters don't match, we can only continue to the next character in s1.\n            return dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp);\n        }\n    }\n\n    // Function to calculate the count of distinct subsequences of s1 equal to s2\n    static int subsequenceCounting(String s1, String s2, int lt, int ls) {\n        // Initialize a DP array to store intermediate results\n        int dp[][] = new int[lt][ls];\n        for (int rows[] : dp)\n            Arrays.fill(rows, -1);\n\n        // Call the recursive helper function to compute the count\n        return countUtil(s1, s2, lt - 1, ls - 1, dp);\n    }\n\n    public static void main(String args[]) {\n        String s1 = \"babgbag\";\n        String s2 = \"bag\";\n\n        System.out.println(\"The Count of Distinct Subsequences is \" +\n                subsequenceCounting(s1, s2, s1.length(), s2.length()));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nprime = int(1e9 + 7)\n\n# Recursive function to count distinct subsequences of s1 that match s2\ndef countUtil(s1, s2, ind1, ind2, dp):\n    # If we have exhausted s2, we found a valid subsequence\n    if ind2 &lt; 0:\n        return 1\n    # If we have exhausted s1, but not s2, no valid subsequence found\n    if ind1 &lt; 0:\n        return 0\n    \n    # If this subproblem has already been solved, return the cached result\n    if dp[ind1][ind2] != -1:\n        return dp[ind1][ind2]\n    \n    # If the current characters match, we can either choose to leave one character\n    # or stay with the current character in s1\n    if s1[ind1] == s2[ind2]:\n        leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp)\n        stay = countUtil(s1, s2, ind1 - 1, ind2, dp)\n        \n        # Store the result in the DP table and return it modulo prime\n        dp[ind1][ind2] = (leaveOne + stay) % prime\n        return dp[ind1][ind2]\n    else:\n        # If the characters don't match, we can only skip the character in s1\n        dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp)\n        return dp[ind1][ind2]\n    \n# Main function to count distinct subsequences of s1 that match s2\ndef subsequenceCounting(s1, s2, lt, ls):\n    # Initialize a DP table to store intermediate results\n    dp = [[-1 for j in range(ls)] for i in range(lt)]\n    \n    # Call the recursive function to count distinct subsequences\n    return countUtil(s1, s2, lt - 1, ls - 1, dp)\n\ndef main():\n    s1 = \"babgbag\"\n    s2 = \"bag\"\n\n    # Calculate and print the count of distinct subsequences\n    print(\"The Count of Distinct Subsequences is\", subsequenceCounting(s1, s2, len(s1), len(s2)))\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nconst prime = 1e9 + 7;\n\n// Function to count the distinct subsequences\nfunction countUtil(s1, s2, ind1, ind2, dp) {\n    // If ind2 goes below 0, we have found a valid subsequence\n    if (ind2 &lt; 0) {\n        return 1;\n    }\n    // If ind1 goes below 0, there are no more characters in s1 to form a subsequence\n    if (ind1 &lt; 0) {\n        return 0;\n    }\n\n    // Check if the result for the current indices is already calculated\n    if (dp[ind1][ind2] !== -1) {\n        return dp[ind1][ind2];\n    }\n\n    // If the characters at ind1 in s1 and ind2 in s2 match\n    if (s1[ind1] === s2[ind2]) {\n        // We have two choices: either leave one character in s1 and s2 and continue searching,\n        // or leave one character in s1 and s2 and one character in s1, but we need to add them modulo prime\n        const leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);\n        const stay = countUtil(s1, s2, ind1 - 1, ind2, dp);\n\n        // Store the result in dp and return\n        return (dp[ind1][ind2] = (leaveOne + stay) % prime);\n    } else {\n        // If the characters do not match, we can only leave one character in s1 and continue searching\n        return (dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp));\n    }\n}\n\n// Function to count the distinct subsequences\nfunction subsequenceCounting(s1, s2) {\n    const lt = s1.length;\n    const ls = s2.length;\n\n    // Create a 2D array to store dynamic programming values\n    const dp = new Array(lt).fill(null).map(() => new Array(ls).fill(-1));\n\n    // Start the counting process from the end of both strings\n    return countUtil(s1, s2, lt - 1, ls - 1, dp);\n}\n\n// Main function\nfunction main() {\n    const s1 = \"babgbag\";\n    const s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    console.log(\"The Count of Distinct Subsequences is \" + subsequenceCounting(s1, s2));\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Brute Force Here -->\n<p><strong>Output:</strong> The Count of Distinct Subsequences is 5\n\n\n</p>\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n<!-- Insert Time and Space Complexity of Brute Force Here -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are N*M states therefore at max \u2018N*M\u2019 new problems will be solved.</p>\n<p><strong>Space Complexity: O(N*M) + O(N+M)</strong></p>\n<p>Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Brute Force Approach Ends here -->\n\n\n<!-- Better Approach Starts from here -->\n\n<div id=\"better-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nTabulation Approach\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm / Intuition For Better Approach Here -->\n<p>In the recursive logic, we set the base case too if(i&lt;0 ) and if(j&lt;0) but we can\u2019t set the dp array\u2019s index to -1. Therefore a hack for this issue is to shift every index by 1 towards the right.</p>\n<p><img width=\"454\" height=\"109\" src=\"https://lh5.googleusercontent.com/gqDQ9sx30aaeDDIFYfHog_x1eDQR1-nibDqGeOcV-vlsol8N5uoa8CMHBrFBp4oRhEIiQQHcYttgZuO1po0NaiLAVhQaYh9h1CKuYMKhFJoBPluGfiVOV8sfvBzdoKnTbxBXFok4\"></p>\n<ul><li>First we initialize the dp array of size [n+1][m+1] as zero.</li><li>Next, we set the base condition (keep in mind 1-based indexing), we set the first column\u2019s value as 1 and the first row as 1.</li><li>Similarly, we will implement the recursive code by keeping in mind the shifting of indexes, therefore S1[i] will be converted to S1[i-1]. Same for S2.</li><li>At last, we will print dp[N][M] as our answer.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\nconst int prime = 1e9 + 7;\n\n// Function to count the number of distinct subsequences of s2 in s1\nint subsequenceCounting(string &amp;s1, string &amp;s2, int n, int m) {\n    // Create a 2D DP array to store the count of distinct subsequences\n    vector&lt;vector&lt;int>> dp(n + 1, vector&lt;int>(m + 1, 0));\n\n    // Initialize the first row: empty string s2 can be matched with any non-empty s1 in one way\n    for (int i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n\n    // Initialize the first column: s1 can't match any non-empty s2\n    for (int i = 1; i &lt;= m; i++) {\n        dp[0][i] = 0;\n    }\n\n    // Fill in the DP array\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            if (s1[i - 1] == s2[j - 1]) {\n                // If the characters match, we have two options:\n                // 1. Match the current characters and move diagonally (dp[i-1][j-1])\n                // 2. Leave the current character in s1 and match s2 with the previous characters (dp[i-1][j])\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;\n            } else {\n                // If the characters don't match, we can only leave the current character in s1\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    // The value at dp[n][m] contains the count of distinct subsequences\n    return dp[n][m];\n}\n\nint main() {\n    string s1 = \"babgbag\";\n    string s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    cout &lt;&lt; \"The Count of Distinct Subsequences is \" &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    static int prime = (int) (Math.pow(10, 9) + 7);\n\n    // Function to calculate the count of distinct subsequences of s1 equal to s2\n    static int subsequenceCounting(String s1, String s2, int n, int m) {\n        // Create a 2D array to store the counts of subsequences\n        int dp[][] = new int[n + 1][m + 1];\n\n        // Initialize the first column with 1 because there's one empty subsequence in any string.\n        for (int i = 0; i &lt; n + 1; i++) {\n            dp[i][0] = 1;\n        }\n\n        // Initialize the first row (except dp[0][0]) with 0 because there's no way to form s2 from an empty string.\n        for (int i = 1; i &lt; m + 1; i++) {\n            dp[0][i] = 0;\n        }\n\n        // Fill the dp array using a bottom-up approach\n        for (int i = 1; i &lt; n + 1; i++) {\n            for (int j = 1; j &lt; m + 1; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    // If the characters match, we can either include this character in the subsequence\n                    // or exclude it. So, we add the counts from both possibilities.\n                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;\n                } else {\n                    // If the characters don't match, we can only exclude this character.\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n\n    public static void main(String args[]) {\n        String s1 = \"babgbag\";\n        String s2 = \"bag\";\n\n        System.out.println(\"The Count of Distinct Subsequences is \" +\n                subsequenceCounting(s1, s2, s1.length(), s2.length()));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nprime = int(1e9 + 7)\n\n# Function to count distinct subsequences of s1 that match s2\ndef subsequenceCounting(s1, s2, n, m):\n    # Initialize a DP table to store the count of distinct subsequences\n    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]\n\n    # Base case: There is exactly one subsequence of an empty string s2 in s1\n    for i in range(n + 1):\n        dp[i][0] = 1\n\n    # Initialize dp[0][i] to 0 for i > 0 since an empty s1 cannot have a non-empty subsequence of s2\n    for i in range(1, m + 1):\n        dp[0][i] = 0\n\n    # Fill in the DP table using dynamic programming\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # If the current characters match, we have two choices:\n            # 1. Include the current character in both s1 and s2 (dp[i-1][j-1])\n            # 2. Skip the current character in s1 (dp[i-1][j])\n            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime if s1[i - 1] == s2[j - 1] else dp[i - 1][j]\n\n    # The final value in dp[n][m] is the count of distinct subsequences\n    return dp[n][m]\n\ndef main():\n    s1 = \"babgbag\"\n    s2 = \"bag\"\n    \n    # Calculate and print the count of distinct subsequences\n    print(\"The Count of Distinct Subsequences is\", subsequenceCounting(s1, s2, len(s1), len(s2)))\n\nif __name__ == \"__main__\":\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nconst prime = 1e9 + 7;\n\n// Function to count the distinct subsequences\nfunction subsequenceCounting(s1, s2, n, m) {\n    // Create a 2D array to store dynamic programming values\n    const dp = new Array(n + 1).fill(null).map(() => new Array(m + 1).fill(0));\n\n    // Initialize the first column with 1 because there is exactly one way to form an empty subsequence\n    for (let i = 0; i &lt;= n; i++) {\n        dp[i][0] = 1;\n    }\n\n    // Initialize the first row with 0 because there is no way to form a non-empty subsequence from an empty string\n    for (let i = 1; i &lt;= m; i++) {\n        dp[0][i] = 0;\n    }\n\n    // Fill the dp array using dynamic programming\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = 1; j &lt;= m; j++) {\n            if (s1[i - 1] === s2[j - 1]) {\n                // If the characters match, we can either include the current character or exclude it\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;\n            } else {\n                // If the characters do not match, we can only exclude the current character\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    // The result is stored in the bottom-right cell of the dp array\n    return dp[n][m];\n}\n\n// Main function\nfunction main() {\n    const s1 = \"babgbag\";\n    const s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    console.log(\"The Count of Distinct Subsequences is \" + subsequenceCounting(s1, s2, s1.length, s2.length));\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Better Approach Here -->\n<strong>Output:</strong> The Count of Distinct Subsequences is 5\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Better Approach Here -->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are two nested loops</p>\n<p><strong>Space Complexity: O(N*M)</strong></p>\n<p>Reason: We are using an external array of size \u2018N*M\u2019. Stack Space is eliminated.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Better Approach Ends from here -->\n\n\n<!-- Optimal Approach Starts from here -->\n\n<div id=\"optimal-approach\">\n<details>\n<summary class=\"main-summary\">\n<span>\nSpace Optimization Approach \n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"common-drops\">\n<details class=\"secondary-details\" open=\"\">\n<summary class=\"secondary-summary\">\n<span>\nAlgorithm / Intuition\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"approach-algorithm\">\n\n<!-- Insert Algorithm of Better Approach Here -->\n<p>If we closely look the relation,</p>\n<p><strong>dp[i][j] =&nbsp; dp[i-1][j-1] + dp[i-1][j]&nbsp; or dp[i][j] = dp[i-1][j]</strong></p>\n<p>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev). So, we don\u2019t need to store an entire array. Hence we can space optimize it.</p>\n<p>We will be space-optimizing this solution using <strong>only one row.</strong></p>\n<h3><strong>Intuition:</strong></h3>\n<p>If we clearly see the values required:&nbsp; dp[i-1][j-1] and dp[i-1][j], we can say that if we are at a column j, we will only require the values shown in the grey box from the previous row and other values will be from the cur row itself. So why do we need to store an entire array for it?</p>\n<p><img width=\"624\" height=\"280\" src=\"https://lh4.googleusercontent.com/19AE4G_9a6veGebYBCec7PMTgVZ546YUWhZVDtF0itZmFVGc_uumxEAiwiKZ9dcLmtP_ee1iq9mH6i8WVZSC1h0qVY118g3QC0ROV78Lei7pgFsGAONR3bDLTSwhmOmEgjv_-yr9\"></p>\n<p>If we need only two values from the prev row, there is no need to store an entire row. We can work a bit smarter.</p>\n<p>We can use the cur row itself to store the required value in the following way:</p>\n<ul><li>We take a single row \u2018prev\u2019.</li><li>We initialize it to the base condition.</li><li>Whenever we want to compute a value of the cell prev[j], we take the already existing value (prev[j] before new computation) and prev[j-1] (if required, in case of character match).</li><li>We perform the above step on all the indexes.</li><li>So we see how we can space optimize using a single row itself.</li></ul>\n</div>\n</details>\n<details class=\"code-section secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nCode\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<div class=\"code-tabs\">\n<button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n<button class=\"code-tab\" data-lang=\"java\">Java</button>\n<button class=\"code-tab\" data-lang=\"python\">Python</button>\n<button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n<svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n<path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n</path>\n</svg>\n</div>\n<div class=\"code-content\">\n<div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;bits/stdc++.h>\nusing namespace std;\n\nconst int prime = 1e9 + 7;\n\n// Function to count the number of distinct subsequences of s2 in s1\nint subsequenceCounting(string &amp;s1, string &amp;s2, int n, int m) {\n    // Create an array to store the count of distinct subsequences for each character in s2\n    vector&lt;int> prev(m + 1, 0);\n\n    // Initialize the count for an empty string (base case)\n    prev[0] = 1;\n\n    // Iterate through s1 and s2 to calculate the counts\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = m; j >= 1; j--) { // Iterate in reverse direction to avoid overwriting values prematurely\n            if (s1[i - 1] == s2[j - 1]) {\n                // If the characters match, we have two options:\n                // 1. Match the current characters and add to the previous count (prev[j-1])\n                // 2. Leave the current character in s1 and match s2 with the previous characters (prev[j])\n                prev[j] = (prev[j - 1] + prev[j]) % prime;\n            }\n            // No need for an else statement since we can simply leave the previous count as is\n        }\n    }\n\n    // The value at prev[m] contains the count of distinct subsequences\n    return prev[m];\n}\n\nint main() {\n    string s1 = \"babgbag\";\n    string s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    cout &lt;&lt; \"The Count of Distinct Subsequences is \" &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());\n    return 0;\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block \" data-lang=\"java\">\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\nclass TUF {\n    static int prime = (int) (Math.pow(10, 9) + 7);\n\n    // Function to calculate the count of distinct subsequences of s1 equal to s2\n    static int subsequenceCounting(String s1, String s2, int n, int m) {\n        // Create an array to store the counts of subsequences\n        int[] prev = new int[m + 1];\n\n        // Initialize the first element to 1 because there's one empty subsequence in any string.\n        prev[0] = 1;\n\n        // Fill the prev array using a bottom-up approach\n        for (int i = 1; i &lt; n + 1; i++) {\n            for (int j = m; j >= 1; j--) { // Reverse direction for updating\n\n                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    // If the characters match, we can either include this character in the subsequence\n                    // or exclude it. So, we add the counts from both possibilities.\n                    prev[j] = (prev[j - 1] + prev[j]) % prime;\n                } else {\n                    // If the characters don't match, we can only exclude this character.\n                    prev[j] = prev[j]; // This statement is not necessary, as it doesn't change the value.\n                }\n            }\n        }\n\n        return prev[m];\n    }\n\n    public static void main(String args[]) {\n        String s1 = \"babgbag\";\n        String s2 = \"bag\";\n\n        System.out.println(\"The Count of Distinct Subsequences is \" +\n                subsequenceCounting(s1, s2, s1.length(), s2.length()));\n    }\n}\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"python\">\n<pre class=\"wp-block-code\"><code lang=\"python\" class=\"language-python\">\nprime = int(1e9 + 7)\n\n# Function to count distinct subsequences of s1 that match s2\ndef subsequenceCounting(s1, s2, n, m):\n    # Initialize a list to store the previous row of the DP table\n    prev = [0 for i in range(m + 1)]\n    \n    # Initialize the first element of prev to 1, as there's always one way to match an empty s2\n    prev[0] = 1\n\n    # Loop through s1 and s2 in reverse direction\n    for i in range(1, n + 1):\n        for j in range(m, 0, -1):\n            # If the current characters match, update prev[j] based on previous values\n            if s1[i - 1] == s2[j - 1]:\n                prev[j] = (prev[j - 1] + prev[j]) % prime\n            # If the characters don't match, keep prev[j] unchanged (omit this statement)\n            else:\n                prev[j] = prev[j]\n\n    # The final value in prev[m] is the count of distinct subsequences\n    return prev[m]\n\ndef main():\n    s1 = \"babgbag\"\n    s2 = \"bag\"\n    \n    # Calculate and print the count of distinct subsequences\n    result = subsequenceCounting(s1, s2, len(s1), len(s2))\n    print(\"The Count of Distinct Subsequences is\", result)\n\nif __name__ == '__main__':\n    main()\n</code>\n</pre>\n</div>\n<div class=\"code-block\" data-lang=\"javascript\">\n<pre class=\"wp-block-code\"><code lang=\"javascript\" class=\"language-javascript\">\nconst prime = 1e9 + 7;\n\n// Function to count the distinct subsequences\nfunction subsequenceCounting(s1, s2, n, m) {\n    // Create an array to store dynamic programming values\n    const prev = new Array(m + 1).fill(0);\n\n    // Initialize the first element with 1 because there is exactly one way to form an empty subsequence\n    prev[0] = 1;\n\n    for (let i = 1; i &lt;= n; i++) {\n        for (let j = m; j >= 1; j--) {\n            // Reverse direction of iteration for optimization\n            if (s1[i - 1] === s2[j - 1]) {\n                // If the characters match, we can either include the current character or exclude it\n                prev[j] = (prev[j - 1] + prev[j]) % prime;\n            }\n            // No need to update for characters that do not match since prev[j] remains the same\n        }\n    }\n\n    // The result is stored in the last element of the prev array\n    return prev[m];\n}\n\n// Main function\nfunction main() {\n    const s1 = \"babgbag\";\n    const s2 = \"bag\";\n\n    // Call the subsequenceCounting function and print the result\n    console.log(\"The Count of Distinct Subsequences is \" + subsequenceCounting(s1, s2, s1.length, s2.length));\n}\n\n// Call the main function to start the program\nmain();\n</code>\n</pre>\n</div>\n<p>\n<!-- Insert Output of Optimal Apporach Here -->\n<strong>Output:</strong>The Count of Distinct Subsequences is 5\n\n\n</p>\n</div>\n</details>\n<details class=\"secondary-details\">\n<summary class=\"secondary-summary\">\n<span>\nComplexity Analysis\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n</path>\n</svg>\n</summary>\n<p>\n\n<!-- Insert Time and Space Complexity of Optimal Approach-->\n<p><strong>Time Complexity: O(N*M)</strong></p>\n<p>Reason: There are two nested loops.</p>\n<p><strong>Space Complexity: O(M)</strong></p>\n<p>Reason: We are using an external array of size \u2018M+1\u2019 to store only one row.</p>\n</p>\n</details>\n</div>\n</details>\n</div>\n<!-- Optimal Approach Starts from here -->\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n<details>\n<summary class=\"main-summary\">\n<span>\nVideo Explanation\n</span>\n<svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n<path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n</svg>\n</summary>\n<div class=\"yt-video-wrapper\">\n\n<!-- Insert iframe embed Link of Youtube Video-->\n<iframe class=\"lazy-loaded\" loading=\"lazy\" title=\"Shortest Common Supersequence\" width=\"810\" height=\"456\" data-lazy-type=\"iframe\" data-src=\"https://www.youtube.com/embed/xElxAuBcvsU?si=5Vi-iYlZsGCbYf35\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\" src=\"https://www.youtube.com/embed/nVG7eTiD2bY?feature=oembed\"></iframe><noscript>\n<iframe loading=\"lazy\" title=\"Shortest Common Supersequence\" width=\"810\" height=\"456\" src=\"https://www.youtube.com/embed/xElxAuBcvsU?si=5Vi-iYlZsGCbYf35\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen=\"\"></iframe></noscript>\n</div>\n</details>\n</div>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script>\n\nconst codeSections = document.querySelectorAll('.code-section');\n\n// Get last selected language from localStorage or set default value\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\n// Update last selected language for all sections and store in localStorage\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\n// Handle copy button click event\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\n// Set initial state of the tabs\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<script>\nconst codeSections = document.querySelectorAll('.code-section');\n\nlet lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; \n\ncodeSections.forEach((section, sectionIndex) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\nconst copyBtn = section.querySelector('.copy-btn');\n\ncodeTabs.forEach((tab) => {\ntab.addEventListener('click', () => {\ncodeTabs.forEach((t) => {\nt.classList.remove('dsa_article_code_active');\n});\ntab.classList.add('dsa_article_code_active');\n\nconst lang = tab.dataset.lang;\nconst activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\ncodeBlocks.forEach((block) => {\nif (block === activeBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n\nlastSelectedLanguage = lang;\nlocalStorage.setItem('lastSelectedLanguage', lang);\ncodeSections.forEach((otherSection, otherIndex) => {\nif (otherIndex !== sectionIndex) {\nconst otherTabs = otherSection.querySelectorAll('.code-tab');\notherTabs.forEach((otherTab) => {\nif (otherTab.dataset.lang === lang) {\notherTab.classList.add('dsa_article_code_active');\n} else {\notherTab.classList.remove('dsa_article_code_active');\n}\n});\nconst otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\nconst otherCodeBlocks = otherSection.querySelectorAll('.code-block');\notherCodeBlocks.forEach((block) => {\nif (block === otherActiveBlock) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n}\n});\n});\n});\n\ncopyBtn.addEventListener('click', () => {\nconst activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\nnavigator.clipboard.writeText(activeBlock.innerText);\ncopyBtn.classList.add('dsa_article_code_active');\nsetTimeout(() => {\ncopyBtn.classList.remove('dsa_article_code_active');\n}, 1000);\n});\n});\n\ncodeSections.forEach((section) => {\nconst codeTabs = section.querySelectorAll('.code-tab');\nconst codeBlocks = section.querySelectorAll('.code-block');\n\ncodeTabs.forEach((tab) => {\nif (tab.dataset.lang === lastSelectedLanguage) {\ntab.classList.add('dsa_article_code_active');\n} else {\ntab.classList.remove('dsa_article_code_active');\n}\n});\n\ncodeBlocks.forEach((block) => {\nif (block.dataset.lang === lastSelectedLanguage) {\nblock.classList.add('dsa_article_code_active');\n} else {\nblock.classList.remove('dsa_article_code_active');\n}\n});\n});\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>\n<!-- /wp:html -->\n\n<!-- wp:html -->\n<script src=\"https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js\"></script>\n<!-- /wp:html -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/anshuman-sharma-a1b245194/\" target=\"_blank\" rel=\"noreferrer noopener\">Anshuman Sharma</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 51,
    "preview": "Problem Statement: Distinct Subsequences Problem Link: Subsequence Counting We are given two strings S1 and S2, we want to know how many distinct subsequences of S2 are present in S1. Examples Exam..."
}