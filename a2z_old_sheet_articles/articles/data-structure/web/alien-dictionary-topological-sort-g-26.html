<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Alien Dictionary - Topological Sort: G-26</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.7;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 20px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 20px 30px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e7e7e7;
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 1.2em;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 20px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Alien Dictionary - Topological Sort: G-26</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong> Given a sorted dictionary of an alien language having N words and k starting alphabets of a standard dictionary. Find the order of characters in the alien language.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note:</strong> Many orders may be possible for a particular test case, thus you may return any valid order.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong> N = 5, K = 4
dict = {"baa","abcd","abca","cab","cad"}
<strong>Output</strong>: b d a c
<strong>Explanation:</strong> 
We will analyze every consecutive pair to find out the order of the characters.
The pair “baa” and “abcd” suggests ‘b’ appears before ‘a’ in the alien dictionary.
The pair “abcd” and “abca” suggests ‘d’ appears before ‘a’ in the alien dictionary.
The pair “abca” and “cab” suggests ‘a’ appears before ‘c’ in the alien dictionary.
The pair “cab” and “cad” suggests ‘b’ appears before ‘d’ in the alien dictionary.
So, [‘b’, ‘d’, ‘a’, ‘c’] is a valid ordering.

<strong>Example 2:</strong>
<strong>Input:</strong> N = 3, K = 3
dict = {"caa","aaa","aab"}
<strong>Output</strong>: c a b
<strong>Explanation:</strong> Similarly, if we analyze the consecutive pair 
for this example, we will figure out [‘c’, ‘a’, ‘b’] is 
a valid ordering.</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><span class="has-inline-color has-accent-color"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></span></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><a href="https://practice.geeksforgeeks.org/problems/alien-dictionary/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=alien-dictionary"><em>Problem Link</em></a><em>.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Let’s consider the first example where <strong>N</strong> = 5, <strong>K</strong> = 4 and <strong>dict</strong> = {"baa", "abcd", "abca", "cab", "cad"}. So, here we need to find out the correct ordering of the first 4 letters of the alphabet(i.e. ‘a’, ‘b’, ‘c’, ‘d’). If we consider the first 2 words and try to figure out why “baa” appears before “abcd”, we can clearly observe that they are differentiated by the first letter i.e. ‘b’ and ‘a’. That is why, we can conclude that in the alien dictionary, <strong><em>‘b’ appears before ‘a’( i.e. ‘b’ is smaller than ‘a’). </em></strong>We can correspond this differentiating factor to a <strong><em>directed graph</em></strong> like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":6904,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-6904" src="assets/7bfed0ed2be330f2a7ee27f564f71310.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Let’s understand <em>why we need not check</em><strong><em> “baa” and “abca” (the 1st and the 3rd word) next:<br/></em></strong>Until now, we have figured out why “baa” appears before “abcd”. So, by convention, if “abcd” is appearing before “abca” and “baa” is appearing before “abcd”, <strong><em>“baa” will obviously appear before “abca”</em></strong>. That is why we will check the pair of “abcd” and “abca” next rather than checking “baa” with any other words and this flow will be continued for the rest of the words.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note:</strong> <em>Points to remember that we need not check every pair of words rather we will just check the consecutive pair of words in the dictionary. </em>Comparing each pair of consecutive words in the dictionary, we can construct a directed graph like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":6905,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-6905" src="assets/c3421ffc00f57bdc6ce3b31dc6288a26.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Now, we have successfully reduced the problem to a known <strong><em>directed graph problem</em></strong>. If we look at the problem from the graph point of view, we just need to find out the <strong><em>linear ordering of the nodes of the directed graph</em></strong>. And we can do this easily using <a href="https://takeuforward.org/data-structure/kahns-algorithm-topological-sort-algorithm-bfs-g-22/" rel="noopener" target="_blank" title="">the topological sort algorithm</a> which we have previously learned.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>To further simplify the problem, we will denote the alphabet with numbers like: ‘a’ with 0, ‘b’ with 1, ‘c’ with 2, and so on. For example, if the letter is ‘z’, we will denote it using 25. Finally, the directed graph will look like the following illustration:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":6906,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-6906" src="assets/aac869acd966b9bf33924818d3091dd1.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Note:</strong> <em>The intuition is to check every consecutive pair of words and find out the differentiating factor. With these factors, we will form a directed graph, and the whole problem balls down to a topological sort of problem.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Edge Case: </strong>The problem arises when the value of K becomes 5 and there is no word in the dictionary containing the letter <strong>‘e’</strong>. In this case, we will add a separate node with the value ‘e’ in the graph and it will be considered a component of the directed graph like the following, and the same algorithm will work fine for multiple components.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":6907,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-6907" src="assets/cc6bf8aaf55764a22b8e8a9b2ae2acf2.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>If the value of K is greater than the number of unique characters appearing in the dictionary, then the extra characters will be considered the different components of the directed graph formed.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>The follow-up question for the interview:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li><strong>When is the ordering not possible?<br/></strong>There are two such cases when ordering is not possible:<ul><li><strong>If every character matches and the largest word appears before the shortest word: </strong>For example, if “abcd” appears before “abc”, we can say the ordering is not possible.</li><li><strong>If there exists a cyclic dependency between the characters: </strong>For example, in the dictionary: <strong>dict: {“abc”, “bat”, “ade”}</strong> there exists a cyclic dependency between ‘a’ and ‘b’ because the dictionary states <strong>‘a’ &lt; ‘b’ &lt; ‘a’</strong>, which is not possible.<br/></li></ul></li></ul>
<!-- /wp:list -->
<!-- wp:heading {"level":3} -->
<h3><strong>Approach</strong>: </h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>We will apply the BFS(Breadth First Search) traversal technique. Breadth First Search or BFS is a traversal technique where we visit the nodes level-wise, i.e., it visits the same level nodes simultaneously, and then moves to the next level.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Initial Configuration:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Adjacency List: </strong>Initially it will be empty and we will create this adjacency list comparing the consecutive pair of words.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Indegree Array:</strong> Initially all elements are set to 0. Then, We will count the incoming edges for a node and store it in this array. For example, if the indegree of node 3 is 2, indegree[3] = 2.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Queue:</strong> As we will use BFS, a queue is required. Initially, the node with indegree 0 will be pushed into the queue.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Answer array(topo):</strong> Initially empty and is used to store the linear ordering.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>First, we need to create the adjacency list for the graph. The steps are the following:<ol><li>We will run a loop from the starting index to the <strong>second last index </strong>because we will check the i<sup>th</sup> element and the (i+1)<sup>th</sup> element. </li><li>Inside the loop, we will pick two words (the word at the current index(<strong>s1</strong>) and the word at the next index(<strong>s2</strong>)). For comparing them, we will again run a loop up to the length of the smallest string.</li><li>Inside that second loop, if at any index we find inequality (<strong>s1[i] != s2[i]</strong>), we will add them to the adjacency list (<strong>s1[i] —&gt; s2[i]</strong>) in terms of numbers(subtracting ‘a’ from them), and then we will immediately come out of the loop. </li><li>This is only because we want the first differentiating character. Finally, we will get the adjacency list.</li><li>In short, we need to find the differentiating character for adjacent strings and create the graph. </li></ol></li><li>Once the graph is created, simply perform a <a href="https://takeuforward.org/data-structure/detect-a-cycle-in-directed-graph-topological-sort-kahns-algorithm-g-23/" rel="noopener" target="_blank" title="">topo sort</a>, whose steps are given below. </li><li>Then, we will calculate the indegree of each node and store it in the indegree array. We can iterate through the given adj list, and simply for every node u-&gt;v, we can increase the indegree of v by 1 in the indegree array. </li><li>Initially, there will be always at least a single node whose indegree is 0. So, we will push the node(s) with indegree 0 into the queue.</li><li>Then, we will pop a node from the queue including the node in our answer array, and for all its adjacent nodes, we will decrease the indegree of that node by one. For example, if node u that has been popped out from the queue has an edge towards node v(u-&gt;v), we will decrease indegree[v] by 1.</li><li>After that, if for any node the indegree becomes 0, we will push that node again into the queue.</li><li>We will repeat steps 3 and 4 until the queue is completely empty. Finally, completing the BFS we will get the linear ordering of the nodes in the answer array.<strong><br/></strong></li><li>For the final answer, we will iterate on the answer array and add each element in terms of character(adding ‘a’ to each of them) to the final string. Then we will return the string as our final answer.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;



class Solution {
	// works for multiple components
private:
	vector&lt;int&gt; topoSort(int V, vector&lt;int&gt; adj[])
	{
		int indegree[V] = {0};
		for (int i = 0; i &lt; V; i++) {
			for (auto it : adj[i]) {
				indegree[it]++;
			}
		}

		queue&lt;int&gt; q;
		for (int i = 0; i &lt; V; i++) {
			if (indegree[i] == 0) {
				q.push(i);
			}
		}
		vector&lt;int&gt; topo;
		while (!q.empty()) {
			int node = q.front();
			q.pop();
			topo.push_back(node);
			// node is in your topo sort
			// so please remove it from the indegree

			for (auto it : adj[node]) {
				indegree[it]--;
				if (indegree[it] == 0) q.push(it);
			}
		}

		return topo;
	}
public:
	string findOrder(string dict[], int N, int K) {
		vector&lt;int&gt;adj[K];
		for (int i = 0; i &lt; N - 1; i++) {
			string s1 = dict[i];
			string s2 = dict[i + 1];
			int len = min(s1.size(), s2.size());
			for (int ptr = 0; ptr &lt; len; ptr++) {
				if (s1[ptr] != s2[ptr]) {
					adj[s1[ptr] - 'a'].push_back(s2[ptr] - 'a');
					break;
				}
			}
		}

		vector&lt;int&gt; topo = topoSort(K, adj);
		string ans = "";
		for (auto it : topo) {
			ans = ans + char(it + 'a');
		}
		return ans;
	}
};

int main() {

	int N = 5, K = 4;
	string dict[] = {"baa", "abcd", "abca", "cab", "cad"};
	Solution obj;
	string ans = obj.findOrder(dict, N, K);

	for (auto ch : ans)
		cout &lt;&lt; ch &lt;&lt; ' ';
	cout &lt;&lt; endl;

	return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: b d a c </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N*len)+O(K+E), where N is the number of words in the dictionary, ‘len’ is the length up to the index where the first inequality occurs, K = no. of nodes, and E = no. of edges.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(K) + O(K)+O(K)+O(K) ~ O(4K), O(K) for the indegree array, and O(K) for the queue data structure used in BFS(where K = no.of nodes), O(K) for the answer array and O(K) for the adjacency list used in the algorithm.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;


class Solution {
    private List&lt;Integer&gt; topoSort(int V, List&lt;List&lt;Integer&gt;&gt; adj) {
        int indegree[] = new int[V];
        for (int i = 0; i &lt; V; i++) {
            for (int it : adj.get(i)) {
                indegree[it]++;
            }
        }

        Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
        for (int i = 0; i &lt; V; i++) {
            if (indegree[i] == 0) {
                q.add(i);
            }
        }
        List&lt;Integer&gt; topo = new ArrayList&lt;&gt;();
        while (!q.isEmpty()) {
            int node = q.peek();
            q.remove();
            topo.add(node);
            // node is in your topo sort
            // so please remove it from the indegree

            for (int it : adj.get(node)) {
                indegree[it]--;
                if (indegree[it] == 0) q.add(it);
            }
        }

        return topo;
    }
    public String findOrder(String [] dict, int N, int K) {
        List&lt;List&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; K; i++) {
            adj.add(new ArrayList&lt;&gt;());
        }


        for (int i = 0; i &lt; N - 1; i++) {
            String s1 = dict[i];
            String s2 = dict[i + 1];
            int len = Math.min(s1.length(), s2.length());
            for (int ptr = 0; ptr &lt; len; ptr++) {
                if (s1.charAt(ptr) != s2.charAt(ptr)) {
                    adj.get(s1.charAt(ptr) - 'a').add(s2.charAt(ptr) - 'a');
                    break;
                }
            }
        }

        List&lt;Integer&gt; topo = topoSort(K, adj);
        String ans = "";
        for (int it : topo) {
            ans = ans + (char)(it + (int)('a'));
        }

        return ans;

    }
}

public class tUf {
    public static void main(String[] args) {
        int N = 5, K = 4;
        String[] dict = {"baa", "abcd", "abca", "cab", "cad"};
        Solution obj = new Solution();
        String ans = obj.findOrder(dict, N, K);

        for (int i = 0; i &lt; ans.length(); i++) {
            System.out.print(ans.charAt(i) + " ");
        }
        System.out.println("");
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: b d a c </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N*len)+O(K+E), where N is the number of words in the dictionary, ‘len’ is the length up to the index where the first inequality occurs, K = no. of nodes, and E = no. of edges.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(K) + O(K)+O(K)+O(K) ~ O(4K), O(K) for the indegree array, and O(K) for the queue data structure used in BFS(where K = no.of nodes), O(K) for the answer array and O(K) for the adjacency list used in the algorithm.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noreferrer noopener" target="_blank"><strong>KRITIDIPTA GHOSH</strong></a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>