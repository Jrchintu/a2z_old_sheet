<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Evaluate Boolean Expression to True | Partition DP: DP 52</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1;
            /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs);
            /* 5px */
            padding: var(--spacing-sm);
            /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.25rem;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5rem;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm);
            /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1rem;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1rem;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm);
            /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1rem;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg);
            /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm);
            /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto;
                /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm);
                /* 10px */
            }

            h1 {
                font-size: 2rem;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Evaluate Boolean Expression to True | Partition DP: DP 52</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong> Given an expression, A, with operands and operators (OR, AND, XOR), in how many ways can you evaluate the expression to be true, by grouping it in different ways?</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Operands are only true and false.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Return the number of ways to evaluate the expression modulo 103 + 3.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Pre-requisite: </strong><a href="https://takeuforward.org/dynamic-programming/matrix-chain-multiplication-dp-48/" rel="noopener" target="_blank" title="">DP-48</a>, <a href="https://takeuforward.org/data-structure/matrix-chain-multiplication-tabulation-method-dp-49/" rel="noopener" target="_blank" title="">DP-49</a>, <a href="https://takeuforward.org/data-structure/minimum-cost-to-cut-the-stick-dp-50/" rel="noopener" target="_blank" title="">DP-50</a>, <a href="https://www.youtube.com/watch?v=Yz4LlDSlkns" rel="noopener" target="_blank" title="">DP-51</a></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
Examples
</strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted"><!-- Insert New Examples Here -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong> expression = “T|T&amp;F”
<strong>Output</strong>: 1
<strong>Explanation:</strong> The only way to get the result as true is:
(T) | (T&amp;F) = T|F = T </pre>
<pre class="wp-block-preformatted"><strong>Example 2:</strong>
<strong>Input</strong>: expression = “F|T^F”
<strong>Output</strong>: 2
<strong>Explanation</strong>: There are 2 possible ways to get the result as true:
		i) (F|T) ^ F = T ^ F = T
		ii) F | (T^F) = F | T = T</pre>
</pre>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/boolean-evaluation_1214650?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/86dd2cadbd0e7ef71ad98d3b7f2f2efc.png"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out
yourself first. </em></p>
<!-- /wp:html -->
<!-- wp:html -->
<div class="horizontal_navbar_dsa_article">
<div class="grid_container_three">
<a class="three-boxes box-a" href="#brute-force-approach">
Recursive approach
</a>
<a class="three-boxes box-b" href="#better-approach">
Memoization approach
</a>
<a class="three-boxes box-c" href="#optimal-approach">
Tabulation Approach
</a>
<a class="three-boxes box-d" href="#dsa_article_video_explanation">
<svg fill="none" height="26" viewbox="0 0 20 14" width="26" xmlns="http://www.w3.org/2000/svg">
<path d="M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z" fill="red"></path>
</svg>
</a>
<div class="box-e tooltip">
<svg fill="none" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z" fill="black"></path>
</svg>
<div class="bottom">
<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,
closes all other expands. You can manually expand more than one approach at a time</p>
<i></i>
</div>
</div>
</div>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Brute Force Approach Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
Recursive Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>In the question, it is clearly stated, that the operands are only ‘true’ and ‘false’, and the operators are AND(&amp;), OR(|), and XOR(^).</p>
<p>If we carefully observe, we can easily understand that the given expression can be solved in several ways. And through several ways, we can achieve different results. For example, if the expression, <strong>“T|T&amp;F”</strong> is given, we can solve it in two different ways like the following:</p>
<ul><li>(T | T) &amp; F = T &amp; F = F. This method gives the result false.</li><li>(T) | (T &amp; F) = T | F = T. This method gives the result true.</li></ul>
<p>But here, we are concerned only with the ways, through which we can achieve the result of the expression as true. So, for the above example, we will only consider the second approach. Now, in order to solve the problem, we have to figure out the total no. of such ways through which we can get ‘true’ as our answer.</p>
<h4><strong>Observation:</strong></h4>
<p>Let’s consider the following expression:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7223" src="assets/a1b027de947fe996f767b57341c2e101.png"/></figure>
<p>If we carefully observe, we can easily notice that the given expression both starts and ends with an operand and the expression also follows a certain pattern i.e. an operand followed by an operator.</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7224" src="assets/3a369c81985abd4558460128def63a0f.png"/></figure>
<p>Now, this expression can be primarily partitioned in the following possible ways:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7225" src="assets/71249d1009e2b03c59a629513970f387.png"/></figure>
<p>From this illustration, we can easily conclude that the number of partitions we can make equals the number of operators that the expression contains. And we can also assume the left side of each operator is the left subproblem and the right side signifies the right subproblem.<br/>Now, each subproblem can be again divided into multiple subproblems in similar ways. For example, the given expression can be divided into subproblems like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7226" src="assets/91e4865d8219c19bd18933c8a1b4b6aa.png"/></figure>
<p>Now, we are getting a pattern of dividing the whole expression into smaller subproblems. If we continue to divide the expression, at some point we will get a single operand left.</p>
<h3><strong>Intuition:</strong><strong> </strong></h3>
<p><em>The intuition is to divide the expression into subproblems and we will break the expression at the position of the operators.</em> </p>
<p>We have found the right approach until now. Now, let us quickly revise the rules to solve a problem on partition dp.</p>
<ol><li>Start with the entire block/array/expression and mark it with i, j.</li><li>Try all partitions.</li><li>Return the best possible answer of the two partitions (the answer that comes after dividing the problem into two subproblems and solving them recursively).</li></ol>
<p>Now let us go through these rules and apply them to this problem.</p>
<p><strong>Marking the expression with i, j:</strong></p>
<p>We are given a string or an expression. The entire expression basically represents the range. So, we will place i and j at both ends of the expression.</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7227" src="assets/0dadf1615e67d848a32e17c99e6a31fa.png"/></figure>
<h4><strong>Try all partitions:</strong></h4>
<p>As we have figured out the logic for marking the i, and j pointers, we will move to the partitioning loop. We can simply write a for loop(say ind) starting from i+1 to j-1, The problem is being broken in the following manner:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7228" src="assets/60cb491fef7105b65ca139293c7c9a48.png"/></figure>
<p><strong>Note: </strong>Here f(i, ind-1) is the left sub-problem, and f(ind+1, j) is the right sub-problem. And the ind variable will start from i+1 and runs up to j-1 and it will move 2 steps in each iteration to select each operator at a time like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7229" src="assets/99f2848d6a1bf1b0cc20aba05392e167.png"/></figure>
<p><strong>Base Case 1: </strong>We can say that when i &gt; j this is not a valid partition and so we will return 0.<br/>The other base case is discussed later.</p>
<p><strong>Return the best possible answer:</strong></p>
<p>Here, in this problem, we are trying to figure out the total number of ways through which we can get the result true for the given expression. So, the final answer will be the summation of all the answers obtained from the subproblems.</p>
<p><strong>Observation 1:</strong></p>
<p>Now, if we want the result true for the whole expression, we can easily observe the following three cases:</p>
<p><strong>Case 1 (If the partition is made at the ‘AND(&amp;)’ operator): </strong></p>
<p>The structure will look like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7230" src="assets/15bc49fb806b69c21b793025719a1a2f.png"/></figure>
<p>Now, the whole expression will yield true when the subproblem1 and subproblem2 both will yield true. So, the total number of ways will be = (x1 * x3).</p>
<p><strong>Case 2 (If the partition is made at the ‘OR(|)’ operator): </strong></p>
<p>The structure will look like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7232" src="assets/4a45c66a7987b55325b5c2ea55b2d1ee.png"/></figure>
<p>Now, the whole expression will yield true in three possible ways:</p>
<ul><li>Subproblem1 yields true, and subproblem2 yields true i.e. (x1 * x3) ways.</li><li>Subproblem1 yields false and subproblem2 yields true i.e. (x2 * x3) ways.</li><li>Subproblem1 yields true and subproblem2 yields false i.e. (x1 * x4) ways.</li></ul>
<p>So, total number of ways = (x1 * x3) + (x2 * x3) + (x1 * x4).</p>
<p><strong>Case 3 (If the partition is made at the ‘XOR(^)’ operator):</strong></p>
<p>The structure will look like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7233" src="assets/90756d9b38a01ae024faa1c55de0db38.png"/></figure>
<p>Now, the whole expression will yield true in two cases:</p>
<ul><li>Subproblem1 yields false and subproblem2 yields true i.e. (x2 * x3) ways.</li><li>Subproblem1 yields true and subproblem2 yields false i.e. (x1 * x4) ways.</li></ul>
<p>So, total number of ways = (x2 * x3) + (x1 * x4).</p>
<p><strong>Observation 2:</strong></p>
<p><em>Now, we have found that in order to solve the problem, we need to figure out the number of cases the subproblems yield true and the number of cases the subproblems yield false(i.e. The values of x1, x2, x3, and x4).</em></p>
<p>In order to do so, we will carry a third variable(let’s say <strong>isTrue</strong>) to indicate for which result we are trying to calculate the number of ways. If <strong>isTrue</strong> is 1, we will calculate the number of ways that provide the result true and if <strong>isTrue</strong> is 0, we will calculate the number of ways that give the result false.</p>
<p>So, the modified function structure will be the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7234" src="assets/1b8633993673119b85f7656566e86bb3.png"/></figure>
<h5><strong>Observation 3:</strong></h5>
<p>Now, if we continue to break down the expression into smaller subproblems, at some point we will get such a subproblem that contains only a single operand. Let’s understand it considering the following illustration:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7235" src="assets/08fcfa914a345a0bd1a26e6a6b1e8a25.png"/></figure>
<p>From the example, we can clearly notice that a subproblem that contains only a single operand(i.e. when i and j are equal, i == j) returns either 1 or 0 ways for true and similarly 1 or 0 ways for false. And this will be the <strong><em>2nd base case.</em></strong></p>
<p><strong>Base case 2:</strong></p>
<p>If i and j become equal, we will observe two different cases:</p>
<ul><li><strong>Case 1 (If we want the number of ways for true(i.e. isTrue = 1))</strong>:<br/>If the single operand left, is T(true), it will return 1 way and if it is F(false), it will return 0 ways.</li><li><strong>Case 2 (If we want the number of ways for false(i.e. isTrue = 0))</strong>:<br/>If the single operand left, is T(true), it will return 0 ways and if it is F(false), it will return 1 way.</li></ul>
<p>So, the base case 2 will be the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7236" src="assets/7c74cbc7742b87cb236bb2bba2d237a5.png"/></figure>
<p>Now let’s move on to the calculation of the no. of ways:<br/>Inside the partitioning loop we will calculate the total no. of ways for the subproblems to be true and false like the following:</p>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7237" src="assets/164f277f7256f265aff3cd63ed0626ec.png"/></figure>
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>
<p><strong>Note: </strong><em>Since the number of ways can be a large number, we are doing a modulo of 1000000007.</em></p>
<p>Let’s discuss the approach and the implementation part:</p>
<p><strong>Approach</strong>: </p>
<p><strong>The recursive algorithm steps are as follows:</strong></p>
<ol><li>Convert the problem to a recursive function marked by the pointers i and j and the isTrue variable discussed above.</li><li>Use a loop to check all possible partitions of the expression and calculate the total number of ways.</li><li>Return the total number of ways calculated.</li><li><strong>Base case 1: </strong>If i &gt; j, we will return 0.<br/><strong>Base case 2: </strong>If i and j become equal, we will observe two different cases:</li></ol>
<ul><li><strong>Case 1 (If we want the number of ways of true(i.e. isTrue = 1))</strong>:<br/>If the single operand left is T(true), it will return 1 way and if it is F(false), it will return 0 ways.</li><li><strong>Case 2 (If we want the number of ways of false(i.e. isTrue = 0))</strong>:<br/>If the single operand left is T(true), it will return 0 ways and if it is F(false), it will return 1 way.</li></ul>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int mod = 1000000007;

int f(int i, int j, int isTrue, string &amp;exp) {
    // Base case 1: If i &gt; j, it's an invalid expression, return 0.
    if (i &gt; j) return 0;
    
    // Base case 2: If i and j are the same, evaluate the single character.
    if (i == j) {
        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;
        else return exp[i] == 'F' ? 1 : 0;
    }
    
    ll ways = 0;
    
    // Iterate through the expression.
    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
        ll lT = f(i, ind - 1, 1, exp);  // Number of ways to make the left expression true.
        ll lF = f(i, ind - 1, 0, exp);  // Number of ways to make the left expression false.
        ll rT = f(ind + 1, j, 1, exp);  // Number of ways to make the right expression true.
        ll rF = f(ind + 1, j, 0, exp);  // Number of ways to make the right expression false.

        // Check the operator at the current index and update ways accordingly.
        if (exp[ind] == '&amp;') {
            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
        }
        else if (exp[ind] == '|') {
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rF) % mod) % mod;
        }
        else {  // XOR operator
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
        }
    }
    return ways;
}

int evaluateExp(string &amp;exp) {
    int n = exp.size();
    return f(0, n - 1, 1, exp);  // Start evaluation with isTrue set to true.
}

int main() {
    string exp = "F|T^F";
    int ways = evaluateExp(exp);
    cout &lt;&lt; "The total number of ways: " &lt;&lt; ways &lt;&lt; "\n";
    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">

public class BooleanExpressionWays {
    static final int MOD = 1000000007;

    static long evaluateExpressionWays(String exp, int i, int j, int isTrue, Long[][][] dp) {
        // Base case 1: When the start index is greater than the end index, no ways to evaluate.
        if (i &gt; j) {
            return 0;
        }
        // Base case 2: When the start and end indices are the same.
        if (i == j) {
            if (isTrue == 1) {
                return exp.charAt(i) == 'T' ? 1 : 0;
            } else {
                return exp.charAt(i) == 'F' ? 1 : 0;
            }
        }
        
        if (dp[i][j][isTrue] != null) {
            return dp[i][j][isTrue];
        }

        long ways = 0;
        for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
            long lT = evaluateExpressionWays(exp, i, ind - 1, 1, dp);
            long lF = evaluateExpressionWays(exp, i, ind - 1, 0, dp);
            long rT = evaluateExpressionWays(exp, ind + 1, j, 1, dp);
            long rF = evaluateExpressionWays(exp, ind + 1, j, 0, dp);

            char operator = exp.charAt(ind);
            if (operator == '&amp;') {
                if (isTrue == 1) {
                    ways = (ways + (lT * rT) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;
                }
            } else if (operator == '|') {
                if (isTrue == 1) {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rF) % MOD) % MOD;
                }
            } else {
                if (isTrue == 1) {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;
                }
            }
        }

        dp[i][j][isTrue] = ways;
        return ways;
    }

    static int evaluateExpWays(String exp) {
        int n = exp.length();
        Long[][][] dp = new Long[n][n][2]; // dp[i][j][k] stores the number of ways to evaluate the subexpression from index i to j with the result k (0 or 1).
        return (int) evaluateExpressionWays(exp, 0, n - 1, 1, dp);
    }

    public static void main(String[] args) {
        String exp = "F|T^F";
        int ways = evaluateExpWays(exp);
        System.out.println("The total number of ways: " + ways);
    }
}

</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">

def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    def f(i, j, isTrue):
        # Base case 1:
        if i &gt; j:
            return 0
        # Base case 2:
        if i == j:
            if isTrue == 1:
                return int(exp[i] == 'T')
            else:
                return int(exp[i] == 'F')
        
        ways = 0
        for ind in range(i + 1, j, 2):
            lT = f(i, ind - 1, 1)
            lF = f(i, ind - 1, 0)
            rT = f(ind + 1, j, 1)
            rF = f(ind + 1, j, 0)

            if exp[ind] == '&amp;':
                if isTrue:
                    ways = (ways + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
            elif exp[ind] == '|':
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod) % mod
            else:
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
        
        return ways
    
    return f(0, n - 1, 1)

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)

</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
function countWaysToEvaluateExpression(exp) {
    // Define constants for the modulo operation
    const mod = 1000000007;

    // Function f to recursively count the number of ways to evaluate the expression
    function f(i, j, isTrue, exp) {
        // Base case 1: If i &gt; j, there are no ways to evaluate the expression.
        if (i &gt; j) return 0;

        // Base case 2: If i and j are the same, check if it evaluates to the desired result.
        if (i === j) {
            if (isTrue === 1) return exp[i] === 'T' ? 1 : 0;
            else return exp[i] === 'F' ? 1 : 0;
        }

        let ways = 0;

        // Iterate through operators at odd indices in the expression
        for (let ind = i + 1; ind &lt;= j - 1; ind += 2) {
            // Calculate the number of ways to evaluate the left and right subexpressions
            const lT = f(i, ind - 1, 1, exp);
            const lF = f(i, ind - 1, 0, exp);
            const rT = f(ind + 1, j, 1, exp);
            const rF = f(ind + 1, j, 0, exp);

            if (exp[ind] === '&amp;') {
                if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
                else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
            }
            else if (exp[ind] === '|') {
                if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
                else ways = (ways + (lF * rF) % mod) % mod;
            }
            else {
                if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
                else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
            }
        }
        return ways;
    }

    // Get the length of the expression
    const n = exp.length;

    // Call the recursive function with initial values
    return f(0, n - 1, 1, exp);
}

// Define the input expression
const exp = "F|T^F";

// Call the function to count the number of ways to evaluate the expression
const ways = countWaysToEvaluateExpression(exp);

// Print the result
console.log("The total number of ways:", ways);
</code>
</pre>
</div>
<p>
<!-- Insert Output of Brute Force Here -->
The total number of ways: 2 (Given expression = "F|T^F")
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Brute Force Here -->
</p><p><strong>Time Complexity: Exponential</strong></p>
<p></p>
</details>
</div>
</details>
</div>
<!-- Brute Force Approach Ends here -->
<!-- Better Approach Starts from here -->
<div id="better-approach">
<details>
<summary class="main-summary">
<span>
Memoization Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition For Better Approach Here -->
<p><strong>Steps to memoize the recursive solution:</strong></p>
<ol><li>Create a 3D dp array of size [n][n][2]. i and j can range from 1 to n and isTrue can range from 0 to 1 so we take the size n X n X 2.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j, isTrue)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j][isTrue] != -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j][isTrue] to the solution we get.</li></ol>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">

#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int mod = 1000000007;

int f(int i, int j, int isTrue, string &amp;exp, vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; &amp;dp) {
    // Base case 1: If i &gt; j, it's an invalid expression, return 0.
    if (i &gt; j) return 0;
    
    // Base case 2: If i and j are the same, evaluate the single character.
    if (i == j) {
        if (isTrue == 1) return exp[i] == 'T' ? 1 : 0;
        else return exp[i] == 'F' ? 1 : 0;
    }

    // If the result for this subproblem has been computed before, return it.
    if (dp[i][j][isTrue] != -1) return dp[i][j][isTrue];
    
    ll ways = 0;
    
    // Iterate through the expression.
    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
        ll lT = f(i, ind - 1, 1, exp, dp);  // Number of ways to make the left expression true.
        ll lF = f(i, ind - 1, 0, exp, dp);  // Number of ways to make the left expression false.
        ll rT = f(ind + 1, j, 1, exp, dp);  // Number of ways to make the right expression true.
        ll rF = f(ind + 1, j, 0, exp, dp);  // Number of ways to make the right expression false.

        // Check the operator at the current index and update ways accordingly.
        if (exp[ind] == '&amp;') {
            if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
        }
        else if (exp[ind] == '|') {
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
            else ways = (ways + (lF * rF) % mod) % mod;
        }
        else {  // XOR operator
            if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
            else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
        }
    }
    
    // Store the result in the DP table and return it.
    return dp[i][j][isTrue] = ways;
}

int evaluateExp(string &amp;exp) {
    int n = exp.size();
    vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; dp(n, vector&lt;vector&lt;ll&gt;&gt;(n, vector&lt;ll&gt;(2, -1)));
    return f(0, n - 1, 1, exp, dp);  // Start evaluation with isTrue set to true.
}

int main() {
    string exp = "F|T^F";
    int ways = evaluateExp(exp);
    cout &lt;&lt; "The total number of ways: " &lt;&lt; ways &lt;&lt; "\n";
    return 0;
}

</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">

public class BooleanExpressionWays {
    static final int MOD = 1000000007;

    static long evaluateExpressionWays(String exp, int i, int j, int isTrue, Long[][][] dp) {
        // Base case 1: When the start index is greater than the end index, no ways to evaluate.
        if (i &gt; j) {
            return 0;
        }
        // Base case 2: When the start and end indices are the same.
        if (i == j) {
            if (isTrue == 1) {
                return exp.charAt(i) == 'T' ? 1 : 0;
            } else {
                return exp.charAt(i) == 'F' ? 1 : 0;
            }
        }
        
        if (dp[i][j][isTrue] != null) {
            return dp[i][j][isTrue];
        }

        long ways = 0;
        for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
            long lT = evaluateExpressionWays(exp, i, ind - 1, 1, dp);
            long lF = evaluateExpressionWays(exp, i, ind - 1, 0, dp);
            long rT = evaluateExpressionWays(exp, ind + 1, j, 1, dp);
            long rF = evaluateExpressionWays(exp, ind + 1, j, 0, dp);

            char operator = exp.charAt(ind);
            if (operator == '&amp;') {
                if (isTrue == 1) {
                    ways = (ways + (lT * rT) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;
                }
            } else if (operator == '|') {
                if (isTrue == 1) {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rF) % MOD) % MOD;
                }
            } else {
                if (isTrue == 1) {
                    ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;
                } else {
                    ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;
                }
            }
        }

        dp[i][j][isTrue] = ways;
        return ways;
    }

    static int evaluateExpWays(String exp) {
        int n = exp.length();
        Long[][][] dp = new Long[n][n][2]; // dp[i][j][k] stores the number of ways to evaluate the subexpression from index i to j with the result k (0 or 1).
        return (int) evaluateExpressionWays(exp, 0, n - 1, 1, dp);
    }

    public static void main(String[] args) {
        String exp = "F|T^F";
        int ways = evaluateExpWays(exp);
        System.out.println("The total number of ways: " + ways);
    }
}

</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">

def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    def f(i, j, isTrue, dp):
        # Base case 1:
        if i &gt; j:
            return 0
        # Base case 2:
        if i == j:
            if isTrue == 1:
                return int(exp[i] == 'T')
            else:
                return int(exp[i] == 'F')
        
        if dp[i][j][isTrue] != -1:
            return dp[i][j][isTrue]
        
        ways = 0
        for ind in range(i + 1, j, 2):
            lT = f(i, ind - 1, 1, dp)
            lF = f(i, ind - 1, 0, dp)
            rT = f(ind + 1, j, 1, dp)
            rF = f(ind + 1, j, 0, dp)

            if exp[ind] == '&amp;':
                if isTrue:
                    ways = (ways + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
            elif exp[ind] == '|':
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod) % mod
            else:
                if isTrue:
                    ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                else:
                    ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
        
        dp[i][j][isTrue] = ways
        return ways
    
    dp = [[[ -1 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    return f(0, n - 1, 1, dp)

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)

</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">

def count_ways(i, j, is_true, exp, dp):
    # Base case 1: If i &gt; j, there are no ways to evaluate the expression.
    if i &gt; j:
        return 0
    
    # Base case 2: If i and j are the same, check if it evaluates to the desired result.
    if i == j:
        if is_true == 1:
            return 1 if exp[i] == 'T' else 0
        else:
            return 1 if exp[i] == 'F' else 0

    # Check if the result for this subproblem is already computed
    if dp[i][j][is_true] != -1:
        return dp[i][j][is_true]

    ways = 0

    # Iterate through operators at odd indices in the expression
    for ind in range(i + 1, j, 2):
        # Calculate the number of ways to evaluate the left and right subexpressions
        lT = count_ways(i, ind - 1, 1, exp, dp)
        lF = count_ways(i, ind - 1, 0, exp, dp)
        rT = count_ways(ind + 1, j, 1, exp, dp)
        rF = count_ways(ind + 1, j, 0, exp, dp)

        if exp[ind] == '&amp;':
            if is_true:
                ways = (ways + (lT * rT) % mod) % mod
            else:
                ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
        elif exp[ind] == '|':
            if is_true:
                ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
            else:
                ways = (ways + (lF * rF) % mod) % mod
        else:
            if is_true:
                ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
            else:
                ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
    
    # Store the result in the memoization table and return it
    dp[i][j][is_true] = ways
    return ways

# Function to evaluate the expression
def evaluate_expression(exp):
    n = len(exp)
    # Create a memoization table initialized with -1
    dp = [[[-1 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    return count_ways(0, n - 1, 1, exp, dp)

# Define the input expression
exp = "F|T^F"

# Call the function to count the number of ways to evaluate the expression
mod = 1000000007
ways = evaluate_expression(exp)

# Print the result
print("The total number of ways:", ways)
</code>
</pre>
</div>
<p>
<!-- Insert Output of Better Approach Here -->
The total number of ways: 2 (Given expression = "F|T^F");
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Better Approach Here -->
</p><p><strong>Time Complexity: </strong>O(N*N*2 * N) ~ O(N<sup>3</sup>) There are a total of 2*N<sup>2</sup> no. of states. And for each state, we are running a partitioning loop roughly for N times.</p>
<p><strong>Space Complexity: </strong>O(2*N<sup>2</sup>) + Auxiliary stack space of O(N), 2*N<sup>2</sup> for the dp array we are using.</p>
<p></p>
</details>
</div>
</details>
</div>
<!-- Better Approach Ends from here -->
<!-- Optimal Approach Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
Tabulation Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm of Optimal Approach Here -->
<p><strong>Tabulation:</strong></p>
<ol><li>First of all, we handle the base case. If (i &gt; j) we return 0. To cover this case we can initialize the entire dp array with 0.</li><li>Next, memoization is a top-down approach, whereas tabulation is bottom-up. Our changing parameters i and j will change in opposite directions, i.e i will change from n→1 and j will change from 1→ n. isTrue will change from 0→1.</li><li>Next, we copy down the recursive logic(recurrence) inside the nested loops.</li></ol>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

#define ll long long
const int mod = 1000000007;

int evaluateExp(string &amp;exp) {
    int n = exp.size();
    vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt; dp(n, vector&lt;vector&lt;ll&gt;&gt;(n, vector&lt;ll&gt;(2, 0)));
    
    for (int i = n - 1; i &gt;= 0; i--) {
        for (int j = 0; j &lt;= n - 1; j++) {
            // Base case 1: i &gt; j is an invalid case, so continue.
            if (i &gt; j) continue;
            
            for (int isTrue = 0; isTrue &lt;= 1; isTrue++) {
                // Base case 2: i == j, evaluate the single character.
                if (i == j) {
                    if (isTrue == 1) dp[i][j][isTrue] = exp[i] == 'T';
                    else dp[i][j][isTrue] = exp[i] == 'F';
                    continue;
                }

                // Recurrence logic:
                ll ways = 0;
                for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
                    ll lT = dp[i][ind - 1][1];
                    ll lF = dp[i][ind - 1][0];
                    ll rT = dp[ind + 1][j][1];
                    ll rF = dp[ind + 1][j][0];

                    if (exp[ind] == '&amp;') {
                        if (isTrue) ways = (ways + (lT * rT) % mod) % mod;
                        else ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod;
                    }
                    else if (exp[ind] == '|') {
                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod;
                        else ways = (ways + (lF * rF) % mod) % mod;
                    }
                    else {
                        if (isTrue) ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod;
                        else ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod;
                    }
                }
                dp[i][j][isTrue] = ways;
            }
        }
    }
    return dp[0][n - 1][1];
}

int main() {
    string exp = "F|T^F";
    int ways = evaluateExp(exp);
    cout &lt;&lt; "The total number of ways: " &lt;&lt; ways &lt;&lt; "\n";
    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">

public class BooleanExpressionWays {
    static final int MOD = 1000000007;

    static int evaluateExp(String exp) {
        int n = exp.length();
        long[][][] dp = new long[n][n][2];

        // Initializing the dp array
        for (int i = n - 1; i &gt;= 0; i--) {
            for (int j = 0; j &lt;= n - 1; j++) {
                if (i &gt; j) continue;
                for (int isTrue = 0; isTrue &lt;= 1; isTrue++) {
                    // Base case 1:
                    if (i == j) {
                        if (isTrue == 1) dp[i][j][isTrue] = exp.charAt(i) == 'T' ? 1 : 0;
                        else dp[i][j][isTrue] = exp.charAt(i) == 'F' ? 1 : 0;
                        continue;
                    }

                    // Recurrence logic:
                    long ways = 0;
                    for (int ind = i + 1; ind &lt;= j - 1; ind += 2) {
                        long lT = dp[i][ind - 1][1];
                        long lF = dp[i][ind - 1][0];
                        long rT = dp[ind + 1][j][1];
                        long rF = dp[ind + 1][j][0];

                        char operator = exp.charAt(ind);
                        if (operator == '&amp;') {
                            if (isTrue == 1) ways = (ways + (lT * rT) % MOD) % MOD;
                            else ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lF * rF) % MOD) % MOD;
                        } else if (operator == '|') {
                            if (isTrue == 1) ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD + (lT * rT) % MOD) % MOD;
                            else ways = (ways + (lF * rF) % MOD) % MOD;
                        } else {
                            if (isTrue == 1) ways = (ways + (lF * rT) % MOD + (lT * rF) % MOD) % MOD;
                            else ways = (ways + (lF * rF) % MOD + (lT * rT) % MOD) % MOD;
                        }
                    }
                    dp[i][j][isTrue] = ways;
                }
            }
        }
        return (int) dp[0][n - 1][1];
    }

    public static void main(String[] args) {
        String exp = "F|T^F";
        int ways = evaluateExp(exp);
        System.out.println("The total number of ways: " + ways);
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">

def evaluateExp(exp):
    n = len(exp)
    mod = 1000000007
    
    # Create a 3D DP array to store the results of subproblems
    dp = [[[0 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    
    # Iterate over the expression string
    for i in range(n - 1, -1, -1):
        for j in range(n):
            # Base case 1: Skip invalid ranges
            if i &gt; j:
                continue
            
            # Iterate over possible values of 'isTrue' (0 or 1)
            for isTrue in range(2):
                # Base case 2: When i == j
                if i == j:
                    if isTrue == 1:
                        dp[i][j][isTrue] = int(exp[i] == 'T')
                    else:
                        dp[i][j][isTrue] = int(exp[i] == 'F')
                    continue
                
                # Recurrence logic
                ways = 0
                for ind in range(i + 1, j, 2):
                    lT = dp[i][ind - 1][1]
                    lF = dp[i][ind - 1][0]
                    rT = dp[ind + 1][j][1]
                    rF = dp[ind + 1][j][0]

                    if exp[ind] == '&amp;':
                        if isTrue:
                            ways = (ways + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
                    elif exp[ind] == '|':
                        if isTrue:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod) % mod
                    else:
                        if isTrue:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod
                
                dp[i][j][isTrue] = ways
    
    # The final result is stored in dp[0][n - 1][1] when the expression is considered true
    return dp[0][n - 1][1]

if __name__ == "__main__":
    exp = "F|T^F"
    ways = evaluateExp(exp)
    print("The total number of ways:", ways)

</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">

# Function to evaluate the expression
def evaluate_expression(exp):
    mod = 1000000007
    n = len(exp)
    
    # Create a 3D memoization table initialized with 0
    dp = [[[0 for _ in range(2)] for _ in range(n)] for _ in range(n)]
    
    # Loop through the expression in reverse order
    for i in range(n - 1, -1, -1):
        for j in range(n):
            # Base case 1: Skip invalid cases where i &gt; j
            if i &gt; j:
                continue
            
            for is_true in range(2):
                # Base case 2: If i and j are the same, calculate the result
                if i == j:
                    if is_true == 1:
                        dp[i][j][is_true] = 1 if exp[i] == 'T' else 0
                    else:
                        dp[i][j][is_true] = 1 if exp[i] == 'F' else 0
                    continue

                # Recurrence logic:
                ways = 0
                for ind in range(i + 1, j, 2):
                    lT = dp[i][ind - 1][1]
                    lF = dp[i][ind - 1][0]
                    rT = dp[ind + 1][j][1]
                    rF = dp[ind + 1][j][0]

                    if exp[ind] == '&amp;':
                        if is_true:
                            ways = (ways + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lF * rF) % mod) % mod
                    elif exp[ind] == '|':
                        if is_true:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod + (lT * rT) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod) % mod
                    else:
                        if is_true:
                            ways = (ways + (lF * rT) % mod + (lT * rF) % mod) % mod
                        else:
                            ways = (ways + (lF * rF) % mod + (lT * rT) % mod) % mod

                dp[i][j][is_true] = ways
    
    # The result for the entire expression is stored in dp[0][n - 1][1]
    return dp[0][n - 1][1]

# Main function
def main():
    exp = "F|T^F"
    ways = evaluate_expression(exp)
    print("The total number of ways:", ways)

if __name__ == "__main__":
    main()

</code>
</pre>
<p>
<!-- Insert Output of Optimal Apporach Here -->
The total number of ways: 2 (Given expression = "F|T^F");
</p>
</div>
</div></details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Optimal Approach-->
</p><p><strong>Time Complexity: </strong>O(N*N*2 * N) ~ O(N<sup>3</sup>) There are a total of 2*N<sup>2</sup> no. of states. And for each state, we are running a partitioning loop roughly for N times.</p>
<p><strong>Space Complexity: </strong>O(2*N<sup>2</sup>), 2*N<sup>2</sup> for the dp array we are using.</p>
<p></p>
</details>
</div>
</details>
</div>
<!-- Optimal Approach Starts from here -->
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
Video Explanation
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" class="lazy-loaded" data-lazy-type="iframe" data-src="https://www.youtube.com/embed/MM7fXopgyjw?si=ZbpkluRrsSgotYXy" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/MM7fXopgyjw?feature=oembed" title="Evaluate Boolean Expression to True" width="810"></iframe><noscript>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/MM7fXopgyjw?si=ZbpkluRrsSgotYXy" title="Evaluate Boolean Expression to True" width="810"></iframe></noscript>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<script>

const codeSections = document.querySelectorAll('.code-section');

// Get last selected language from localStorage or set default value
let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

// Update last selected language for all sections and store in localStorage
lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

// Handle copy button click event
copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

// Set initial state of the tabs
codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<script>
const codeSections = document.querySelectorAll('.code-section');

let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
<!-- /wp:html -->
<!-- wp:html -->
<script src="https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js"></script>
<!-- /wp:html -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noreferrer noopener" target="_blank"><strong>KRITIDIPTA GHOSH</strong></a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>