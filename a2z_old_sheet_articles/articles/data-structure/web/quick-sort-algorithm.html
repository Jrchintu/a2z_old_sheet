<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Quick Sort Algorithm</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1; /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs); /* 5px */
            padding: var(--spacing-sm); /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm); /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm); /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1em;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg); /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px; /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm); /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto; /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm); /* 10px */
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Quick Sort Algorithm</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong>  Given an array of n integers, sort the array using the <strong>Quicksort</strong> method.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong>  N = 5  , Arr[] = {4,1,7,9,3}
<strong>Output:</strong> 1 3 4 7 9 

<strong>Explanation:</strong> After sorting the array becomes 1, 3, 4, 7, 9

<strong>Example 2:</strong>
<strong>Input:</strong> N = 8 , Arr[] = {4,6,2,5,7,9,1,3}
<strong>Output:</strong> 1 2 3 4 5 6 7 9
<strong>Explanation:</strong> After sorting the array becomes 1, 3, 4, 7, 9</pre>
<!-- /wp:preformatted -->
<!-- wp:heading {"level":3} -->
<h3><strong>Solution</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><a href="https://www.codingninjas.com/codestudio/problems/quick-sort_983625?utm_source=youtube&amp;utm_medium=affiliate&amp;utm_campaign=striver_Arrayproblems"><em>Problem Link</em></a><em>.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Intuition:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Quick Sort is a divide-and-conquer algorithm like <a href="https://takeuforward.org/data-structure/merge-sort-algorithm/">the Merge Sort</a>. But unlike Merge sort, this algorithm does not use any extra array for sorting(though it uses an auxiliary stack space). So, from that perspective, Quick sort is slightly better than Merge sort.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>This algorithm is basically a repetition of two simple steps that are the following:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Pick a pivot and place it in its correct place in the sorted array.</li><li>Shift smaller elements(i.e. Smaller than the pivot) on the left of the pivot and larger ones to the right.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>Now, let’s discuss the steps in detail considering the array {4,6,2,5,7,9,1,3}:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Step 1: </strong>The first thing is to choose the pivot. <strong><em>A pivot is basically a chosen element of the given array.</em></strong> The element or the pivot can be chosen by our choice. So, in an array a pivot can be any of the following:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>The first element of the array</li><li>The last element of the array</li><li>Median of array</li><li>Any Random element of the array</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>After choosing the pivot(i.e. the element), we should place it in its correct position(<em>i.e. The place it should be after the array gets sorted</em>) in the array. For example, if the given array is {4,6,2,5,7,9,1,3}, the correct position of 4 will be the 4th position.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note:</strong> <em>Here in this tutorial, we have chosen the first element as our pivot. You can choose any element as per your choice.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Step 2: </strong>In step 2, we will shift the smaller elements(i.e. Smaller than the pivot) to the left of the pivot and the larger ones to the right of the pivot. In the example, if the chosen pivot is 4, after performing step 2 the array will look like: {3, 2, 1, 4, 6, 5, 7, 9}. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>From the explanation, we can see that after completing the steps, pivot 4 is in its correct position with the left and right subarray unsorted. Now <strong>we will apply these two steps on the left subarray and the right subarray recursively</strong>. And we will continue this process until the size of the unsorted part becomes 1(as an array with a single element is always sorted).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>So, from the above intuition, we can get a clear idea that we are going to use recursion in this algorithm.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>To summarize, the main intention of this process is to place the pivot, after each recursion call, at its final position, where the pivot should be in the final sorted array.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now, let’s understand how we are going to implement the logic of the above steps. In the intuition, we have seen that the given array should be broken down into subarrays. But while implementing, we are not going to break down and create any new arrays. Instead, we will specify the range of the subarrays using two indices or pointers(i.e. <strong>low </strong>pointer and <strong>high </strong>pointer) each time while breaking down the array.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are the following for the <strong>quickSort()</strong> function:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>Initially, the <strong>low</strong> points to the first index and the <strong>high</strong> points to the last index(as the range is n i.e. the size of the array). </li><li>After that, we will get the index(<em>where the pivot should be placed after sorting</em>) while shifting the smaller elements on the left and the larger ones on the right using a partition() function discussed later.<br/>Now, this index can be called the <strong>partition index</strong> as it creates a partition between the left and the right unsorted subarrays.</li><li>After placing the pivot in the partition index(within the partition() function specified), we need to call the function quickSort() for the left and the right subarray recursively. So, <strong>the range of the left subarray will be [low to (partition index - 1)]</strong> and <strong>the range of the right subarray will be [(partition index + 1) to high]. </strong></li><li>This is how the recursion will continue until the range becomes 1.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Pseudocode:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>So, the pseudocode will look like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7750,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7750" src="assets/3283ecfad19c281a9e96e83469e1aa14.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Now, let’s understand how to implement the partition() function to get the partition index.</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>Inside the function, we will first select the pivot(<em>i.e. </em>arr[low]<em> in our case</em>).</li><li>Now, we will again take two-pointers i and j. The i pointer points to low and the j points to high.</li><li>Now, the pointer i will move forward and find the first element that is greater than the pivot. Similarly, the pointer j will move backward and find the first element that is smaller than the pivot.<br/><em>Here, we need to add some checks like i &lt;= high-1 and j &gt;= low+1. Because it might happen that i is standing at high and trying to proceed or j is standing at low and trying to exceed.</em></li><li>Once we find such elements i.e. arr[i] &gt; pivot and arr[j] &lt; pivot, and i &lt; j, we will swap arr[i] and arr[j].</li><li>We will continue step 3 and step 4, until j becomes smaller than i.</li><li>Finally, we will swap the pivot element(i.e. arr[low]) with arr[j] and will return the index j i.e. the partition index.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Pseudocode:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>So, the pseudocode will look like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7751,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7751" src="assets/0a1085cc664b57fde8435c0c340bf260.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>In the function, we have kept the elements equal to the pivot on the left side. If you choose to place them on the right, check 1 will be arr[i] &lt; pivot and check 2 will be arr[j] &gt;= pivot.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>If you wish to see the dry run, refer to the video attached below.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

int partition(vector&lt;int&gt; &amp;arr, int low, int high) {
    int pivot = arr[low];
    int i = low;
    int j = high;

    while (i &lt; j) {
        while (arr[i] &lt;= pivot &amp;&amp; i &lt;= high - 1) {
            i++;
        }

        while (arr[j] &gt; pivot &amp;&amp; j &gt;= low + 1) {
            j--;
        }
        if (i &lt; j) swap(arr[i], arr[j]);
    }
    swap(arr[low], arr[j]);
    return j;
}

void qs(vector&lt;int&gt; &amp;arr, int low, int high) {
    if (low &lt; high) {
        int pIndex = partition(arr, low, high);
        qs(arr, low, pIndex - 1);
        qs(arr, pIndex + 1, high);
    }
}

vector&lt;int&gt; quickSort(vector&lt;int&gt; arr) {
    qs(arr, 0, arr.size() - 1);
    return arr;
}

int main()
{
    vector&lt;int&gt; arr = {4, 6, 2, 5, 7, 9, 1, 3};
    int n = arr.size();
    cout &lt;&lt; "Before Using quick Sort: " &lt;&lt; endl;
    for (int i = 0; i &lt; n; i++)
    {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    arr = quickSort(arr);
    cout &lt;&lt; "After Using quick sort: " &lt;&lt; "\n";
    for (int i = 0; i &lt; n; i++) {
        cout &lt;&lt; arr[i] &lt;&lt; " ";
    }
    cout &lt;&lt; "\n";
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong><strong><br/></strong>Before Using quick Sort:<br/>4 6 2 5 7 9 1 3<br/>After Using quick sort:<br/>1 2 3 4 5 6 7 9 </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N*logN), where N = size of the array.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Reason:</strong> At each step, we divide the whole array, for that logN and n steps are taken for the partition() function, so overall time complexity will be N*logN.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The following recurrence relation can be written for Quick sort : </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>F(n) = F(k) + F(n-1-k) </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Here k is the number of elements smaller or equal to the pivot and n-1-k denotes elements greater than the pivot.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>There can be 2 cases :</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Worst Case</strong> – This case occurs when the pivot is the greatest or smallest element of the array. If the partition is done and the last element is the pivot, then the worst case would be either in the increasing order of the array or in the decreasing order of the array. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Recurrence:</strong><br/><strong>F(n) = F(0)+F(n-1)  or  F(n) = F(n-1) + F(0) </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Worst Case Time complexity: O(n</strong><strong><sup>2</sup></strong><strong>)</strong> </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Best Case – This case occurs when the pivot is the middle element or near to middle element of the array.<br/>Recurrence :<br/>F(n) = 2F(n/2)<br/><br/>Time Complexity for the best and average case: O(N*logN)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) + O(N) auxiliary stack space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;

class Solution {
    static int partition(List&lt;Integer&gt; arr, int low, int high) {
        int pivot = arr.get(low);
        int i = low;
        int j = high;

        while (i &lt; j) {
            while (arr.get(i) &lt;= pivot &amp;&amp; i &lt;= high - 1) {
                i++;
            }

            while (arr.get(j) &gt; pivot &amp;&amp; j &gt;= low + 1) {
                j--;
            }
            if (i &lt; j) {
                int temp = arr.get(i);
                arr.set(i, arr.get(j));
                arr.set(j, temp);
            }
        }
        int temp = arr.get(low);
        arr.set(low, arr.get(j));
        arr.set(j, temp);
        return j;
    }

    static void qs(List&lt;Integer&gt; arr, int low, int high) {
        if (low &lt; high) {
            int pIndex = partition(arr, low, high);
            qs(arr, low, pIndex - 1);
            qs(arr, pIndex + 1, high);
        }
    }
    public static List&lt;Integer&gt; quickSort(List&lt;Integer&gt; arr) {
        // Write your code here.
        qs(arr, 0, arr.size() - 1);
        return arr;
    }
}

public class tUf {
    public static void main(String args[]) {
        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
        arr = Arrays.asList(new Integer[] {4, 6, 2, 5, 7, 9, 1, 3});
        int n = arr.size();
        System.out.println("Before Using insertion Sort: ");
        for (int i = 0; i &lt; n; i++) {
            System.out.print(arr.get(i) + " ");
        }
        System.out.println();
        arr = Solution.quickSort(arr);
        System.out.println("After insertion sort: ");
        for (int i = 0; i &lt; n; i++) {
            System.out.print(arr.get(i) + " ");
        }
        System.out.println();
    }

} 
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong><strong><br/></strong>Before Using quick Sort:<br/>4 6 2 5 7 9 1 3<br/>After Using quick sort:<br/>1 2 3 4 5 6 7 9 </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N*logN), where N = size of the array.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Reason:</strong> At each step, we divide the whole array, for that logN and n steps are taken for partition() function, so overall time complexity will be N*logN.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The following recurrence relation can be written for Quick sort : </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>F(n) = F(k) + F(n-1-k) </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Here k is the number of elements smaller or equal to the pivot and n-1-k denotes elements greater than the pivot.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>There can be 2 cases :</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Worst Case</strong> – This case occurs when the pivot is the greatest or smallest element of the array. If the partition is done and the last element is the pivot, then the worst case would be either in the increasing order of the array or in the decreasing order of the array. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Recurrence:</strong><br/><strong>F(n) = F(0)+F(n-1)  or  F(n) = F(n-1) + F(0) </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Worst Case Time complexity: O(n</strong><strong><sup>2</sup></strong><strong>)</strong> </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Best Case – This case occurs when the pivot is the middle element or near to middle element of the array.<br/>Recurrence :<br/>F(n) = 2F(n/2)<br/><br/>Time Complexity for the best and average case: O(N*logN)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) + O(N) auxiliary stack space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/shreyas-vishwakarma-06517b190/" rel="noreferrer noopener" target="_blank"><strong>Shreyas Vishwakarma</strong></a></strong> and <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noopener" target="_blank" title="">KRITIDIPTA GHOSH</a></strong></em> <em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>
