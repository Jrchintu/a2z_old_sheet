<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Right/Left view of binary tree</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            /* margin: 5px; */
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                /* margin: 5px; */
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Right/Left view of binary tree</h1>
</header>
<article>
<p><strong>Problem Statement: </strong> Given a Binary Tree, return its right and left views.</p>
<p>
The Right View of a Binary Tree is a list of nodes that can be seen when the tree is viewed from the right side. The Left View of a Binary Tree is a list of nodes that can be seen when the tree is viewed from the left side.

</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
                <span><strong>Input:</strong>Binary Tree: 1 2 3 4 10 9 11 -1 5 -1 -1 -1 -1 -1 -1 -1 6 </span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/148ffc0347de5524fbd3fa5e6d9d14df" width="439"/></figure>
                <span><strong>Output:</strong> Left View: [1, 2, 4, 5, 6] , Right View: [1, 3, 11, 5, 6]</span>
                
                <span><strong>Explanation: </strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/1fb110763a024f2fe2d60172d5b74631" width="439"/></figure>
                
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong>Binary Tree: 2 7 5 2 6 -1 9 -1 -1 5 11 4 -1
                </span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/1638c327c3222c593a8499453239107e" width="439"/></figure>
                <span><strong>Output :</strong>Left View Traversal:[2,7,2,5], Right View Traversal:[2,5,9,4] </span>
                
                <span><strong>Explanation: </strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/f61963afb014aeffe4ce10e5cfbfddd1" width="439"/></figure>
                

            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/left-view-of-binary-tree_625707?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1:</strong> Initialise an empty queue data structure to store the nodes during traversal. Create a 2D array or a vector of a vector to store the level order traversal. If the tree is empty, return this empty 2D vector.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/09572c3dc0acb7cd866d6181f60a4135" width="439"/></figure>
<p><strong>Step 2:</strong>Enqueue the root node ie. Add the root node of the binary tree to the queue.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/44748608fc31bd18bce3431c9e8917b0" width="439"/></figure>
<p><strong>Step 3:</strong>Iterate until the queue is empty:
                        <ol><li>Get the current size of the queue. This size indicates the number of nodes at the current level.</li><li>Create a vector ‘level’ to store the nodes at the current level.</li><li>Iterate through ‘size’ number of nodes at the current level:</li>
<ol><li>Pop the front node from the queue.</li><li>Store the node’s value in the level vector.</li><li>Enqueue the left and right child nodes of the current node (if they exist) into the queue.</li></ol>
<li>After processing all the nodes at the current level, add the ‘level’ vector to the ‘ans’ 2D vector, representing the current level.</li></ol></p><figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/2713ae10ac28bf65588ab6ba7af0fd01" width="439"/></figure>
<p><strong>Step 4: </strong>Once the traversal loop completes, the 'ans' 2D vector now contains the level order traversal of the binary tree. To obtain the left view and right view we use each level's vector in the 'ans' vector</p>
<p><strong>Left View: </strong>For each level, extract the first element from the vector and store it in a separate array. Return this array as the final left view of the binary tree.</p>
<p><strong>Right View: </strong>For each level, extract the last element from the vector and store it in a separate array. Return this array as the final right view of the binary tree.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/83bcd6abc6e663bc80ee6f8141d6b72f" width="439"/></figure>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

// Node structure for the binary tree
struct Node {
    int data;
    Node* left;
    Node* right;
    // Constructor to initialize
    // the node with a value
    Node(int val) : data(val),
        left(nullptr), right(nullptr) {}
};

class Solution {
public:
    // Function to return the
    // Right view of the binary tree
    vector&lt;int&gt; rightsideView(Node* root) {
        // Vector to store
        // the result
        vector&lt;int&gt; res;

        // Get the level order
        // traversal of the tree
        vector&lt;vector&lt;int&gt;&gt; levelTraversal = levelOrder(root);

        // Iterate through each level and
        // add the last element to the result
        for (auto level : levelTraversal) {
            res.push_back(level.back());
        }

        return res;
    }

    // Function to return the
    // Left view of the binary tree
    vector&lt;int&gt; leftsideView(Node* root) {
        // Vector to store the result
        vector&lt;int&gt; res;

        // Get the level order
        // traversal of the tree
        vector&lt;vector&lt;int&gt;&gt; levelTraversal = levelOrder(root);

        // Iterate through each level and
        // add the first element to the result
        for (auto level : levelTraversal) {
            res.push_back(level.front());
        }

        return res;
    }

private:
    // Function that returns the
    // level order traversal of a Binary tree 
    vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) {
        vector&lt;vector&lt;int&gt;&gt; ans;

        // Return an empty vector
        // if the tree is empty
        if (!root) {
            return ans;
        }

        // Use a queue to perform
        // level order traversal
        queue&lt;Node*&gt; q;
        q.push(root);

        while (!q.empty()) {
            int size = q.size();
            vector&lt;int&gt; level;

            // Process each node
            // in the current level
            for (int i = 0; i &lt; size; i++) {
                Node* top = q.front();
                level.push_back(top-&gt;data);
                q.pop();

                // Enqueue the left
                // child if it exists
                if (top-&gt;left != NULL) {
                    q.push(top-&gt;left);
                }

                // Enqueue the right
                // child if it exists
                if (top-&gt;right != NULL) {
                    q.push(top-&gt;right);
                }
            }

            // Add the current
            // level to the result
            ans.push_back(level);
        }

        return ans;
    }
};




int main() {
    // Creating a sample binary tree
    Node* root = new Node(1);
    root-&gt;left = new Node(2);
    root-&gt;left-&gt;left = new Node(4);
    root-&gt;left-&gt;right = new Node(10);
    root-&gt;left-&gt;left-&gt;right = new Node(5);
    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);
    root-&gt;right = new Node(3);
    root-&gt;right-&gt;right = new Node(10);
    root-&gt;right-&gt;left = new Node(9);

    Solution solution;

        // Get the Right View traversal
    vector&lt;int&gt; rightView = solution.rightsideView(root);

    // Print the result for Right View
    cout &lt;&lt; "Right View Traversal: ";
    for(auto node: rightView){
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    // Get the Left View traversal
    vector&lt;int&gt; leftView = solution.leftsideView(root);

    // Print the result for Left View
    cout &lt;&lt; "Left View Traversal: ";
    for(auto node: leftView){
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.ArrayList;
import java.util.List;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {

    // Function to return the Right view of the binary tree
    public List&lt;Integer&gt; rightsideView(Node root) {
        // List to store the result
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

        // Call the recursive function
        // to populate the right-side view
        recursionRight(root, 0, res);

        return res;
    }

    // Function to return the Left view of the binary tree
    public List&lt;Integer&gt; leftsideView(Node root) {
        // List to store the result
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

        // Call the recursive function
        // to populate the left-side view
        recursionLeft(root, 0, res);

        return res;
    }

    // Recursive function to traverse the
    // binary tree and populate the left-side view
    private void recursionLeft(Node root, int level, List&lt;Integer&gt; res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);
        }

        // Recursively call the function for the
        // left child with an increased level
        recursionLeft(root.left, level + 1, res);

        // Recursively call the function for the
        // right child with an increased level
        recursionLeft(root.right, level + 1, res);
    }

    // Recursive function to traverse the
    // binary tree and populate the right-side view
    private void recursionRight(Node root, int level, List&lt;Integer&gt; res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);

            // Recursively call the function for the
            // right child with an increased level
            recursionRight(root.right, level + 1, res);

            // Recursively call the function for the
            // left child with an increased level
            recursionRight(root.left, level + 1, res);
        }
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Right View traversal
        List&lt;Integer&gt; rightView = solution.rightsideView(root);

        // Print the result for Right View
        System.out.print("Right View Traversal: ");
        for (int node : rightView) {
            System.out.print(node + " ");
        }
        System.out.println();

        // Get the Left View traversal
        List&lt;Integer&gt; leftView = solution.leftsideView(root);

        // Print the result for Left View
        System.out.print("Left View Traversal: ");
        for (int node : leftView) {
            System.out.print(node + " ");
        }
        System.out.println();
    }
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
 # Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to get the left
# and right view of the binary tree
class Solution:
    def rightsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the right-side view
        self.recursionRight(root, 0, res)
        
        return res

    def leftsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the left-side view
        self.recursionLeft(root, 0, res)
        
        return res

    # Recursive function to traverse the
    # binary tree and populate the left-side view
    def recursionLeft(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
        
        # Recursively call the function for the
        # left child with an increased level
        self.recursionLeft(root.left, level + 1, res)
        
        # Recursively call the function for the
        # right child with an increased level
        self.recursionLeft(root.right, level + 1, res)

    # Recursive function to traverse the
    # binary tree and populate the right-side view
    def recursionRight(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
            
            # Recursively call the function for the
            # right child with an increased level
            self.recursionRight(root.right, level + 1, res)
            
            # Recursively call the function for the
            # left child with an increased level
            self.recursionRight(root.left, level + 1, res)

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

solution = Solution()

# Get the Right View traversal
rightView = solution.rightsideView(root)

# Print the result for Right View
print("Right View Traversal:", end=" ")
for node in rightView:
    print(node, end=" ")
print()

# Get the Left View traversal
leftView = solution.leftsideView(root)

# Print the result for Left View
print("Left View Traversal:", end=" ")
for node in leftView:
    print(node, end=" ")
print()
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node class for the binary tree
class Node {
    constructor(val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to return the
    // Right view of the binary tree
    rightsideView(root) {
        // Array to store the result
        const res = [];

        // Call the recursive function
        // to populate the right-side view
        this.recursionRight(root, 0, res);

        return res;
    }

    // Function to return the
    // Left view of the binary tree
    leftsideView(root) {
        // Array to store the result
        const res = [];

        // Call the recursive function
        // to populate the left-side view
        this.recursionLeft(root, 0, res);

        return res;
    }

    // Recursive function to traverse the
    // binary tree and populate the left-side view
    recursionLeft(root, level, res) {
        // Check if the current node is null
        if (!root) {
            return;
        }

        // Check if the size of the result array
        // is equal to the current level
        if (res.length === level) {
            // If equal, add the value of the
            // current node to the result array
            res.push(root.data);
        }

        // Recursively call the function for the
        // left child with an increased level
        this.recursionLeft(root.left, level + 1, res);

        // Recursively call the function for the
        // right child with an increased level
        this.recursionLeft(root.right, level + 1, res);
    }

    // Recursive function to traverse the
    // binary tree and populate the right-side view
    recursionRight(root, level, res) {
        // Check if the current node is null
        if (!root) {
            return;
        }

        // Check if the size of the result array
        // is equal to the current level
        if (res.length === level) {
            // If equal, add the value of the
            // current node to the result array
            res.push(root.data);

            // Recursively call the function for the
            // right child with an increased level
            this.recursionRight(root.right, level + 1, res);

            // Recursively call the function for the
            // left child with an increased level
            this.recursionRight(root.left, level + 1, res);
        }
    }
}

// Creating a sample binary tree
const root = new Node(1);
root.left = new Node(2);
root.left.left = new Node(4);
root.left.right = new Node(10);
root.left.left.right = new Node(5);
root.left.left.right.right = new Node(6);
root.right = new Node(3);
root.right.right = new Node(10);
root.right.left = new Node(9);

const solution = new Solution();

// Get the Right View traversal
const rightView = solution.rightsideView(root);

// Print the result for Right View
console.log("Right View Traversal:", rightView.join(" "));

// Get the Left View traversal
const leftView = solution.leftsideView(root);

// Print the result for Left View
console.log("Left View Traversal:", leftView.join(" "));

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Right View Traversal: 1 3 10, Left View Traversal: 1 2 4 5 6 </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(N)</strong> where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.</p>
<p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N). The resultant vector answer also stores the values of the nodes level by level and hence contains all the nodes of the tree contributing to O(N) space as well.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>To get the left and right view of a Binary Tree, we perform a depth-first traversal of the Binary Tree while keeping track of the level of each node. For both the left and right view, we’ll ensure that only the first node encountered at each level is added to the result vector.</p>
<p><strong>Algorithm for Left View</strong></p>
<p><strong>Step 1: </strong>Initialise an empty vector `res` to store the left view nodes.</p>
<p><strong>Step 2: </strong>Implement a recursive depth-first traversal of the binary tree. </p>
<p><strong>Base Case: </strong>Check if the current node is null, if true, return the function as we have reached the end of that particular vertical level.</p>
<p><strong>Recursive Function: </strong>The recursive function takes in arguments the current node of the Binary Tree, its current level and the result vector.
                        <ol><li>We check if the size of the result vector is equal to the current level.</li><li>If true, it means that we have not yet encountered any node at this level in the result vector. Add the value of the current node to the result vector.</li><li>Recursively call the function for the current nodes left then right child with an increased level ie. level + 1.</li><li>We call the left child first as we want to traverse the left most nodes. In cases where there is no left child, the recursion function backtracks and explores the right child.</li></ol></p>
<p><strong>Step 3: </strong>The recursion continues until it reaches the base case. Return the result vector at the end.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/dc4e3c27177e54b0cfee764a09697e4f" width="600"/></figure>
<p><strong>Algorithm for Right View</strong></p>
<p><strong>Step 1: </strong>Initialise an empty vector `res` to store the left view nodes.</p>
<p><strong>Step 2: </strong>Implement a recursive depth-first traversal of the binary tree. </p>
<p><strong>Base Case: </strong>Check if the current node is null, if true, return the function as we have reached the end of that particular vertical level.</p>
<p><strong>Recursive Function: </strong>The recursive function takes in arguments the current node of the Binary Tree, its current level and the result vector.
                        <ol><li>We check if the size of the result vector is equal to the current level.</li><li>If true, it means that we have not yet encountered any node at this level in the result vector. Add the value of the current node to the result vector.</li><li>Recursively call the function for the current nodes right then left child with an increased level ie. level + 1.</li><li>We call the right child first as we want to traverse the right most nodes. In cases where there is no right child, the recursion function backtracks and explores the left child.</li></ol></p>
<p><strong>Step 3: </strong>The recursion continues until it reaches the base case. Return the result vector at the end.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/ff0ebfec6b89fffb03fa8625a26a02c5" width="600"/></figure>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

// Node structure for the binary tree
struct Node {
    int data;
    Node* left;
    Node* right;
    // Constructor to initialize
    // the node with a value
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    // Function to return the Right view of the binary tree
    vector&lt;int&gt; rightsideView(Node* root){
        // Vector to store the result
        vector&lt;int&gt; res;
        
        // Call the recursive function
        // to populate the right-side view
        recursionRight(root, 0, res);
        
        return res;
    }
    
    // Function to return the Left view of the binary tree
    vector&lt;int&gt; leftsideView(Node* root){
        // Vector to store the result
        vector&lt;int&gt; res;
        
        // Call the recursive function
        // to populate the left-side view
        recursionLeft(root, 0, res);
        
        return res;
    }

private:
    // Recursive function to traverse the
    // binary tree and populate the left-side view
    void recursionLeft(Node* root, int level, vector&lt;int&gt;&amp; res){
        // Check if the current node is NULL
        if(root == NULL){
            return;
        }
        
        // Check if the size of the result vector
        // is equal to the current level
        if(res.size() == level){
            // If equal, add the value of the
            // current node to the result vector
            res.push_back(root-&gt;data);
        }
        
        // Recursively call the function for the
        // left child with an increased level
        recursionLeft(root-&gt;left, level + 1, res);
        
        // Recursively call the function for the
        // right child with an increased level
        recursionLeft(root-&gt;right, level + 1, res);
    }
    
    // Recursive function to traverse the
    // binary tree and populate the right-side view
    void recursionRight(Node* root, int level, vector&lt;int&gt; &amp;res){
        // Check if the current node is NULL
        if(root == NULL){
            return;
        }
        
        // Check if the size of the result vector
        // is equal to the current level
        if(res.size() == level){
            // If equal, add the value of the
            // current node to the result vector
            res.push_back(root-&gt;data);
            
            // Recursively call the function for the
            // right child with an increased level
            recursionRight(root-&gt;right, level + 1, res);
            
            // Recursively call the function for the
            // left child with an increased level
            recursionRight(root-&gt;left, level + 1, res);
        }
    }
};



int main() {
    // Creating a sample binary tree
    Node* root = new Node(1);
    root-&gt;left = new Node(2);
    root-&gt;left-&gt;left = new Node(4);
    root-&gt;left-&gt;right = new Node(10);
    root-&gt;left-&gt;left-&gt;right = new Node(5);
    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);
    root-&gt;right = new Node(3);
    root-&gt;right-&gt;right = new Node(10);
    root-&gt;right-&gt;left = new Node(9);

    Solution solution;

        // Get the Right View traversal
    vector&lt;int&gt; rightView = solution.rightsideView(root);

    // Print the result for Right View
    cout &lt;&lt; "Right View Traversal: ";
    for(auto node: rightView){
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    // Get the Left View traversal
    vector&lt;int&gt; leftView = solution.leftsideView(root);

    // Print the result for Left View
    cout &lt;&lt; "Left View Traversal: ";
    for(auto node: leftView){
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.ArrayList;
import java.util.List;

// Node structure for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {

    // Function to return the Right view of the binary tree
    public List&lt;Integer&gt; rightsideView(Node root) {
        // List to store the result
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

        // Call the recursive function
        // to populate the right-side view
        recursionRight(root, 0, res);

        return res;
    }

    // Function to return the Left view of the binary tree
    public List&lt;Integer&gt; leftsideView(Node root) {
        // List to store the result
        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();

        // Call the recursive function
        // to populate the left-side view
        recursionLeft(root, 0, res);

        return res;
    }

    // Recursive function to traverse the
    // binary tree and populate the left-side view
    private void recursionLeft(Node root, int level, List&lt;Integer&gt; res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);
        }

        // Recursively call the function for the
        // left child with an increased level
        recursionLeft(root.left, level + 1, res);

        // Recursively call the function for the
        // right child with an increased level
        recursionLeft(root.right, level + 1, res);
    }

    // Recursive function to traverse the
    // binary tree and populate the right-side view
    private void recursionRight(Node root, int level, List&lt;Integer&gt; res) {
        // Check if the current node is null
        if (root == null) {
            return;
        }

        // Check if the size of the result list
        // is equal to the current level
        if (res.size() == level) {
            // If equal, add the value of the
            // current node to the result list
            res.add(root.data);

            // Recursively call the function for the
            // right child with an increased level
            recursionRight(root.right, level + 1, res);

            // Recursively call the function for the
            // left child with an increased level
            recursionRight(root.left, level + 1, res);
        }
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Right View traversal
        List&lt;Integer&gt; rightView = solution.rightsideView(root);

        // Print the result for Right View
        System.out.print("Right View Traversal: ");
        for (int node : rightView) {
            System.out.print(node + " ");
        }
        System.out.println();

        // Get the Left View traversal
        List&lt;Integer&gt; leftView = solution.leftsideView(root);

        // Print the result for Left View
        System.out.print("Left View Traversal: ");
        for (int node : leftView) {
            System.out.print(node + " ");
        }
        System.out.println();
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
# Node class for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

# Solution class to get the left
# and right view of the binary tree
class Solution:
    def rightsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the right-side view
        self.recursionRight(root, 0, res)
        
        return res

    def leftsideView(self, root):
        # Vector to store the result
        res = []
        
        # Call the recursive function
        # to populate the left-side view
        self.recursionLeft(root, 0, res)
        
        return res

    # Recursive function to traverse the
    # binary tree and populate the left-side view
    def recursionLeft(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
        
        # Recursively call the function for the
        # left child with an increased level
        self.recursionLeft(root.left, level + 1, res)
        
        # Recursively call the function for the
        # right child with an increased level
        self.recursionLeft(root.right, level + 1, res)

    # Recursive function to traverse the
    # binary tree and populate the right-side view
    def recursionRight(self, root, level, res):
        # Check if the current node is None
        if not root:
            return
        
        # Check if the size of the result list
        # is equal to the current level
        if len(res) == level:
            # If equal, add the value of the
            # current node to the result list
            res.append(root.data)
            
            # Recursively call the function for the
            # right child with an increased level
            self.recursionRight(root.right, level + 1, res)
            
            # Recursively call the function for the
            # left child with an increased level
            self.recursionRight(root.left, level + 1, res)

# Creating a sample binary tree
root = Node(1)
root.left = Node(2)
root.left.left = Node(4)
root.left.right = Node(10)
root.left.left.right = Node(5)
root.left.left.right.right = Node(6)
root.right = Node(3)
root.right.right = Node(10)
root.right.left = Node(9)

solution = Solution()

# Get the Right View traversal
rightView = solution.rightsideView(root)

# Print the result for Right View
print("Right View Traversal:", end=" ")
for node in rightView:
    print(node, end=" ")
print()

# Get the Left View traversal
leftView = solution.leftsideView(root)

# Print the result for Left View
print("Left View Traversal:", end=" ")
for node in leftView:
    print(node, end=" ")
print()
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node class for the binary tree
class Node {
    constructor(val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to return the
    // Right view of the binary tree
    rightsideView(root) {
        // Array to store the result
        const res = [];

        // Call the recursive function
        // to populate the right-side view
        this.recursionRight(root, 0, res);

        return res;
    }

    // Function to return the
    // Left view of the binary tree
    leftsideView(root) {
        // Array to store the result
        const res = [];

        // Call the recursive function
        // to populate the left-side view
        this.recursionLeft(root, 0, res);

        return res;
    }

    // Recursive function to traverse the
    // binary tree and populate the left-side view
    recursionLeft(root, level, res) {
        // Check if the current node is null
        if (!root) {
            return;
        }

        // Check if the size of the result array
        // is equal to the current level
        if (res.length === level) {
            // If equal, add the value of the
            // current node to the result array
            res.push(root.data);
        }

        // Recursively call the function for the
        // left child with an increased level
        this.recursionLeft(root.left, level + 1, res);

        // Recursively call the function for the
        // right child with an increased level
        this.recursionLeft(root.right, level + 1, res);
    }

    // Recursive function to traverse the
    // binary tree and populate the right-side view
    recursionRight(root, level, res) {
        // Check if the current node is null
        if (!root) {
            return;
        }

        // Check if the size of the result array
        // is equal to the current level
        if (res.length === level) {
            // If equal, add the value of the
            // current node to the result array
            res.push(root.data);

            // Recursively call the function for the
            // right child with an increased level
            this.recursionRight(root.right, level + 1, res);

            // Recursively call the function for the
            // left child with an increased level
            this.recursionRight(root.left, level + 1, res);
        }
    }
}

// Creating a sample binary tree
const root = new Node(1);
root.left = new Node(2);
root.left.left = new Node(4);
root.left.right = new Node(10);
root.left.left.right = new Node(5);
root.left.left.right.right = new Node(6);
root.right = new Node(3);
root.right.right = new Node(10);
root.right.left = new Node(9);

const solution = new Solution();

// Get the Right View traversal
const rightView = solution.rightsideView(root);

// Print the result for Right View
console.log("Right View Traversal:", rightView.join(" "));

// Get the Left View traversal
const leftView = solution.leftsideView(root);

// Print the result for Left View
console.log("Left View Traversal:", leftView.join(" "));                  
                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Right View Traversal: 1 3 10, Left View Traversal: 1 2 4 5 6 </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity:  O(log2N)</strong> where N is the number of nodes in the Binary Tree. This complexity arises as we travel along the height of the Binary Tree. For a balanced binary tree, the height is log2N but in the worst case when the tree is skewed, the complexity becomes O(N). </p>
<p><strong>Space Complexity : O(log2N)</strong>   where N is the number of nodes in the Binary Tree. This complexity arises because we store the leftmost and rightmost nodes in an additional vector. The size of this result vector is proportional to the height of the Binary Tree which will be log2N when the tree is balanced and O(N) in the worst case of a skewed tree.
                        <ol><li>O(H): Recursive Stack Space is used to calculate the height of the tree at each node which is proportional to the height of the tree. </li><li>The recursive nature of the getHeight function, which incurs space on the call stack for each recursive call until it reaches the leaf nodes or the height of the tree.</li></ol> </p>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/KV4mRzTjlAk?si=SxrGZ92mA1SSlTh3" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>