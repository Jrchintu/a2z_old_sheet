<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Wildcard Matching | (DP-34)</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* Practice */
        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: 20px auto;
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Wildcard Matching | (DP-34)</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement: </strong>Wildcard Matching</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We are given two strings ‘S1’ and ‘S2’. String S1 can have the following two special characters:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>‘?’ can be matched to a single character of S2.</li><li>‘*’ can be matched to any sequence of characters of S2. (sequence can be of length zero or more).</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>We need to check whether strings S1 and S2 match or not.</p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
Examples
</strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted"><!-- Insert New Examples Here -->
<pre class="wp-block-preformatted"><strong>Example:</strong>

<img height="391" src="assets/c4f692fad8f595b91fa5af9872ace3cb" width="624"/></pre>
</pre>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/wildcard-pattern-matching_701650?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/86dd2cadbd0e7ef71ad98d3b7f2f2efc.png"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out
yourself first. </em></p>
<!-- /wp:html -->
<!-- wp:html -->
<div class="horizontal_navbar_dsa_article">
<div class="grid_container_three">
<a class="three-boxes box-a" href="#brute-force-approach">
Memoization approach
</a>
<a class="three-boxes box-b" href="#better-approach">
Tabulation approach
</a>
<a class="three-boxes box-c" href="#optimal-approach">
Space Optimization
</a>
<a class="three-boxes box-d" href="#dsa_article_video_explanation">
<svg fill="none" height="26" viewbox="0 0 20 14" width="26" xmlns="http://www.w3.org/2000/svg">
<path d="M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z" fill="red"></path>
</svg>
</a>
<div class="box-e tooltip">
<svg fill="none" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z" fill="black"></path>
</svg>
<div class="bottom">
<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,
closes all other expands. You can manually expand more than one approach at a time</p>
<i></i>
</div>
</div>
</div>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Brute Force Approach Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
Memoization Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<h3><strong>Intuition: </strong></h3>
<p>For every index of string S1, we have different options to match that index with string S2. Therefore, we can think in terms of string matching path as we have done already in previous questions.</p>
<ul><li>Either the characters match already.</li><li>Or, if there is a ‘?’, we can explicitly match a single character.</li><li>For a ‘*’, the following figure explains the scenario.</li></ul>
<p><img height="324" src="assets/88af9c607a9615ff31f70e405c45fe66" width="594"/></p>
<p>As there is no uniformity in data, there is no other way to find out than to <strong>try out all possible ways</strong>. To do so we will need to use <strong>recursion</strong>.</p>
<p><strong>Steps to form the recursive solution: </strong></p>
<p>We will first form the recursive solution by the three points mentioned in the <a href="https://takeuforward.org/data-structure/dynamic-programming-introduction/" rel="noreferrer noopener" target="_blank">Dynamic Programming Introduction</a>. </p>
<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>
<p>We are given two strings. We can represent them with the help of two indexes i and j. Initially, i=n-1 and j=m-1, where n and m are lengths of strings S1 and S2. Initially, we will call f(n-1,m-1), which means whether string S1[0…n-1] matches with string S2[0…m-1].</p>
<p>We can generalize this as follows:</p>
<p><img height="75" src="assets/cc89e9060801e9c26fe707dbf5eb0ace" width="624"/></p>
<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>
<p>Now, i and j represent two characters from strings S1 and S2 respectively. There are only two options that make sense: either the characters represented by i and j match or they don’t.</p>
<p><strong>(i) When the characters match</strong></p>
<p><strong>if(S1[i]==S2[j])</strong>, </p>
<p>If this is true, the characters at i and j match, we can simply move to the next characters of both the strings. So we will just decrement both i and j by 1 and recursively find the answer for the remaining string portions. We return<strong> f(i-1,j-1)</strong>. The following figure makes it clear.</p>
<p><img height="398" src="assets/8f69e134f3255bda6b2ed317e041b2ac" width="165"/></p>
<p><strong>(ii) When the characters don’t match</strong></p>
<p>If the characters don’t match, there are three possible scenarios:</p>
<ol><li><strong>S1[i] == ‘?’</strong></li><li><strong>S1[i] == ‘*’</strong></li><li><strong>S1[i] is some other character</strong></li></ol>
<p>Let us discuss them one by one:</p>
<p><strong>(i) If S1[i] == ‘?’</strong></p>
<p>In this case, we can explicitly match ‘?’ at index i of S1 with the corresponding character at index j of S2. And then recursively call <strong>f(i-1,j-1)</strong> to check for the remaining string.</p>
<p><strong>(ii) If S1[i] == ‘*’</strong></p>
<p>This is an interesting case as now ‘*’ can be replaced with any sequence of characters( of length 0 or more) from S2.</p>
<p>We will revisit this example:</p>
<p><img height="347" src="assets/9eb05cae4e1e0983f56bad29308d5d80" width="624"/></p>
<p>If any of these cases return true, we can say that the characters do match. The next question is <strong>how to try all possible ways</strong>?</p>
<p>We are using two pointers i and j to represent characters of strings S1 and S2. We can surely write a for loop to compare characters from 0 to j of S2 for the above scenario. <strong>Can we do it more smartly? </strong>Yes, we can. Please understand the approach explained below.</p>
<p>We are using a recursive function f(i,j). If we do only the following two recursive calls:</p>
<ul><li>Call <strong>f(i-1,j)</strong>. i.e <strong>replace ‘*’ with nothing </strong>and act as if it was not present.</li><li>Call <strong>f(i,j-1)</strong>. i.e <strong>replace ‘*’ with a single character</strong> at index j and make the i pointer to still point at index i. In this, we matched it with a single character (one of the many options that need to be tried) and in the next recursive call, as i still point to ‘*’, we get the exact two recursive calls again.</li></ul>
<p>The following recursive tree will help us to understand the recursion better.</p>
<p><img height="490" src="assets/d297b0f6b5b3e20513647696e3c59d23" width="677"/></p>
<p>So we see how we can tackle all the required cases associated with ‘*’ by using recursion.</p>
<p><strong>(iii) If S1[i] is neither ‘?’ nor ‘*’</strong>, then we can say as the characters at i and j don’t match then the strings don’t match, so we return false.</p>
<p>To summarise:</p>
<ol><li>If S1[i] == ‘?’, return <strong>f(i-1,j)</strong></li><li>Else if S1[i] == ‘*’, return <strong>f(i-1,j) || f(i,j-1)</strong></li><li>Else return <strong>false</strong></li></ol>
<p><strong>Step 3: Return logical OR (||) of all the choices</strong></p>
<p>If any of the cases return true, we can say that strings do match. We can use OR operator (||) with the recursive calls.</p>
<p><strong>Base Cases:</strong></p>
<p>We are reducing i and j in our recursive relation, there can be two possibilities, either i becomes -1 or j becomes -1., i,e we exhaust either S1 or S2 respectively.</p>
<p><strong>(i) When S1 is exhausted:</strong></p>
<p>When S1 is exhausted (i&lt;0), we know that in order for the strings to match, String S2 should also exhaust simultaneously. If it does, we return true, else we return false.</p>
<p>We can say:</p>
<ul><li>if(i&lt;0 &amp;&amp; j&lt;0), return true.</li><li>if(i&lt;0 &amp;&amp; j&gt;=0), return false.</li></ul>
<p>(ii) When S2 is exhausted:</p>
<p>When S2 is exhausted(j&lt;0) and S1 has not, there is only one pattern that can account for true(matching of strings). It is if S1 is like this “*”,”****”,”***”, i.e: S1 contains only stars. Then we can replace every star with a sequence of length 0 and say that the string match.</p>
<p>If S1 is all-stars, we return true, else return false.</p>
<p>The final pseudocode after steps 1, 2, and 3:</p>
<p><img height="594" src="assets/d2aadbd3c97dc895a1624b2368fa673a" width="514"/></p>
<p><strong>Steps to memoize a recursive solution:</strong></p>
<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>
<ol><li>Create a dp array of size [n][m]. The size of S1 and S2 are n and m respectively, so the variable i will always lie between ‘0’ and ‘n-1’ and the variable j between ‘0’ and ‘m-1’.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li></ol>
<!-- /wp:list -->
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Function to check if a substring of S1 contains only '*'
bool isAllStars(string &amp;S1, int i) {
    for (int j = 0; j &lt;= i; j++) {
        if (S1[j] != '*')
            return false;
    }
    return true;
}

// Function to check if S1 matches S2 using wildcard pattern matching
bool wildcardMatchingUtil(string &amp;S1, string &amp;S2, int i, int j, vector&lt;vector&lt;bool&gt;&gt; &amp;dp) {
    // Base Cases
    if (i &lt; 0 &amp;&amp; j &lt; 0)
        return true;
    if (i &lt; 0 &amp;&amp; j &gt;= 0)
        return false;
    if (j &lt; 0 &amp;&amp; i &gt;= 0)
        return isAllStars(S1, i);

    // If the result for this state has already been calculated, return it
    if (dp[i][j] != -1)
        return dp[i][j];

    // If the characters at the current positions match or S1 has a '?'
    if (S1[i] == S2[j] || S1[i] == '?')
        return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);
    else {
        if (S1[i] == '*')
            // Two options: either '*' represents an empty string or it matches a character in S2
            return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) || wildcardMatchingUtil(S1, S2, i, j - 1, dp);
        else
            return false;
    }
}

// Main function to check if S1 matches S2 using wildcard pattern matching
bool wildcardMatching(string &amp;S1, string &amp;S2) {
    int n = S1.size();
    int m = S2.size();

    // Create a DP table to memoize results
    vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(m, -1));
    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);
}

int main() {
    string S1 = "ab*cd";
    string S2 = "abdefcd";

    // Call the wildcardMatching function and print the result
    if (wildcardMatching(S1, S2))
        cout &lt;&lt; "String S1 and S2 do match";
    else
        cout &lt;&lt; "String S1 and S2 do not match";

    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
  // Helper function to check if all characters from index 0 to i in S1 are '*'
  static boolean isAllStars(String S1, int i) {
    for (int j = 0; j &lt;= i; j++) {
      if (S1.charAt(j) != '*')
        return false;
    }
    return true;
  }

  // Recursive function to perform wildcard pattern matching
  static int wildcardMatchingUtil(String S1, String S2, int i, int j, int[][] dp) {
    // Base Cases
    if (i &lt; 0 &amp;&amp; j &lt; 0)
      return 1; // Both strings are empty, and the pattern matches.
    if (i &lt; 0 &amp;&amp; j &gt;= 0)
      return 0; // S1 is empty, but there are characters left in S2.
    if (j &lt; 0 &amp;&amp; i &gt;= 0)
      return isAllStars(S1, i) ? 1 : 0; // S2 is empty, check if remaining characters in S1 are all '*'.

    // If the result is already computed, return it.
    if (dp[i][j] != -1) return dp[i][j];

    // If the characters match or S1 has a '?', continue matching the rest of the strings.
    if (S1.charAt(i) == S2.charAt(j) || S1.charAt(i) == '?')
      return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);

    else {
      if (S1.charAt(i) == '*') {
        // Two possibilities when encountering '*':
        // 1. '*' matches one or more characters in S2.
        // 2. '*' matches zero characters in S2.
        return dp[i][j] = (wildcardMatchingUtil(S1, S2, i - 1, j, dp) == 1 || wildcardMatchingUtil(S1, S2, i, j - 1, dp) == 1) ? 1 : 0;
      } else {
        // Characters don't match, and S1[i] is not '*'.
        return 0;
      }
    }
  }

  // Main function to check if S1 matches the wildcard pattern S2
  static int wildcardMatching(String S1, String S2) {
    int n = S1.length();
    int m = S2.length();

    int dp[][] = new int[n][m];
    for (int row[]: dp)
      Arrays.fill(row, -1);

    // Call the recursive helper function
    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);
  }

  public static void main(String args[]) {
    String S1 = "ab*cd";
    String S2 = "abdefcd";

    if (wildcardMatching(S1, S2) == 1)
      System.out.println("String S1 and S2 do match");
    else
      System.out.println("String S1 and S2 do not match");
  }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(i + 1):
        if S1[j] != '*':
            return False
    return True

def wildcardMatchingUtil(S1, S2, i, j, dp):
    # Base conditions
    if i &lt; 0 and j &lt; 0:
        return True
    if i &lt; 0 and j &gt;= 0:
        return False
    if j &lt; 0 and i &gt;= 0:
        return isAllStars(S1, i)

    # If the result for this subproblem is already computed, return it
    if dp[i][j] != -1:
        return dp[i][j]

    if S1[i] == S2[j] or S1[i] == '?':
        # Characters match or S1 has a '?'; move to the previous characters in both strings
        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp)
    elif S1[i] == '*':
        # If S1 has a '*', there are two choices:
        # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
        # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
        dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) or wildcardMatchingUtil(S1, S2, i, j - 1, dp)
    else:
        dp[i][j] = False  # Characters don't match, and S1[i] is not '*'

    return dp[i][j]

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array with -1 values
    dp = [[-1 for _ in range(m)] for _ in range(n)]

    # Calculate and return the result of wildcard matching
    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp)

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
function isAllStars(S1, i) {
    for (let j = 0; j &lt;= i; j++) {
        if (S1[j] !== '*') {
            return false;
        }
    }
    return true;
}

// Function to perform wildcard pattern matching
function wildcardMatchingUtil(S1, S2, i, j, dp) {
    // Base Conditions
    if (i &lt; 0 &amp;&amp; j &lt; 0) {
        return true;
    }
    if (i &lt; 0 &amp;&amp; j &gt;= 0) {
        return false;
    }
    if (j &lt; 0 &amp;&amp; i &gt;= 0) {
        return isAllStars(S1, i);
    }

    // Check if the result for the current indices is already calculated
    if (dp[i][j] !== -1) {
        return dp[i][j];
    }

    if (S1[i] === S2[j] || S1[i] === '?') {
        return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);
    } else {
        if (S1[i] === '*') {
            return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) || wildcardMatchingUtil(S1, S2, i, j - 1, dp);
        } else {
            return false;
        }
    }
}

// Function to perform wildcard pattern matching
function wildcardMatching(S1, S2) {
    const n = S1.length;
    const m = S2.length;

    // Create a 2D array to store dynamic programming values
    const dp = new Array(n).fill(null).map(() =&gt; new Array(m).fill(-1));

    return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);
}

// Main function
function main() {
    const S1 = "ab*cd";
    const S2 = "abdefcd";

    // Check if S1 matches S2 using wildcard matching
    if (wildcardMatching(S1, S2)) {
        console.log("String S1 and S2 do match");
    } else {
        console.log("String S1 and S2 do not match");
    }
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Brute Force Here -->
<p><strong>Output:</strong> String S1 and S2 do match


</p>
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Brute Force Here -->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are N*M states therefore at max ‘N*M’ new problems will be solved.</p>
<p><strong>Space Complexity: O(N*M) + O(N+M)</strong></p>
<p>Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).</p>
</p>
</details>
</div>
</details>
</div>
<!-- Brute Force Approach Ends here -->
<!-- Better Approach Starts from here -->
<div id="better-approach">
<details>
<summary class="main-summary">
<span>
Tabulation Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition For Better Approach Here -->
<p>In the recursive logic, we set the base case too if(i&lt;0 ) and if(j&lt;0) but we can’t set the dp array’s index to -1. Therefore a hack for this issue is to shift every index by 1 towards the right.</p>
<p><img height="109" src="assets/b1c14695d48ec15548b780a4e06df703" width="454"/></p>
<ul><li>First we initialise the dp array of size [n+1][m+1] as zero.</li><li>Next, we set the base condition (keep in mind 1-based indexing), we set the top-left cell as ‘true’, then we set the first column’s value as ‘false’; and for the first row, we will run isAllStars() for every cell value.</li><li>Similarly, we will implement the recursive code by keeping in mind the shifting of indexes, therefore S1[i] will be converted to S1[i-1]. Same for S2.</li><li>At last we will print dp[n][m] as our answer.</li></ul>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Function to check if a substring of S1 contains only '*'
bool isAllStars(string &amp;S1, int i) {
    // S1 is taken in 1-based indexing
    for (int j = 1; j &lt;= i; j++) {
        if (S1[j - 1] != '*')
            return false;
    }
    return true;
}

// Function to perform wildcard pattern matching between S1 and S2
bool wildcardMatching(string &amp;S1, string &amp;S2) {
    int n = S1.size();
    int m = S2.size();

    // Create a DP table to memoize results
    vector&lt;vector&lt;bool&gt;&gt; dp(n + 1, vector&lt;bool&gt;(m, false));

    // Initialize the first row and column
    dp[0][0] = true;
    for (int j = 1; j &lt;= m; j++) {
        dp[0][j] = false;
    }
    for (int i = 1; i &lt;= n; i++) {
        dp[i][0] = isAllStars(S1, i);
    }

    // Fill in the DP table
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                if (S1[i - 1] == '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }
    }

    // The value at dp[n][m] contains whether S1 matches S2
    return dp[n][m];
}

int main() {
    string S1 = "ab*cd";
    string S2 = "abdefcd";

    // Call the wildcardMatching function and print the result
    if (wildcardMatching(S1, S2))
        cout &lt;&lt; "String S1 and S2 do match";
    else
        cout &lt;&lt; "String S1 and S2 do not match";

    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
  // Helper function to check if all characters from index 1 to i in S1 are '*'
  static boolean isAllStars(String S1, int i) {
    for (int j = 1; j &lt;= i; j++) {
      if (S1.charAt(j - 1) != '*')
        return false;
    }
    return true;
  }

  // Function to perform wildcard pattern matching
  static boolean wildcardMatching(String S1, String S2) {
    int n = S1.length();
    int m = S2.length();

    // Create a 2D array to store the matching results
    boolean dp[][] = new boolean[n + 1][m + 1];
    dp[0][0] = true;

    // Initialize the first row and column based on wildcard '*' in S1
    for (int j = 1; j &lt;= m; j++) {
      dp[0][j] = false;
    }
    for (int i = 1; i &lt;= n; i++) {
      dp[i][0] = isAllStars(S1, i);
    }

    // Fill the dp array using a bottom-up approach
    for (int i = 1; i &lt;= n; i++) {
      for (int j = 1; j &lt;= m; j++) {
        if (S1.charAt(i - 1) == S2.charAt(j - 1) || S1.charAt(i - 1) == '?') {
          dp[i][j] = dp[i - 1][j - 1]; // Characters match or '?' is encountered.
        } else {
          if (S1.charAt(i - 1) == '*') {
            dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; // '*' matches one or more characters.
          } else {
            dp[i][j] = false; // Characters don't match, and S1[i-1] is not '*'.
          }
        }
      }
    }

    return dp[n][m]; // The final result indicates whether S1 matches S2.
  }

  public static void main(String args[]) {
    String S1 = "ab*cd";
    String S2 = "abdefcd";

    if (wildcardMatching(S1, S2)) {
      System.out.println("String S1 and S2 do match");
    } else {
      System.out.println("String S1 and S2 do not match");
    }
  }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(1, i + 1):
        if S1[j - 1] != '*':
            return False
    return True

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize a 2D DP array dp with dimensions (n+1) x m and fill it with False values
    dp = [[False for _ in range(m)] for _ in range(n + 1)]

    # Initialize dp[0][0] to True since two empty strings match
    dp[0][0] = True

    # Initialize the first row of dp
    for j in range(1, m):
        dp[0][j] = False

    # Initialize the first column of dp based on whether S1 consists of all '*' characters up to that position
    for i in range(1, n + 1):
        dp[i][0] = isAllStars(S1, i)

    # Fill in the DP array using dynamic programming
    for i in range(1, n + 1):
        for j in range(1, m):
            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':
                # Characters match or S1 has a '?'; continue matching with the previous characters
                dp[i][j] = dp[i - 1][j - 1]
            elif S1[i - 1] == '*':
                # If S1 has a '*', there are two choices:
                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
                dp[i][j] = dp[i - 1][j] or dp[i][j - 1]
            else:
                dp[i][j] = False  # Characters don't match, and S1[i-1] is not '*'

    # The final value in dp[n][m-1] is True if the two strings match, False otherwise
    return dp[n][m-1]

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
function isAllStars(S1, i) {
    // S1 is taken in 1-based indexing
    for (let j = 1; j &lt;= i; j++) {
        if (S1[j - 1] !== '*') {
            return false;
        }
    }
    return true;
}

// Function to perform wildcard pattern matching
function wildcardMatching(S1, S2) {
    const n = S1.length;
    const m = S2.length;

    // Create a 2D array to store dynamic programming values
    const dp = new Array(n + 1).fill(null).map(() =&gt; new Array(m + 1).fill(false));

    dp[0][0] = true;

    for (let j = 1; j &lt;= m; j++) {
        dp[0][j] = false;
    }

    for (let i = 1; i &lt;= n; i++) {
        dp[i][0] = isAllStars(S1, i);
    }

    for (let i = 1; i &lt;= n; i++) {
        for (let j = 1; j &lt;= m; j++) {
            if (S1[i - 1] === S2[j - 1] || S1[i - 1] === '?') {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                if (S1[i - 1] === '*') {
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                } else {
                    dp[i][j] = false;
                }
            }
        }
    }

    return dp[n][m];
}

// Main function
function main() {
    const S1 = "ab*cd";
    const S2 = "abdefcd";

    // Check if S1 matches S2 using wildcard matching
    if (wildcardMatching(S1, S2)) {
        console.log("String S1 and S2 do match");
    } else {
        console.log("String S1 and S2 do not match");
    }
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Better Approach Here -->
<strong>Output:</strong> String S1 and S2 do match
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Better Approach Here -->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are two nested loops</p>
<p><strong>Space Complexity: O(N*M)</strong></p>
<p>Reason: We are using an external array of size ‘N*M’. Stack Space is eliminated.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Better Approach Ends from here -->
<!-- Optimal Approach Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
Space Optimization Approach 
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm of Better Approach Here -->
<p>If we closely look the relation,</p>
<p><strong>dp[i][j] =  dp[i-1][j-1], dp[i][j] = dp[i-1][j] ||dp[i][j-1] </strong></p>
<p>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev) and current row’s previous columns values. So, we don’t need to store an entire array. Hence we can space optimise it.</p>
<p><strong>Approach:</strong></p>
<p>We will space optimize in the following way:</p>
<ul><li>We take two rows ‘prev’ and ‘cur’.</li><li>We initialize it to the base condition. We first initialize the prev row. Its first value needs to be true. Rest all the values of the prev row meeds to be false.</li><li>Moreover, the cur variable whenever declared should have its first cell’s value given by isAllStarts() function.</li><li>Next, we implement the memoization logic. We replace dp[i-1] with prev and dp[i] by cur.</li><li>After every inner loop execution, we set prev=cur, for the next iteration.</li><li>At last, we return prev[m] as our answer.</li></ul>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Function to check if a substring of S1 contains only '*'
bool isAllStars(string &amp;S1, int i) {
    // S1 is taken in 1-based indexing
    for (int j = 1; j &lt;= i; j++) {
        if (S1[j - 1] != '*')
            return false;
    }
    return true;
}

// Function to perform wildcard pattern matching between S1 and S2
bool wildcardMatching(string &amp;S1, string &amp;S2) {
    int n = S1.size();
    int m = S2.size();

    // Create two arrays to store previous and current rows of matching results
    vector&lt;bool&gt; prev(m + 1, false);
    vector&lt;bool&gt; cur(m + 1, false);

    prev[0] = true; // Initialize the first element of the previous row to true

    for (int i = 1; i &lt;= n; i++) {
        cur[0] = isAllStars(S1, i); // Initialize the first element of the current row
        for (int j = 1; j &lt;= m; j++) {
            if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {
                cur[j] = prev[j - 1]; // Characters match or S1 has '?'
            } else {
                if (S1[i - 1] == '*') {
                    cur[j] = prev[j] || cur[j - 1]; // '*' represents empty or a character
                } else {
                    cur[j] = false; // Characters don't match and S1[i-1] is not '*'
                }
            }
        }
        prev = cur; // Update the previous row with the current row
    }

    // The value at prev[m] contains whether S1 matches S2
    return prev[m];
}

int main() {
    string S1 = "ab*cd";
    string S2 = "abdefcd";

    // Call the wildcardMatching function and print the result
    if (wildcardMatching(S1, S2))
        cout &lt;&lt; "String S1 and S2 do match";
    else
        cout &lt;&lt; "String S1 and S2 do not match";

    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
  // Helper function to check if all characters from index 1 to i in S1 are '*'
  static boolean isAllStars(String S1, int i) {
    for (int j = 1; j &lt;= i; j++) {
      if (S1.charAt(j - 1) != '*')
        return false;
    }
    return true;
  }

  // Function to perform wildcard pattern matching
  static boolean wildcardMatching(String S1, String S2) {
    int n = S1.length();
    int m = S2.length();

    // Create two boolean arrays to store the matching results for the current and previous rows
    boolean[] prev = new boolean[m + 1];
    boolean[] cur = new boolean[m + 1];

    // Initialize the first element of prev as true
    prev[0] = true;

    // Iterate through S1 and S2 to fill the cur array
    for (int i = 1; i &lt;= n; i++) {
      // Initialize the first element of cur based on whether S1 contains '*'
      cur[0] = isAllStars(S1, i);
      for (int j = 1; j &lt;= m; j++) {
        if (S1.charAt(i - 1) == S2.charAt(j - 1) || S1.charAt(i - 1) == '?') {
          cur[j] = prev[j - 1]; // Characters match or '?' is encountered.
        } else {
          if (S1.charAt(i - 1) == '*') {
            cur[j] = prev[j] || cur[j - 1]; // '*' matches one or more characters.
          } else {
            cur[j] = false; // Characters don't match, and S1[i-1] is not '*'.
          }
        }
      }
      // Update prev array to store the current values
      prev = cur.clone();
    }

    return prev[m]; // The final result indicates whether S1 matches S2.
  }

  public static void main(String args[]) {
    String S1 = "ab*cd";
    String S2 = "abdefcd";

    if (wildcardMatching(S1, S2)) {
      System.out.println("String S1 and S2 do match");
    } else {
      System.out.println("String S1 and S2 do not match");
    }
  }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
def isAllStars(S1, i):
    # Helper function to check if all characters up to index i in S1 are '*'
    for j in range(1, i + 1):
        if S1[j - 1] != '*':
            return False
    return True

def wildcardMatching(S1, S2):
    n = len(S1)
    m = len(S2)

    # Initialize two lists, prev and cur, to store the previous and current rows of the DP array
    prev = [False for _ in range(m + 1)]
    cur = [False for _ in range(m + 1)]

    prev[0] = True  # Initialize the first element of prev to True

    for i in range(1, n + 1):
        cur[0] = isAllStars(S1, i)  # Initialize the first element of cur based on '*' characters in S1
        for j in range(1, m + 1):

            if S1[i - 1] == S2[j - 1] or S1[i - 1] == '?':
                # Characters match or S1 has a '?'; continue matching with the previous characters
                cur[j] = prev[j - 1]
            elif S1[i - 1] == '*':
                # If S1 has a '*', there are two choices:
                # 1. '*' represents an empty string in S1, so move to the previous character in S1 (i-1, j).
                # 2. '*' represents one or more characters in S1, so move to the previous character in S2 (i, j-1).
                cur[j] = prev[j] or cur[j - 1]
            else:
                cur[j] = False  # Characters don't match, and S1[i-1] is not '*'

        prev = cur  # Update prev to be the current row

    # The final value in prev[m] is True if the two strings match, False otherwise
    return prev[m]

def main():
    S1 = "ab*cd"
    S2 = "abdefcd"

    if wildcardMatching(S1, S2):
        print("String S1 and S2 do match")
    else:
        print("String S1 and S2 do not match")

if __name__ == "__main__":
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
function isAllStars(S1, i) {
    // S1 is taken in 1-based indexing
    for (let j = 1; j &lt;= i; j++) {
        if (S1[j - 1] !== '*') {
            return false;
        }
    }
    return true;
}

// Function to perform wildcard pattern matching
function wildcardMatching(S1, S2) {
    const n = S1.length;
    const m = S2.length;

    // Create two arrays, prev and cur, to store dynamic programming values
    const prev = new Array(m + 1).fill(false);
    const cur = new Array(m + 1).fill(false);

    prev[0] = true;

    for (let i = 1; i &lt;= n; i++) {
        cur[0] = isAllStars(S1, i);
        for (let j = 1; j &lt;= m; j++) {
            if (S1[i - 1] === S2[j - 1] || S1[i - 1] === '?') {
                cur[j] = prev[j - 1];
            } else {
                if (S1[i - 1] === '*') {
                    cur[j] = prev[j] || cur[j - 1];
                } else {
                    cur[j] = false;
                }
            }
        }
        // Update the prev array with the values from the cur array for the next iteration
        for (let j = 0; j &lt;= m; j++) {
            prev[j] = cur[j];
        }
    }

    return prev[m];
}

// Main function
function main() {
    const S1 = "ab*cd";
    const S2 = "abdefcd";

    // Check if S1 matches S2 using wildcard matching
    if (wildcardMatching(S1, S2)) {
        console.log("String S1 and S2 do match");
    } else {
        console.log("String S1 and S2 do not match");
    }
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Optimal Apporach Here -->
<strong>Output:</strong>String S1 and S2 do match

</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Optimal Approach-->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are two nested loops.</p>
<p><strong>Space Complexity: O(M)</strong></p>
<p>Reason: We are using an external array of size ‘M+1’ to store two rows.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Optimal Approach Starts from here -->
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
Video Explanation
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" class="lazy-loaded" data-lazy-type="iframe" data-src="https://www.youtube.com/embed/ZmlQ3vgAOMo?si=9uvg_LQLhoHBypEV" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/xvNwoz-ufXA?feature=oembed" title="Wildcard Matching" width="810"></iframe><noscript>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/ZmlQ3vgAOMo?si=9uvg_LQLhoHBypEV" title="Wildcard Matching" width="810"></iframe></noscript>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<script>

const codeSections = document.querySelectorAll('.code-section');

// Get last selected language from localStorage or set default value
let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

// Update last selected language for all sections and store in localStorage
lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

// Handle copy button click event
copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

// Set initial state of the tabs
codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<script>
const codeSections = document.querySelectorAll('.code-section');

let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
<!-- /wp:html -->
<!-- wp:html -->
<script src="https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js"></script>
<!-- /wp:html -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/anshuman-sharma-a1b245194/" rel="noreferrer noopener" target="_blank">Anshuman Sharma</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/" rel="noreferrer noopener" target="_blank">please check out this article</a></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (active.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>