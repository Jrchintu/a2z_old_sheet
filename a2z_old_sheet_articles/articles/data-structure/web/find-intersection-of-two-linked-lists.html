<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Find intersection of Two Linked Lists</title>
<link href="assets/34bd07407ad1de576cba1f67651fa31a" rel="stylesheet"/>
<style>
        /* ==========================================================================
           1. CSS Variables (Theme) - Utilitarian Modern
           ========================================================================== */
        :root {
            /* Default to Light Theme */
            --primary-color: #3b82f6; /* Blue 500 */
            --primary-hover: #2563eb; /* Blue 600 */
            
            --bg-body: #f8fafc; /* Slate 50 */
            --bg-surface: #ffffff; /* White */
            --bg-subtle: #f1f5f9; /* Slate 100 */
            
            --border-color: #e2e8f0; /* Slate 200 */
            
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #334155; /* Slate 700 */
            --text-muted: #64748b; /* Slate 500 */
            
            --link-color: #2563eb; /* Blue 600 */
            --link-hover: #3b82f6; /* Blue 500 */

            --code-bg: #f1f5f9; /* Slate 100 */
            --code-text: #0f172a; /* Slate 900 */

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 0 25px -5px rgba(59, 130, 246, 0.25);
            
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
        }

        /* Dark Theme Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f172a; /* Slate 900 */
                --bg-surface: #1e293b; /* Slate 800 */
                --bg-subtle: #334155; /* Slate 700 */
                
                --border-color: #334155;
                
                --text-primary: #f8fafc; /* Slate 50 */
                --text-secondary: #cbd5e1; /* Slate 300 */
                --text-muted: #94a3b8; /* Slate 400 */
                
                --link-color: #60a5fa; /* Blue 400 */
                --link-hover: #93c5fd; /* Blue 300 */

                --code-bg: #020617; /* Slate 950 */
                --code-text: #f8fafc;
            }
        }

        /* ==========================================================================
           2. Base & Reset
           ========================================================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-body);
            margin: 0;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ==========================================================================
           3. Layout
           ========================================================================== */
        .container {
            max-width: 800px; /* Optimal reading width */
            margin: 0 auto;
            padding: 2rem;
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        /* Enhanced hover for desktop only */
        @media (hover: hover) and (pointer: fine) {
            .container:hover {
                transform: translateY(-4px);
                border-color: var(--primary-color);
                box-shadow: var(--shadow-hover);
            }
        }

        /* ==========================================================================
           4. Typography
           ========================================================================== */
        h1 {
            color: var(--text-primary);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.025em;
        }
        
        h2, h3, h4 {
            color: var(--text-secondary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.25em;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* ==========================================================================
           5. Media
           ========================================================================== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            margin: 1.5rem auto;
        }

        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            margin: 1.5rem 0;
            border-radius: var(--radius-md);
            background-color: var(--bg-subtle);
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ==========================================================================
           6. Code Blocks
           ========================================================================== */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            overflow-x: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        code {
            font-family: inherit;
        }

        /* ==========================================================================
           7. Code Tabs
           ========================================================================== */
        .code-section {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .code-tabs {
            display: flex;
            background-color: var(--bg-subtle);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .code-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .code-tab:hover {
            color: var(--text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .copy-btn {
            margin-left: auto;
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .copy-btn svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
        }
        
        .copy-btn:hover svg {
            fill: var(--text-primary);
        }

        .code-content {
            background-color: var(--code-bg);
        }
        
        .code-content pre {
            margin: 0;
            border-radius: 0;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ==========================================================================
           8. Accordions / Details
           ========================================================================== */
        details {
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: var(--bg-surface);
            transition: box-shadow 0.2s;
        }
        
        details:hover {
            box-shadow: var(--shadow-sm);
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: 1rem;
            background-color: var(--bg-subtle);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: #475569; /* Slate 600 */
        }
        
        /* Arrow icon rotation */
        summary .arrow-svg {
            transition: transform 0.3s ease;
            width: 20px;
            height: 20px;
            fill: var(--text-muted);
            flex-shrink: 0;
            transform-origin: center;
        }
        
        /* Only rotate the arrow of the *active* details element */
        details[open] > summary .arrow-svg {
            transform: rotate(90deg);
            fill: var(--primary-color);
        }

        .common-drops,
        .atricle_example_content,
        details > :not(summary) {
            padding: 0.5rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-surface);
        }

        /* Nested details */
        .secondary-details {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        .secondary-summary {
            background-color: rgba(51, 65, 85, 0.3); /* Semi-transparent slate-700 */
            font-size: 0.95rem;
        }
        
        .secondary-summary:hover {
            background-color: var(--bg-subtle);
        }
        
        .opacity-75 {
            opacity: 0.75;
        }

        /* ==========================================================================
           9. Practice & Disclaimer
           ========================================================================== */
        .practice, .new-disclaimer {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: var(--bg-subtle);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .problem-buttons a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        
        .problem-buttons a:hover {
            background-color: var(--primary-hover);
            text-decoration: none;
        }

        /* ==========================================================================
           10. Utilities
           ========================================================================== */
        .problem-buttons img,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article,
        .has-text-align-center {
            display: none;
        }
        
        .arrow-svg {
            display: inline-block; /* Ensure arrows are visible */
        }

        /* ==========================================================================
           11. Responsive (Full Page Mobile)
           ========================================================================== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border: none;
                border-radius: 0;
                box-shadow: none;
                padding: 0.5rem;
                max-width: 100%;
            }

            h1 {
                font-size: 1.5rem;
                text-align: left;
            }

            .code-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 2px; /* Space for scrollbar */
            }
            
            .code-tab {
                flex-shrink: 0;
            }

            .code-content pre {
                padding: 0.2rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Find intersection of Two Linked Lists</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement: </strong>Given the heads of two singly <a href="https://takeuforward.org/linked-list/linked-list-introduction/" rel="noreferrer noopener" target="_blank">linked-lists</a> <strong>headA</strong> and <strong>headB</strong>, return <strong>the node at which the two lists intersect</strong>. If the two linked lists have no intersection at all, return <strong>null</strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong>
List 1 = [1,3,1,2,4], List 2 = [3,2,4]
<strong>Output:</strong>
2
<strong>Explanation:</strong> Here, both lists intersecting nodes start from node 2.
<img height="260.4377308268175" src="assets/4bd485065daaec2dcad9cdba9908ad16" width="463.60975609756093"/></pre>
<!-- /wp:preformatted -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 2:</strong>
<strong>Input:</strong>
 List1 = [1,2,7], List 2 = [2,8,1]
<strong>Output:</strong>
 Null
<strong>Explanation:</strong> Here, both lists do not intersect and thus no intersection node is present.
<strong><img height="285.23970605636237" src="assets/b2415e6450f78d1e7867db4fcf630a06" width="509.22279792746116"/></strong></pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><strong>Solution 1: Brute-Force</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong> We know intersection means a common attribute present between two entities. Here, we have linked lists as given entities. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>What should be the common attribute for two linked lists? </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>If you believe a common attribute is a node's value, then think properly! If we take our example 1, there we can see both lists have nodes of value 3. But it is not the first intersection node. So what’s the common attribute?</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>It is the node itself that is the common attribute. So, the process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Keep any one of the list to check its node present in the other list. Here, we are choosing the second list for this task.</li><li>Iterate through the other list. Here, it is the first one. </li><li>Check if the both nodes are the same. If yes, we got our first intersection node.</li><li>If not, continue iteration.</li><li>If we did not find an intersection node and completed the entire iteration of the second list, then there is no intersection between the provided lists. Hence, return <em>null</em>.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="244" src="assets/c187c0ac061b905f0926f60c3c24a7f5" width="435"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;iostream&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
    while(head2 != NULL) {
        node* temp = head1;
        while(temp != NULL) {
            //if both nodes are same
            if(temp == head2) return head2;
            temp = temp-&gt;next;
        }
        head2 = head2-&gt;next;
    }
    //intersection is not present between the lists return null
    return NULL;
}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire lists 1 are iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}

//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
    while(head2 != null) {
        Node temp = head1;
        while(temp != null) {
            //if both nodes are same
            if(temp == head2) return head2;
            temp = temp.next;
        }
        head2 = head2.next;
    }
    //intersection is not present between the lists return null
    return null;
}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire lists 1 are iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    while head2 != None:
        temp = head1
        while temp != None:
            # if both nodes are same
            if temp == head2:
                return head2
            temp = temp.next
        head2 = head2.next
    # intersection is not present between the lists
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire list 1 is iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 2: Hashing</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Can we improve brute-force time complexity? In brute force, we are basically performing “searching”. We can also perform searches by Hashing. Taking into consideration that hashing process takes O(1) time complexity. So the process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Iterate through list 1 and hash its node address. Why? (Hint: depends on the common attribute we are searching)</li><li>Iterate through list 2 and search the hashed value in the hash table. If found, return node.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
     unordered_set&lt;node*&gt; st;
    while(head1 != NULL) {
       st.insert(head1);
       head1 = head1-&gt;next;
    }
    while(head2 != NULL) {
        if(st.find(head2) != st.end()) return head2;
        head2 = head2-&gt;next;
    }
    return NULL;

}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node addresses in unordered_set.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}

//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
     HashSet&lt;Node&gt; st=new HashSet&lt;&gt;();
    while(head1 != null) {
       st.add(head1);
       head1 = head1.next;
    }
    while(head2 != null) {
        if(st.contains(head2)) return head2;
        head2 = head2.next;
    }
    return null;

}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node address in HashSet.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    st = set()
    while head1 != None:
        st.add(head1)
        head1 = head1.next
    while head2 != None:
        if head2 in st:
            return head2
        head2 = head2.next
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node addresses in unordered_set.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 3: Difference in length</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We will reduce the search length. This can be done by searching the length of the shorter linked list. How? Let’s see the process.</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Find the length of both lists.</li><li>Find the positive difference between these lengths.</li><li>Move the dummy pointer of the larger list by the difference achieved. This makes our search length reduced to a smaller list length.</li><li>Move both pointers, each pointing two lists, ahead simultaneously if both do not collide.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="233" src="assets/bc2483091a1b051bee8853f2528818fd" width="414"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}
int getDifference(node* head1,node* head2) {
     int len1 = 0,len2 = 0;
        while(head1 != NULL || head2 != NULL) {
            if(head1 != NULL) {
                ++len1; head1 = head1-&gt;next;
            }
            if(head2 != NULL) {
                ++len2; head2 = head2-&gt;next;
            }
            
        }
        return len1-len2;//if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
 int diff = getDifference(head1,head2);
        if(diff &lt; 0) 
            while(diff++ != 0) head2 = head2-&gt;next; 
        else while(diff-- != 0) head1 = head1-&gt;next;
        while(head1 != NULL) {
            if(head1 == head2) return head1;
            head2 = head2-&gt;next;
            head1 = head1-&gt;next;
        }
        return head1;


}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}
 static int getDifference(Node head1,Node head2) {
     int len1 = 0,len2 = 0;
        while(head1 != null || head2 != null) {
            if(head1 != null) {
                ++len1; head1 = head1.next;
            }
            if(head2 != null) {
                ++len2; head2 = head2.next;
            }
            
        }
        return len1-len2;//if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
}
//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
   int diff = getDifference(head1,head2);
        if(diff &lt; 0) 
            while(diff++ != 0) head2 = head2.next; 
        else while(diff-- != 0) head1 = head1.next;
        while(head1 != null) {
            if(head1 == head2) return head1;
            head2 = head2.next;
            head1 = head1.next;
        }
        return head1;

}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




def getDifference(head1, head2):
    len1 = 0
    len2 = 0
    while head1 != None or head2 != None:
        if head1 != None:
            len1 += 1
            head1 = head1.next
        if head2 != None:
            len2 += 1
            head2 = head2.next
    # if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
    return len1 - len2




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    diff = getDifference(head1, head2)
    if diff &lt; 0:
        while diff != 0:
            head2 = head2.next
            diff += 1
    else:
        while diff != 0:
            head1 = head1.next
            diff -= 1
    while head1 != None:
        if head1 == head2:
            return head1
        head2 = head2.next
        head1 = head1.next
    return head1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 4: Optimised </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The difference of length method requires various steps to work on it. Using the same concept of difference of length, a different approach can be implemented. The process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Take two dummy nodes for each list. Point each to the head of the lists.</li><li>Iterate over them. If anyone becomes null, point them to the head of the opposite lists and continue iterating until they collide.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry</strong> <strong>Run</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="246" src="assets/d384da637e1975c7dad33b63657507e2" width="438"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}
//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
    node* d1 = head1;
    node* d2 = head2;
    
    while(d1 != d2) {
        d1 = d1 == NULL? head2:d1-&gt;next;
        d2 = d2 == NULL? head1:d2-&gt;next;
    }
    
    return d1;
}


//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of the difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}
//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
    Node d1 = head1;
    Node d2 = head2;
    
    while(d1 != d2) {
        d1 = d1 == null? head2:d1.next;
        d2 = d2 == null? head1:d2.next;
    }
    
    return d1;
}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of the difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    d1 = head1
    d2 = head2
    while d1 != d2:
        d1 = head2 if d1 == None else d1.next
        d2 = head1 if d2 == None else d2.next
    return d1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><em>Special thanks to <strong><a href="https://www.linkedin.com/in/dewanshi-paul-2515091b9" rel="noreferrer noopener" target="_blank">Dewanshi Paul</a></strong> <em>and <em><a href="https://www.linkedin.com/in/imsudip/" rel="noreferrer noopener" target="_blank"><strong>Sudip Ghosh</strong></a></em></em> </em></em><em><em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/contribute/help-us-grow-takeuforward/">please check out this articl</a></em>e</p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>