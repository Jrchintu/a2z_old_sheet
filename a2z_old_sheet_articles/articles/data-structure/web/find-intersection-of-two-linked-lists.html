<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Find intersection of Two Linked Lists</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            /* line-height: 1.7; */
            color: #333;
            background-color: #fdfdfd;
            margin: 5px;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e7e7e7;
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 5px;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Find intersection of Two Linked Lists</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement: </strong>Given the heads of two singly <a href="https://takeuforward.org/linked-list/linked-list-introduction/" rel="noreferrer noopener" target="_blank">linked-lists</a> <strong>headA</strong> and <strong>headB</strong>, return <strong>the node at which the two lists intersect</strong>. If the two linked lists have no intersection at all, return <strong>null</strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong>
List 1 = [1,3,1,2,4], List 2 = [3,2,4]
<strong>Output:</strong>
2
<strong>Explanation:</strong> Here, both lists intersecting nodes start from node 2.
<img height="260.4377308268175" src="assets/4bd485065daaec2dcad9cdba9908ad16" width="463.60975609756093"/></pre>
<!-- /wp:preformatted -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 2:</strong>
<strong>Input:</strong>
 List1 = [1,2,7], List 2 = [2,8,1]
<strong>Output:</strong>
 Null
<strong>Explanation:</strong> Here, both lists do not intersect and thus no intersection node is present.
<strong><img height="285.23970605636237" src="assets/b2415e6450f78d1e7867db4fcf630a06" width="509.22279792746116"/></strong></pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><strong>Solution 1: Brute-Force</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong> We know intersection means a common attribute present between two entities. Here, we have linked lists as given entities. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>What should be the common attribute for two linked lists? </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>If you believe a common attribute is a node's value, then think properly! If we take our example 1, there we can see both lists have nodes of value 3. But it is not the first intersection node. So what’s the common attribute?</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>It is the node itself that is the common attribute. So, the process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Keep any one of the list to check its node present in the other list. Here, we are choosing the second list for this task.</li><li>Iterate through the other list. Here, it is the first one. </li><li>Check if the both nodes are the same. If yes, we got our first intersection node.</li><li>If not, continue iteration.</li><li>If we did not find an intersection node and completed the entire iteration of the second list, then there is no intersection between the provided lists. Hence, return <em>null</em>.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="244" src="assets/c187c0ac061b905f0926f60c3c24a7f5" width="435"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;iostream&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
    while(head2 != NULL) {
        node* temp = head1;
        while(temp != NULL) {
            //if both nodes are same
            if(temp == head2) return head2;
            temp = temp-&gt;next;
        }
        head2 = head2-&gt;next;
    }
    //intersection is not present between the lists return null
    return NULL;
}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire lists 1 are iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}

//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
    while(head2 != null) {
        Node temp = head1;
        while(temp != null) {
            //if both nodes are same
            if(temp == head2) return head2;
            temp = temp.next;
        }
        head2 = head2.next;
    }
    //intersection is not present between the lists return null
    return null;
}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire lists 1 are iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    while head2 != None:
        temp = head1
        while temp != None:
            # if both nodes are same
            if temp == head2:
                return head2
            temp = temp.next
        head2 = head2.next
    # intersection is not present between the lists
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(m*n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: For each node in list 2 entire list 1 is iterated. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 2: Hashing</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Can we improve brute-force time complexity? In brute force, we are basically performing “searching”. We can also perform searches by Hashing. Taking into consideration that hashing process takes O(1) time complexity. So the process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Iterate through list 1 and hash its node address. Why? (Hint: depends on the common attribute we are searching)</li><li>Iterate through list 2 and search the hashed value in the hash table. If found, return node.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
     unordered_set&lt;node*&gt; st;
    while(head1 != NULL) {
       st.insert(head1);
       head1 = head1-&gt;next;
    }
    while(head2 != NULL) {
        if(st.find(head2) != st.end()) return head2;
        head2 = head2-&gt;next;
    }
    return NULL;

}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node addresses in unordered_set.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}

//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
     HashSet&lt;Node&gt; st=new HashSet&lt;&gt;();
    while(head1 != null) {
       st.add(head1);
       head1 = head1.next;
    }
    while(head2 != null) {
        if(st.contains(head2)) return head2;
        head2 = head2.next;
    }
    return null;

}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node address in HashSet.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    st = set()
    while head1 != None:
        st.add(head1)
        head1 = head1.next
    while head2 != None:
        if head2 in st:
            return head2
        head2 = head2.next
    return None




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(n+m)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Iterating through list 1 first takes O(n), then iterating through list 2 takes O(m). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(n)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Storing list 1 node addresses in unordered_set.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 3: Difference in length</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We will reduce the search length. This can be done by searching the length of the shorter linked list. How? Let’s see the process.</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Find the length of both lists.</li><li>Find the positive difference between these lengths.</li><li>Move the dummy pointer of the larger list by the difference achieved. This makes our search length reduced to a smaller list length.</li><li>Move both pointers, each pointing two lists, ahead simultaneously if both do not collide.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="233" src="assets/bc2483091a1b051bee8853f2528818fd" width="414"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}
int getDifference(node* head1,node* head2) {
     int len1 = 0,len2 = 0;
        while(head1 != NULL || head2 != NULL) {
            if(head1 != NULL) {
                ++len1; head1 = head1-&gt;next;
            }
            if(head2 != NULL) {
                ++len2; head2 = head2-&gt;next;
            }
            
        }
        return len1-len2;//if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
}

//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
 int diff = getDifference(head1,head2);
        if(diff &lt; 0) 
            while(diff++ != 0) head2 = head2-&gt;next; 
        else while(diff-- != 0) head1 = head1-&gt;next;
        while(head1 != NULL) {
            if(head1 == head2) return head1;
            head2 = head2-&gt;next;
            head1 = head1-&gt;next;
        }
        return head1;


}

//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}
 static int getDifference(Node head1,Node head2) {
     int len1 = 0,len2 = 0;
        while(head1 != null || head2 != null) {
            if(head1 != null) {
                ++len1; head1 = head1.next;
            }
            if(head2 != null) {
                ++len2; head2 = head2.next;
            }
            
        }
        return len1-len2;//if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
}
//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
   int diff = getDifference(head1,head2);
        if(diff &lt; 0) 
            while(diff++ != 0) head2 = head2.next; 
        else while(diff-- != 0) head1 = head1.next;
        while(head1 != null) {
            if(head1 == head2) return head1;
            head2 = head2.next;
            head1 = head1.next;
        }
        return head1;

}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




def getDifference(head1, head2):
    len1 = 0
    len2 = 0
    while head1 != None or head2 != None:
        if head1 != None:
            len1 += 1
            head1 = head1.next
        if head2 != None:
            len2 += 1
            head2 = head2.next
    # if difference is neg-&gt; length of list2 &gt; length of list1 else vice-versa
    return len1 - len2




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    diff = getDifference(head1, head2)
    if diff &lt; 0:
        while diff != 0:
            head2 = head2.next
            diff += 1
    else:
        while diff != 0:
            head1 = head1.next
            diff -= 1
    while head1 != None:
        if head1 == head2:
            return head1
        head2 = head2.next
        head1 = head1.next
    return head1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>O(2max(length of list1,length of list2))+O(abs(length of list1-length of list2))+O(min(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Finding the length of both lists takes max(length of list1, length of list2) because it is found simultaneously for both of them. Moving the head pointer ahead by a difference of them. The next one is for searching.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra space is used.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution 4: Optimised </strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The difference of length method requires various steps to work on it. Using the same concept of difference of length, a different approach can be implemented. The process is as follows:-</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Take two dummy nodes for each list. Point each to the head of the lists.</li><li>Iterate over them. If anyone becomes null, point them to the head of the opposite lists and continue iterating until they collide.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry</strong> <strong>Run</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><img height="246" src="assets/d384da637e1975c7dad33b63657507e2" width="438"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

class node {
    public:
        int num;
        node* next;
        node(int val) {
            num = val;
            next = NULL;
        }
};
//utility function to insert node at the end of the linked list
void insertNode(node* &amp;head,int val) {
    node* newNode = new node(val);
    
    if(head == NULL) {
        head = newNode;
        return;
    }
    
    node* temp = head;
    while(temp-&gt;next != NULL) temp = temp-&gt;next;
    
    temp-&gt;next = newNode;
    return;
}
//utility function to check presence of intersection
node* intersectionPresent(node* head1,node* head2) {
    node* d1 = head1;
    node* d2 = head2;
    
    while(d1 != d2) {
        d1 = d1 == NULL? head2:d1-&gt;next;
        d2 = d2 == NULL? head1:d2-&gt;next;
    }
    
    return d1;
}


//utility function to print linked list created
void printList(node* head) {
    while(head-&gt;next != NULL) {
        cout&lt;&lt;head-&gt;num&lt;&lt;"-&gt;";
        head = head-&gt;next;
    }
    cout&lt;&lt;head-&gt;num&lt;&lt;endl;
}

int main() {
    // creation of both lists 
    node* head = NULL;
    insertNode(head,1);
    insertNode(head,3);
    insertNode(head,1);
    insertNode(head,2);
    insertNode(head,4);
    node* head1 = head;
    head = head-&gt;next-&gt;next-&gt;next;
    node* headSec = NULL;
    insertNode(headSec,3);
    node* head2 = headSec;
    headSec-&gt;next = head;
    //printing of the lists
    cout&lt;&lt;"List1: "; printList(head1);
    cout&lt;&lt;"List2: "; printList(head2);
    //checking if intersection is present
    node* answerNode = intersectionPresent(head1,head2);
    if(answerNode == NULL )
    cout&lt;&lt;"No intersection\n";
    else
    cout&lt;&lt;"The intersection point is "&lt;&lt;answerNode-&gt;num&lt;&lt;endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of the difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
class Node {
        int num;
        Node next;
        Node(int val) {
            num = val;
            next = null;
        }
}
class TUF{
//utility function to insert node at the end of the linked list
static Node insertNode(Node head,int val) {
    Node newNode = new Node(val);
    
    if(head == null) {
        head = newNode;
        return head;
    }
    
    Node temp = head;
    while(temp.next != null) temp = temp.next;
    
    temp.next = newNode;
    return head;
}
//utility function to check presence of intersection
static Node intersectionPresent(Node head1,Node head2) {
    Node d1 = head1;
    Node d2 = head2;
    
    while(d1 != d2) {
        d1 = d1 == null? head2:d1.next;
        d2 = d2 == null? head1:d2.next;
    }
    
    return d1;
}

//utility function to print linked list created
static void printList(Node head) {
    while(head.next != null) {
    System.out.print(head.num+"-&gt;");
        head = head.next;
    }
    System.out.println(head.num);
}

public static void main(String args[]) {
    // creation of both lists 
    Node head = null;
    head=insertNode(head,1);
    head=insertNode(head,3);
    head=insertNode(head,1);
    head=insertNode(head,2);
    head=insertNode(head,4);
    Node head1 = head;
    head = head.next.next.next;
    Node headSec = null;
    headSec=insertNode(headSec,3);
    Node head2 = headSec;
    headSec.next = head;
    //printing of the lists
    System.out.print("List1: "); printList(head1);
    System.out.print("List2: "); printList(head2);
    //checking if intersection is present
    Node answerNode = intersectionPresent(head1,head2);
    if(answerNode == null)  
    System.out.println("No intersection\n");
    else
    System.out.println("The intersection point is "+answerNode.num);
    
}
}</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of the difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="python">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">class Node:
    def __init__(self, val):
        self.val = val
        self.next = None




# utility function to insert node at the end of the linked list
def insertNode(head, val):
    newNode = Node(val)
    if head == None:
        head = newNode
        return head
    temp = head
    while temp.next != None:
        temp = temp.next
    temp.next = newNode
    return head




# utility function to check presence of intersection
def intersectionPresent(head1, head2):
    d1 = head1
    d2 = head2
    while d1 != d2:
        d1 = head2 if d1 == None else d1.next
        d2 = head1 if d2 == None else d2.next
    return d1




# utility function to print linked list created
def printList(head):
    while head.next != None:
        print(head.val, end='-&gt;')
        head = head.next
    print(head.val)




if __name__ == '__main__':
    head = None
    head = insertNode(head, 1)
    head = insertNode(head, 3)
    head = insertNode(head, 1)
    head = insertNode(head, 2)
    head = insertNode(head, 4)
    head1 = head
    head = head.next.next.next
    headSec = None
    headSec = insertNode(headSec, 3)
    head2 = headSec
    headSec.next = head
    print('List1: ', end='')
    printList(head1)
    print('List2: ', end='')
    printList(head2)
    answerNode = intersectionPresent(head1, head2)
    if answerNode == None:
        print('No intersection')
    else:
        print('The intersection point is', answerNode.val)</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>List1: 1-&gt;3-&gt;1-&gt;2-&gt;4<br/>List2: 3-&gt;2-&gt;4<br/>The intersection point is 2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:</strong> O(2*max(length of list1,length of list2))</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: Uses the same concept of difference of lengths of two lists.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity:</strong> O(1)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Reason</em>: No extra data structure is used</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em><em>Special thanks to <strong><a href="https://www.linkedin.com/in/dewanshi-paul-2515091b9" rel="noreferrer noopener" target="_blank">Dewanshi Paul</a></strong> <em>and <em><a href="https://www.linkedin.com/in/imsudip/" rel="noreferrer noopener" target="_blank"><strong>Sudip Ghosh</strong></a></em></em> </em></em><em><em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/contribute/help-us-grow-takeuforward/">please check out this articl</a></em>e</p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>