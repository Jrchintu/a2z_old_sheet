<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Number of Distinct Substrings in a String Using Trie</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1;
            /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs);
            /* 5px */
            padding: var(--spacing-sm);
            /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.25rem;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5rem;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm);
            /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9rem;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1rem;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1rem;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm);
            /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1rem;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg);
            /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm);
            /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto;
                /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm);
                /* 10px */
            }

            h1 {
                font-size: 2rem;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Number of Distinct Substrings in a String Using Trie</h1>
</header>
<article>
<p><strong>Problem Statement: </strong>  Implement a program that takes a string 'S' as input and returns the number of distinct substrings of the given string, including the empty substring. Use a trie data structure to accomplish this.</p>
<p>
Note:
<ol><li>
A string ‘B’ is considered a substring of a string ‘A’ if ‘B’ can be obtained by deleting zero or more characters from the start and end of ‘A’.</li><li>Two strings ‘X’ and ‘Y’ are considered different if there is at least one index ‘i’ such that the character of ‘X’ at index ‘i’ is different from the character of ‘Y’ at index ‘i’ (i.e., X[i] != Y[i]).</li></ol>
</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
                <span><strong>Input:</strong> Input String = [‘abab’]</span>
                
                <span><strong>Output:</strong> 8</span>
                
                <span><strong>Explanation: </strong>All possible substring of ‘abab’ are:</span>
                <ol><li>“”</li>
                <li>“a”</li>
                <li>“b”</li>
                <li>“ab”</li>
                <li>“aba”</li>
                <li>“abab”</li>
                <li>“bab”</li>
                <li>“ba”</li></ol>
                         
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong> Input String = [“bob”]
                </span>                
               
                <span><strong>Output: </strong>7</span>
                
                <span><strong>Explanation: </strong> All possible substring of ‘bob’ are:</span>
                <ol><li>“”</li>
                <li>“b”</li>
                <li>“bo”</li>
                <li>“bob”</li>
                <li>“o”</li>
                <li>“ob”</li>
                <li>“b”</li></ol>
                

            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!--Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/count-distinct-substrings_985292?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>To find all the distinct substrings of a given string we iterate through the string and construct substrings starting from each character. Add each substring created to a set to only store the unique substrings.</p>
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1:</strong> Initialise an empty set to store distinct substrings.</p>
<p><strong>Step 2:</strong>  Iterate through each character of the string. Start from the first character and iterate through each subsequent character.</p>
<p><strong>Step 3:</strong> For each starting character, construct all possible starting from that character using nested loops:
                        <ol><li>The outer loop iterates over each character, acting as the starting point of the substring.</li><li>The inner loop iterates over the subsequent characters to construct the substring.</li><li>Add each constructed substring to the set.</li></ol></p>
<p><strong>Step 4: </strong>Return the set containing all distinct substrings of the given string.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
using namespace std;

// Function to count all distinct
// substrings of a given string
set&lt;string&gt; countDistinctSubstrings(const string&amp; s) {
    // Set to store
    // distinct substrings
    set&lt;string&gt; st;

    // Length of the
    // input string
    int n = s.length();

    // Iterate over each
    // character in the string
    for (int i = 0; i &lt; n; i++) {
        // Initialize an empty string
        // to store the current substring
        string str = "";

        // Iterate over the remaining characters 
        // in the string starting from index i
        for (int j = i; j &lt; n; j++) {
            // Append the current
            // character to the substring
            str += s[j];

            // Insert the current
            // substring into the set
            st.insert(str);
        }
    }

    // Return the set containing
    // all distinct substrings
    return st;
}

int main() {
    string s = "striver";
    cout &lt;&lt; "Given String: " &lt;&lt; s &lt;&lt; endl;

    // Call the function to
    // count distinct substrings
    set&lt;string&gt; substrings = countDistinctSubstrings(s);
    int count = 0;
    // Print the distinct substrings
    cout &lt;&lt; "Distinct Substrings:" &lt;&lt; endl;
    for (const auto&amp; substr : substrings) {
        cout &lt;&lt; substr &lt;&lt; endl;
        count ++;
    }
    // Count + 1 as we have to count
    // the empty string as well
    cout &lt;&lt; "Number of distinct substrings: "&lt;&lt; count + 1&lt;&lt; endl;

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.HashSet;
import java.util.Set;

public class Main {
    // Function to count all distinct
    // substrings of a given string
    static Set&lt;String&gt; countDistinctSubstrings(String s) {
        // Set to store
        // distinct substrings
        Set&lt;String&gt; st = new HashSet&lt;&gt;();

        // Length of the
        // input string
        int n = s.length();

        // Iterate over each
        // character in the string
        for (int i = 0; i &lt; n; i++) {
            // Initialize an empty string
            // to store the current substring
            StringBuilder str = new StringBuilder();

            // Iterate over the remaining characters
            // in the string starting from index i
            for (int j = i; j &lt; n; j++) {
                // Append the current
                // character to the substring
                str.append(s.charAt(j));

                // Insert the current
                // substring into the set
                st.add(str.toString());
            }
        }

        // Return the set containing
        // all distinct substrings
        return st;
    }

    public static void main(String[] args) {
        String s = "striver";
        System.out.println("Given String: " + s);

        // Call the function to
        // count distinct substrings
        Set&lt;String&gt; substrings = countDistinctSubstrings(s);
        int count = 0;

        // Print the distinct substrings
        System.out.println("Distinct Substrings:");
        for (String substr : substrings) {
            System.out.println(substr);
            count++;
        }

        // Count + 1 as we have to count
        // the empty string as well
        System.out.println("Number of distinct substrings: " + (count + 1));
    }
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
# Function to count all distinct
# substrings of a given string
def count_distinct_substrings(s):
    # Set to store
    # distinct substrings
    st = set()

    # Length of the
    # input string
    n = len(s)

    # Iterate over each
    # character in the string
    for i in range(n):
        # Initialize an empty string
        # to store the current substring
        substr = ""

        # Iterate over the remaining characters 
        # in the string starting from index i
        for j in range(i, n):
            # Append the current
            # character to the substring
            substr += s[j]

            # Insert the current
            # substring into the set
            st.add(substr)

    # Return the set containing
    # all distinct substrings
    return st

if __name__ == "__main__":
    s = "striver"
    print("Given String:", s)

    # Call the function to
    # count distinct substrings
    substrings = count_distinct_substrings(s)
    count = 0

    # Print the distinct substrings
    print("Distinct Substrings:")
    for substr in substrings:
        print(substr)
        count += 1

    # Count + 1 as we have to count
    # the empty string as well
    print("Number of distinct substrings:", count + 1)
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Function to count all distinct
// substrings of a given string
function countDistinctSubstrings(s) {
    // Set to store
    // distinct substrings
    const st = new Set();

    // Length of the
    // input string
    const n = s.length;

    // Iterate over each
    // character in the string
    for (let i = 0; i &lt; n; i++) {
        // Initialize an empty string
        // to store the current substring
        let str = "";

        // Iterate over the remaining characters 
        // in the string starting from index i
        for (let j = i; j &lt; n; j++) {
            // Append the current
            // character to the substring
            str += s[j];

            // Insert the current
            // substring into the set
            st.add(str);
        }
    }

    // Return the set containing
    // all distinct substrings
    return st;
}

// Main function to test the code
function main() {
    const s = "striver";
    console.log("Given String: " + s);

    // Call the function to
    // count distinct substrings
    const substrings = countDistinctSubstrings(s);
    let count = 0;

    // Print the distinct substrings
    console.log("Distinct Substrings:");
    for (const substr of substrings) {
        console.log(substr);
        count++;
    }

    // Count + 1 as we have to count
    // the empty string as well
    console.log("Number of distinct substrings: " + (count + 1));
}

// Call the main function
main();

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Given String: striver</p>
<p>Distinct Substrings:</p>
<p>e</p>
<p>er</p>
<p>i</p>
<p>iv</p>
<p>ive</p>
<p>iver</p>
<p>r</p>
<p>ri</p>
<p>riv</p>
<p>rive</p>
<p>river</p>
<p>s</p>
<p>st</p>
<p>str</p>
<p>stri</p>
<p>striv</p>
<p>strive</p>
<p>striver</p>
<p>t</p>
<p>tr</p>
<p>tri</p>
<p>triv</p>
<p>trive</p>
<p>triver</p>
<p>v</p>
<p>ve</p>
<p>ver</p>
<p>Number of distinct substrings: 28</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(N*N)</strong> where N is the number of characters in the given word. The implementation has two nested loops:
                        <ol><li>The outer loop iterates over each character of the string, leading to O(N) iterations.</li><li>The inner loop iterates over the remaining characters in the string for each character, also leading to O(N) iterations in the worst case.</li></ol></p>
<p><strong>Space Complexity : O(N*N)</strong>where N is the number of characters in the given word. The size of the set to store distinct substrings can grow up to O(N*N) in the worst case where all substrings are distinct. Each substring stored in the set occupies space proportional to its length, but the total space occupied by all substrings will limit to O(N*N).</p>
</p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>Instead of using the nested loops for the previous approach, using a Trie data structure significantly reduces the number of comparisons needed as we traverse the substring, resulting in better performance. </p>
<p>The Trie also uses memory efficiently by storing only the necessary information and avoids redundancy by sharing common prefixes among substrings for better space utilisation especially for long strings with many repeated substrings. Read more about the Implementation of a Trie here:<a href="https://takeuforward.org/data-structure/implement-trie-1/"> Implement Trie | Search | Insert | Startswith</a></p>
<p><strong>Algorithm</strong></p>
<p><strong>Step 1: </strong>
                        Initialise a root node for the Trie.</p>
<p><strong>Step 2: </strong>
                        Iterate through all the input string and for each character: Traverse the trie, creating new nodes as necessary to represent the substrings formed by the characters seen so far.

                        </p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/6bee527301189aae43ef920accb89b3b" width="600">
<p><strong>Step 3: </strong> Initialise a counter to keep track of the number of the number of distinct substrings.
                        <ol><li>Iterate through all possible starting positions ‘i’ of the substring.</li><li>Start from the ‘root’ node for each substring.</li><li>For each character at index ‘j’ in the substring starting from position ‘i’:<ol><li>Check if the current node has a child node corresponding to the character at index j.</li><li>If not, insert a new child node for character at index j and increment the counter since a new substring is found.</li><li>Move to the child node corresponding to the character at index i.</li></ol></li><li>Repeat this process for all substrings starting from position ‘i’.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/2a339af3134ca081cd38376cb3e5c635" width="600"/>
<p><strong>Step 4: </strong>Return the total count of distinct substrings + 1 added to account for the input string itself.</p>
</figure></img></figure></div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;  
#include &lt;string&gt;    

using namespace std;  


// Node structure representing
// each node in the trie
struct Node {
    Node* links[26];  
    // Array of pointers to child nodes,
    // each corresponding to a letter
    // of the alphabet
    bool flag = false;  
    // Flag indicating if the current
    // node represents the end of a substring

    // Method to check if a specific character key
    // exists in the children of the current node
    bool containsKey(char ch) {  
        // Check if the current node has a child node
        // corresponding to character 'ch'
        return (links[ch - 'a'] != NULL);
    }

    // Method to get the child node corresponding
    // to a specific character key
    Node* get(char ch) {  
        // Get the child node
        // corresponding to character 'ch'
        return links[ch - 'a'];
    }

    // Method to insert a new child
    // node with a specific character key
    void put(char ch, Node* node) {  
        // Insert a new child
        // node for character 'ch'
        links[ch - 'a'] = node;
    }

    // Method to mark the current
    // node as the end of a substring
    void setEnd() {  
        // Mark the current node
        // as the end of a substring
        flag = true;
    }

    // Method to check if the current
    // node marks the end of a substring
    bool isEnd() {  
        // Check if the current node
        // marks the end of a substring
        return flag;
    }
};

// Function to count the number of
// distinct substrings in the given string
int countDistinctSubstrings(string &amp;s) {  
    // Function to count distinct
    // substrings in the input string 's'
    Node* root = new Node();  
    // Creating the root
    // node of the trie
    int cnt = 0;  
    // Counter to keep track
    // of distinct substrings
    int n = s.size();  
    // Length of the input string

    // Nested loops to iterate through all
    // possible substrings of the input string
    for (int i = 0; i &lt; n; i++) {  
        // Iterate through each
        // starting position of the substring
        Node* node = root;  
        // Start from the root for each substring
        for (int j = i; j &lt; n; j++) {  
            // Iterate through each character of the substring
            // If the current character is not a child
            // of the current node, insert it as a new child node
            if (!node-&gt;containsKey(s[j])) {
                node-&gt;put(s[j], new Node());  
                // Insert a new child
                // node for character s[j]
                cnt++;  
                // Increment the counter
                // since a new substring is found
            }
            node = node-&gt;get(s[j]);  
            // Move to the child node
            // corresponding to character s[j]
        }
    }
     // Return the total count of distinct substrings
     // (+1 to account for the input string itself)
    return cnt + 1;  
  
}

int main() {  
    // Main function to test the
    // countDistinctSubstrings function
    string s = "striver";  
    cout &lt;&lt; "Current String: " &lt;&lt; s &lt;&lt; endl;
    // Input string
    cout &lt;&lt; "Number of distinct substrings: " &lt;&lt; countDistinctSubstrings(s) &lt;&lt; endl;  
    return 0;  

}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.HashMap;

// Node structure representing
// each node in the trie
class Node {
    Node[] links;  
    // Array of pointers to child nodes,
    // each corresponding to a letter
    // of the alphabet
    boolean flag;  
    // Flag indicating if the current
    // node represents the end of a substring

    // Method to check if a specific character key
    // exists in the children of the current node
    public boolean containsKey(char ch) {  
        // Check if the current node has a child node
        // corresponding to character 'ch'
        return links[ch - 'a'] != null;
    }

    // Method to get the child node corresponding
    // to a specific character key
    public Node get(char ch) {  
        // Get the child node
        // corresponding to character 'ch'
        return links[ch - 'a'];
    }

    // Method to insert a new child
    // node with a specific character key
    public void put(char ch, Node node) {  
        // Insert a new child
        // node for character 'ch'
        links[ch - 'a'] = node;
    }

    // Method to mark the current
    // node as the end of a substring
    public void setEnd() {  
        // Mark the current node
        // as the end of a substring
        flag = true;
    }

    // Method to check if the current
    // node marks the end of a substring
    public boolean isEnd() {  
        // Check if the current node
        // marks the end of a substring
        return flag;
    }
}

// Function to count the number of
// distinct substrings in the given string
public class Main {  
    // Function to count the number of
    // distinct substrings in the given string
    public static int countDistinctSubstrings(String s) {  
        // Function to count distinct
        // substrings in the input string 's'
        Node root = new Node();  
        // Creating the root
        // node of the trie
        int cnt = 0;  
        // Counter to keep track
        // of distinct substrings
        int n = s.length();  
        // Length of the input string

        // Nested loops to iterate through all
        // possible substrings of the input string
        for (int i = 0; i &lt; n; i++) {  
            // Iterate through each
            // starting position of the substring
            Node node = root;  
            // Start from the root for each substring
            for (int j = i; j &lt; n; j++) {  
                // Iterate through each character of the substring
                // If the current character is not a child
                // of the current node, insert it as a new child node
                if (!node.containsKey(s.charAt(j))) {
                    node.put(s.charAt(j), new Node());  
                    // Insert a new child
                    // node for character s.charAt(j)
                    cnt++;  
                    // Increment the counter
                    // since a new substring is found
                }
                node = node.get(s.charAt(j));  
                // Move to the child node
                // corresponding to character s.charAt(j)
            }
        }
        return cnt + 1;  
        // Return the total count of distinct substrings
        // (+1 to account for the input string itself)
    }

    // Main function to test the
    // countDistinctSubstrings function
    public static void main(String[] args) {  
        String s = "striver";  
        // Input string
        System.out.println("Current String: " + s);
        System.out.println("Number of distinct substrings: " + countDistinctSubstrings(s));  
        // Output the result
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
class Node:
    """
    Node structure representing
    each node in the trie
    """

    def __init__(self):
        self.links = [None] * 26  
        # Array of pointers to child nodes,
        # each corresponding to a letter
        # of the alphabet
        self.flag = False  
        # Flag indicating if the current
        # node represents the end of a substring

    def containsKey(self, ch):
        """
        Method to check if a specific character key
        exists in the children of the current node
        """
        # Check if the current node has a child node
        # corresponding to character 'ch'
        return self.links[ord(ch) - ord('a')] is not None

    def get(self, ch):
        """
        Method to get the child node corresponding
        to a specific character key
        """
        # Get the child node
        # corresponding to character 'ch'
        return self.links[ord(ch) - ord('a')]

    def put(self, ch, node):
        """
        Method to insert a new child
        node with a specific character key
        """
        # Insert a new child
        # node for character 'ch'
        self.links[ord(ch) - ord('a')] = node

    def setEnd(self):
        """
        Method to mark the current
        node as the end of a substring
        """
        # Mark the current node
        # as the end of a substring
        self.flag = True

    def isEnd(self):
        """
        Method to check if the current
        node marks the end of a substring
        """
        # Check if the current node
        # marks the end of a substring
        return self.flag


def countDistinctSubstrings(s):
    """
    Function to count the number of
    distinct substrings in the given string
    """
    root = Node()  
    # Creating the root
    # node of the trie
    cnt = 0  
    # Counter to keep track
    # of distinct substrings
    n = len(s)  
    # Length of the input string

    # Nested loops to iterate through all
    # possible substrings of the input string
    for i in range(n):  
        # Iterate through each
        # starting position of the substring
        node = root  
        # Start from the root for each substring
        for j in range(i, n):  
            # Iterate through each character of the substring
            # If the current character is not a child
            # of the current node, insert it as a new child node
            if not node.containsKey(s[j]):
                node.put(s[j], Node())  
                # Insert a new child
                # node for character s[j]
                cnt += 1  
                # Increment the counter
                # since a new substring is found
            node = node.get(s[j])  
            # Move to the child node
            # corresponding to character s[j]

    return cnt + 1  
    # Return the total count of distinct substrings
    # (+1 to account for the input string itself)


if __name__ == "__main__":
    s = "striver"  
    # Input string
    print("Current String:", s)
    print("Number of distinct substrings:", countDistinctSubstrings(s))  
    # Output the result
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node class representing each node in the trie
class Node {
    constructor() {
        this.links = new Array(26);  
        // Array of pointers to child nodes,
        // each corresponding to a letter
        // of the alphabet
        this.flag = false;  
        // Flag indicating if the current
        // node represents the end of a substring
    }

    // Method to check if a specific character key
    // exists in the children of the current node
    containsKey(ch) {  
        // Check if the current node has a child node
        // corresponding to character 'ch'
        return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] !== undefined;
    }

    // Method to get the child node corresponding
    // to a specific character key
    get(ch) {  
        // Get the child node
        // corresponding to character 'ch'
        return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)];
    }

    // Method to insert a new child
    // node with a specific character key
    put(ch, node) {  
        // Insert a new child
        // node for character 'ch'
        this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] = node;
    }

    // Method to mark the current
    // node as the end of a substring
    setEnd() {  
        // Mark the current node
        // as the end of a substring
        this.flag = true;
    }

    // Method to check if the current
    // node marks the end of a substring
    isEnd() {  
        // Check if the current node
        // marks the end of a substring
        return this.flag;
    }
}

// Function to count the number of
// distinct substrings in the given string
function countDistinctSubstrings(s) {  
    // Function to count distinct
    // substrings in the input string 's'
    const root = new Node();  
    // Creating the root
    // node of the trie
    let cnt = 0;  
    // Counter to keep track
    // of distinct substrings
    const n = s.length;  
    // Length of the input string

    // Nested loops to iterate through all
    // possible substrings of the input string
    for (let i = 0; i &lt; n; i++) {  
        // Iterate through each
        // starting position of the substring
        let node = root;  
        // Start from the root for each substring
        for (let j = i; j &lt; n; j++) {  
            // Iterate through each character of the substring
            // If the current character is not a child
            // of the current node, insert it as a new child node
            if (!node.containsKey(s[j])) {
                node.put(s[j], new Node());  
                // Insert a new child
                // node for character s[j]
                cnt++;  
                // Increment the counter
                // since a new substring is found
            }
            node = node.get(s[j]);  
            // Move to the child node
            // corresponding to character s[j]
        }
    }
    return cnt + 1;  
    // Return the total count of distinct substrings
    // (+1 to account for the input string itself)
}

// Main function to test the
// countDistinctSubstrings function
function main() {  
    const s = "striver";  
    // Input string
    console.log("Current String: " + s);
    console.log("Number of distinct substrings: " + countDistinctSubstrings(s));  
    // Output the result
}

main();         
                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Current String: striver ,Number of distinct substrings: 28</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(N*N)</strong>where N is the length of the input string. This is because for each starting position of the substring, we traverse the entire substring once. However, due to the Trie structure, the actual number of comparisons is reduced as we progress.</p>
<p><strong>Space Complexity : O(N*N)</strong> where N is the length of the input string. In the worst-case scenario, where there are no common prefixes among substrings the number of nodes could be as high as the total number of substrings which is bounded by O(N*N). </p>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/RV0QeTyHZxo?si=fzIH7QuxT1t-AMdZ" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>