<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Clone Linked List with Random and Next Pointer</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            /* line-height: 1.7; */
            color: #333;
            background-color: #fdfdfd;
            margin: 5px;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 5px;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Clone Linked List with Random and Next Pointer</h1>
</header>
<article>
<p><strong>Problem Statement: </strong>Given a linked list where every node in the linked list contains two pointers:
<ol><li>‘next’ which points to the next node in the list.</li>
<li>‘random’ which points to a random node in the list or ‘null’.</li></ol></p>
<p>Create a ‘deep copy’ of the given linked list and return it.
</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>

                <span><strong>Input:</strong>
                </span>

                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/2a3dd7baf1bb00e65adbc6f7c864f22f" width="439"/></figure>
               
                <span><strong>Output:</strong>
                </span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/9af08cc1f4392004bf22bcbee043d8a0" width="439"/></figure>
                <span><strong>Explanation: </strong>  A deep copy of the linked list has to be created while maintaining all ‘next’ and ‘random’ pointers to the appropriate new nodes. Additional memory allocation is done while creating a duplicate set of nodes and managing their pointer relationships.</span>
                
                <br/>
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/decd222f443010bfe67c95bcb55ee8a8" width="439"/></figure>                
                
                <span><strong>Output: </strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/5187af932429ed1f0180afe4783e96c5" width="439"/></figure>
                <span><strong>Explanation: </strong> A deep copy of the linked list has to be created while maintaining all ‘next’ and ‘random’ pointers to the appropriate new nodes. Additional memory allocation is done while creating a duplicate set of nodes and managing their pointer relationships.</span>
                
            </pre>
</div>
</details>
</div>
<!-- This is Practice Section
<div class="practice">
    <span><strong>Practice: </strong></span>
    <div class="problem-buttons">

         
        <a href="https://www.codingninjas.com/studio/problems/power-of-numbers_8157729?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga" alt="code-studio">
        </a>
    </div>
    
</div>-->
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>To create a deep copy of the original linked list we can use a map to establish a relationship between original nodes and their copied nodes.</p>
<p>We traverse the list first to create a copied node for each original node then traverse and establish the correct connections between the copied nodes similar to the arrangement of next and random pointers of the original pointers. In the end, return the head of the copied list obtained from the map.</p>
<h4>Algorithm </h4>
<p><strong>Step 1:</strong>Initialise variables ‘temp’ as a pointer to the head of the original linked list to traverse it. Create an empty unordered_map, to map original nodes to their corresponding copied nodes.</p>
<p><strong>Step 2: </strong>  Iterate through the original linked list and for each node in the linked list create a new node with the same data value as the original data. Map the original node to its copied node in the map.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/6eff517d4826eda64a5d5d6a34e40159" width="439"/></figure>
<p><strong>Step 3: </strong>
                         Iterate through the original list again but this time connect the pointers of the copied nodes in the same arrangement as the original node.
                         <ol><li>Get the copied node corresponding to the original node using the map.</li><li>Set the next pointer of the copied node to the copied node mapped to the original node’s next node.</li><li>Set the random pointer of the copied node to the original node’s next node copied from the map.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/162499ffdd590de436b28b3557869032" width="439"/></figure>
<p><strong>Step 4: </strong>
                         Return the head of the deep copied list which is obtained by retrieving the copied nodes mapped to the original head from the map.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;
using namespace std;

// Node class to represent
// elements in the linked list
class Node {
public:
    // Data stored in the node
    int data;           
     // Pointer to the next node
    Node *next;        
    // Pointer to a random
    // node in the list
    Node *random;       

    // Constructors for Node class
    Node() : data(0), next(nullptr), random(nullptr){}; 
    Node(int x) : data(x), next(nullptr), random(nullptr) {} 
    // Constructor with data,
    // next, and random pointers
    Node(int x, Node *nextNode, Node *randomNode) :
            data(x), next(nextNode), random(randomNode) {}  
};


// Function to clone the linked list
Node *cloneLL(Node *head){
    Node* temp = head;
    // Create an unordered_map to map original
    // nodes to their corresponding copied nodes
    unordered_map&lt;Node*, Node*&gt; mpp;

    // Step 1: Create copies of each node
    // and store them in the map
    while(temp != NULL){
        // Create a new node with the
        // same data as the original node
        Node* newNode = new Node(temp-&gt;data);
        // Map the original node to its
        // corresponding copied node in the map
        mpp[temp] = newNode;
        // Move to the next node in the original list
        temp = temp-&gt;next;
    }
    
    temp = head;
    // Step 2: Connect the next and random
    // pointers of the copied nodes using the map
    while(temp != NULL){
        // Access the copied node corresponding
        // to the current original node
        Node* copyNode = mpp[temp];
        // Set the next pointer of the copied node
        // to the copied node mapped to the
        // next node in the original list
        copyNode-&gt;next = mpp[temp-&gt;next];
        // Set the random pointer of the copied node
        // to the copied node mapped to the
        // random node in the original list
        copyNode-&gt;random = mpp[temp-&gt;random];
        // Move to the next node
        // in the original list
        temp = temp-&gt;next;
    }
    
    // Return the head of the
    // deep copied list from the map
    return mpp[head];
}


// Function to print the cloned linked list
void printClonedLinkedList(Node *head) {
    while (head != nullptr) {
        cout &lt;&lt; "Data: " &lt;&lt; head-&gt;data;
        if (head-&gt;random != nullptr) {
            cout &lt;&lt; ", Random: " &lt;&lt; head-&gt;random-&gt;data;
        } else {
            cout &lt;&lt; ", Random: nullptr";
        }
        cout &lt;&lt; endl;
         // Move to the next node
        head = head-&gt;next;  
    }
}

// Main function
int main() {
    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    Node* head = new Node(7);
    head-&gt;next = new Node(14);
    head-&gt;next-&gt;next = new Node(21);
    head-&gt;next-&gt;next-&gt;next = new Node(28);

    // Assigning random pointers
    head-&gt;random = head-&gt;next-&gt;next;
    head-&gt;next-&gt;random = head;
    head-&gt;next-&gt;next-&gt;random = head-&gt;next-&gt;next-&gt;next;
    head-&gt;next-&gt;next-&gt;next-&gt;random = head-&gt;next;

    cout &lt;&lt; "Original Linked List with Random Pointers:" &lt;&lt; endl;
    printClonedLinkedList(head);

    // Clone the linked list
    Node* clonedList = cloneLL(head);

    cout &lt;&lt; "\nCloned Linked List with Random Pointers:" &lt;&lt; endl;
    printClonedLinkedList(clonedList);

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.HashMap;

// Node class to represent
// elements in the linked list
class Node {
    // Data stored in the node
    int data;
    // Pointer to the next node
    Node next;
    // Pointer to a random node in the list
    Node random;

    // Constructors for Node class
    Node() {
        this.data = 0;
        this.next = null;
        this.random = null;
    }

    Node(int x) {
        this.data = x;
        this.next = null;
        this.random = null;
    }

    Node(int x, Node nextNode, Node randomNode) {
        this.data = x;
        this.next = nextNode;
        this.random = randomNode;
    }
}

public class Main {
    // Function to clone the linked list
    public static Node cloneLL(Node head) {
        Node temp = head;
        // Create a HashMap to map original nodes
        // to their corresponding copied nodes
        HashMap&lt;Node, Node&gt; map = new HashMap&lt;&gt;();

        // Step 1: Create copies of each
        // node and store them in the map
        while (temp != null) {
            // Create a new node with the
            // same data as the original node
            Node newNode = new Node(temp.data);
            // Map the original node to its
            // corresponding copied node in the map
            map.put(temp, newNode);
            // Move to the next node in the original list
            temp = temp.next;
        }

        temp = head;
        // Step 2: Connect the next and random
        // pointers of the copied nodes using the map
        while (temp != null) {
            // Access the copied node corresponding
            // to the current original node
            Node copyNode = map.get(temp);
            // Set the next pointer of the copied node
            // to the copied node mapped to the
            // next node in the original list
            copyNode.next = map.get(temp.next);
            // Set the random pointer of the copied node
            // to the copied node mapped to the
            // random node in the original list
            copyNode.random = map.get(temp.random);
            // Move to the next node in the original list
            temp = temp.next;
        }

        // Return the head of the
        // deep copied list from the map
        return map.get(head);
    }

    // Function to print the cloned linked list
    public static void printClonedLinkedList(Node head) {
        while (head != null) {
            System.out.print("Data: " + head.data);
            if (head.random != null) {
                System.out.print(", Random: " + head.random.data);
            } else {
                System.out.print(", Random: nullptr");
            }
            System.out.println();
            // Move to the next node in the list
            head = head.next;
        }
    }

    // Main function
    public static void main(String[] args) {
        // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
        Node head = new Node(7);
        head.next = new Node(14);
        head.next.next = new Node(21);
        head.next.next.next = new Node(28);

        // Assigning random pointers
        head.random = head.next.next;
        head.next.random = head;
        head.next.next.random = head.next.next.next;
        head.next.next.next.random = head.next;

        System.out.println("Original Linked List with Random Pointers:");
        printClonedLinkedList(head);

        // Clone the linked list
        Node clonedList = cloneLL(head);

        System.out.println("\nCloned Linked List with Random Pointers:");
        printClonedLinkedList(clonedList);
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
# Node class to represent
# elements in the linked list
class Node:
    def __init__(self, x, nextNode=None, randomNode=None):
        # Data stored in the node
        self.data = x
        # Pointer to the next node
        self.next = nextNode
        # Pointer to a random
        # node in the list
        self.random = randomNode


# Function to clone the linked list
def cloneLL(head):
    temp = head
    # Create a dictionary to map original
    # nodes to their corresponding copied nodes
    mpp = {}

    # Step 1: Create copies of each node
    # and store them in the map
    while temp is not None:
        # Create a new node with the
        # same data as the original node
        newNode = Node(temp.data)
        # Map the original node to its
        # corresponding copied node in the dictionary
        mpp[temp] = newNode
        # Move to the next node in the original list
        temp = temp.next

    temp = head
    # Step 2: Connect the next and random
    # pointers of the copied nodes using the dictionary
    while temp is not None:
        # Access the copied node corresponding
        # to the current original node
        copyNode = mpp[temp]
        # Set the next pointer of the copied node
        # to the copied node mapped to the
        # next node in the original list
        copyNode.next = mpp[temp.next]
        # Set the random pointer of the copied node
        # to the copied node mapped to the
        # random node in the original list
        copyNode.random = mpp[temp.random]
        # Move to the next node
        # in the original list
        temp = temp.next

    # Return the head of the
    # deep copied list from the dictionary
    return mpp[head]


# Function to print the cloned linked list
def printClonedLinkedList(head):
    while head is not None:
        print(f"Data: {head.data}", end="")
        if head.random is not None:
            print(f", Random: {head.random.data}")
        else:
            print(", Random: nullptr")
        head = head.next


# Main function
if __name__ == "__main__":
    # Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    head = Node(7)
    head.next = Node(14)
    head.next.next = Node(21)
    head.next.next.next = Node(28)

    # Assigning random pointers
    head.random = head.next.next
    head.next.random = head
    head.next.next.random = head.next.next.next
    head.next.next.next.random = head.next

    print("Original Linked List with Random Pointers:")
    printClonedLinkedList(head)

    # Clone the linked list
    clonedList = cloneLL(head)

    print("\nCloned Linked List with Random Pointers:")
    printClonedLinkedList(clonedList)
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node class to represent
// elements in the linked list
class Node {
    // Data stored in the node
    constructor(data) {
        this.data = data;
        // Pointer to the next node
        this.next = null;
        // Pointer to a random node in the list
        this.random = null;
    }
}

// Function to clone the linked list
function cloneLL(head) {
    let temp = head;
    // Create a map to map original nodes
    // to their corresponding copied nodes
    let mpp = new Map();

    // Step 1: Create copies of each
    // node and store them in the map
    while (temp !== null) {
        // Create a new node with the
        // same data as the original node
        let newNode = new Node(temp.data);
        // Map the original node to its
        // corresponding copied node in the map
        mpp.set(temp, newNode);
        // Move to the next node in the original list
        temp = temp.next;
    }

    temp = head;
    // Step 2: Connect the next and random
    // pointers of the copied nodes using the map
    while (temp !== null) {
        // Access the copied node corresponding
        // to the current original node
        let copyNode = mpp.get(temp);
        // Set the next pointer of the copied node
        // to the copied node mapped to the next
        // node in the original list
        copyNode.next = mpp.get(temp.next);
        // Set the random pointer of the copied node
        // to the copied node mapped to the random
        // node in the original list
        copyNode.random = mpp.get(temp.random);
        // Move to the next node in the original list
        temp = temp.next;
    }

    // Return the head of the
    // deep copied list from the map
    return mpp.get(head);
}

// Function to print the cloned linked list
function printClonedLinkedList(head) {
    while (head !== null) {
        console.log(`Data: ${head.data}` + (head.random !== null ? `,
                        Random: ${head.random.data}` : `, Random: null`));
        // Move to the next node in the list
        head = head.next;
    }
}

// Main function
function main() {
    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    let head = new Node(7);
    head.next = new Node(14);
    head.next.next = new Node(21);
    head.next.next.next = new Node(28);

    // Assigning random pointers
    head.random = head.next.next;
    head.next.random = head;
    head.next.next.random = head.next.next.next;
    head.next.next.next.random = head.next;

    console.log("Original Linked List with Random Pointers:");
    printClonedLinkedList(head);

    // Clone the linked list
    let clonedList = cloneLL(head);

    console.log("\nCloned Linked List with Random Pointers:");
    printClonedLinkedList(clonedList);
}

// Calling the main function to execute the code
main();

                            </code>
                        </pre>
</div>
<p><strong>Output: </strong>Original Linked List with Random Pointers: 
                        Data: 7, Random: 21
                        Data: 14, Random: 7
                        Data: 21, Random: 28
                        Data: 28, Random: 14

                        Cloned Linked List with Random Pointers:
                        Data: 7, Random: 21
                        Data: 14, Random: 7
                        Data: 21, Random: 28
                        Data: 28, Random: 14</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(2N)</strong> where N is the number of nodes in the linked list. The linked list is traversed twice, once for creating copies of each node and for the second time to set the next and random pointers for each copied node. The time to access the nodes in the map is O(1) due to hashing.</p>
<p><strong>Space Complexity : O(N)+O(N)</strong>where N is the number of nodes in the linked list as all nodes are stored in the map to maintain mappings and the copied linked lists takes O(N) space as well.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>The previous approach uses an extra space complexity of creating mappings between the original and copied nodes. Instead of creating duplicate nodes and storing them in a map, insert it in between the original node and the next node for quick access without the need for additional space.</p>
<p>Traverse the list again to set the random pointer of copied nodes to the corresponding copied node duplicating the original arrangement. As a final traversal, separate the copied and original nodes by detaching alternate nodes.</p>
<p><strong>Algorithm</strong></p>
<p><strong>Step 1: </strong>
                        Traverse the original node and create a copy of each node and insert it in between the original node and the next node.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/7548f434f1ec560c9399a099432da7f9" width="439"/></figure>
<p><strong>Step 2: </strong>Traverse this modified list and for each original node that has a random pointer, set the copied node’s random pointer to the corresponding copies random node. If the original node’s random pointer is full, set the copied node’s random pointe to null as well.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ce08c337882c0dcdcadb68d132fea9a6" width="439"/></figure>
<p><strong>Step 3: Recursion</strong>Traverse the modified list again and extract the coped nodes by breaking the links between the original nodes and the copied nodes. Revert the original list to its initial state by fixing the next pointers.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ea114c12852f943b7e0a62f71f57d0bb" width="439"/></figure>
<p><strong>Step 4: </strong>Return the head of the deep copy obtained after extracting the copied nodes from the modified list.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
using namespace std;

// Node class to represent
// elements in the linked list
class Node {
public:
    // Data stored in the node
    int data;           
     // Pointer to the next node
    Node *next;        
    // Pointer to a random
    // node in the list
    Node *random;       

    // Constructors for Node class
    Node() : data(0), next(nullptr), random(nullptr){}; 
    Node(int x) : data(x), next(nullptr), random(nullptr) {} 
    // Constructor with data,
    // next, and random pointers
    Node(int x, Node *nextNode, Node *randomNode) :
            data(x), next(nextNode), random(randomNode) {}  
};

// Function to insert a copy of each
// node in between the original nodes
void insertCopyInBetween(Node* head){
    Node* temp = head;
    while(temp != NULL){
        Node* nextElement = temp-&gt;next;
        // Create a new node with the same data
        Node* copy = new Node(temp-&gt;data);  
        
        // Point the copy's next to
        // the original node's next
        copy-&gt;next = nextElement;  
        
        // Point the original
        // node's next to the copy
        temp-&gt;next = copy;         

        // Move to the next original node
        temp = nextElement;         
    }
}

// Function to connect random
// pointers of the copied nodes
void connectRandomPointers(Node* head){
    Node* temp = head;
    while(temp != NULL){
        // Access the copied node
        Node* copyNode = temp-&gt;next;    
        
        // If the original node
        // has a random pointer
        if(temp-&gt;random){   
             // Point the copied node's random to the
             // corresponding copied random node
            copyNode-&gt;random = temp-&gt;random-&gt;next; 
        }
        else{
             // Set the copied node's random to
             // null if the original random is null
            copyNode-&gt;random = NULL;   
        }
        
         // Move to the next original node
        temp = temp-&gt;next-&gt;next;   
    }
}

// Function to retrieve the
// deep copy of the linked list
Node* getDeepCopyList(Node* head){
    Node* temp = head;
     // Create a dummy node
    Node* dummyNode = new Node(-1);   
    // Initialize a result pointer
    Node* res = dummyNode;             

    while(temp != NULL){
        // Creating a new List by
        // pointing to copied nodes
        res-&gt;next = temp-&gt;next;
        res = res-&gt;next;

        // Disconnect and revert back to the
        // initial state of the original linked list
        temp-&gt;next = temp-&gt;next-&gt;next;
        temp = temp-&gt;next;
    }
    
     // Return the deep copy of the
     // list starting from the dummy node
    return dummyNode-&gt;next;   
}

// Function to clone the linked list
Node *cloneLL(Node *head){
    // If the original list
    // is empty, return null
    if(!head) return nullptr;   
    
     // Step 1: Insert copy of
     // nodes in between
    insertCopyInBetween(head); 
    // Step 2: Connect random
    // pointers of copied nodes
    connectRandomPointers(head);  
    // Step 3: Retrieve the deep
    // copy of the linked list
    return getDeepCopyList(head); 
}

// Function to print the cloned linked list
void printClonedLinkedList(Node *head) {
    while (head != nullptr) {
        cout &lt;&lt; "Data: " &lt;&lt; head-&gt;data;
        if (head-&gt;random != nullptr) {
            cout &lt;&lt; ", Random: " &lt;&lt; head-&gt;random-&gt;data;
        } else {
            cout &lt;&lt; ", Random: nullptr";
        }
        cout &lt;&lt; endl;
         // Move to the next node
        head = head-&gt;next;  
    }
}

// Main function
int main() {
    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    Node* head = new Node(7);
    head-&gt;next = new Node(14);
    head-&gt;next-&gt;next = new Node(21);
    head-&gt;next-&gt;next-&gt;next = new Node(28);

    // Assigning random pointers
    head-&gt;random = head-&gt;next-&gt;next;
    head-&gt;next-&gt;random = head;
    head-&gt;next-&gt;next-&gt;random = head-&gt;next-&gt;next-&gt;next;
    head-&gt;next-&gt;next-&gt;next-&gt;random = head-&gt;next;

    cout &lt;&lt; "Original Linked List with Random Pointers:" &lt;&lt; endl;
    printClonedLinkedList(head);

    // Clone the linked list
    Node* clonedList = cloneLL(head);

    cout &lt;&lt; "\nCloned Linked List with Random Pointers:" &lt;&lt; endl;
    printClonedLinkedList(clonedList);

    return 0;
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
// Node class to represent
// elements in the linked list
class Node {
    // Data stored in the node
    int data;
    // Pointer to the next node
    Node next;
    // Pointer to a random
    // node in the list
    Node random;

    // Constructors for Node class
    Node() {
        // Default constructor
        this.data = 0;
        this.next = null;
        this.random = null;
    }

    Node(int x) {
        // Constructor with data
        this.data = x;
        this.next = null;
        this.random = null;
    }

    Node(int x, Node nextNode, Node randomNode) {
        // Constructor with data,
        // next, and random pointers
        this.data = x;
        this.next = nextNode;
        this.random = randomNode;
    }
}

// Function to insert a copy of each
// node in between the original nodes
void insertCopyInBetween(Node head) {
    Node temp = head;
    while (temp != null) {
        Node nextElement = temp.next;
        // Create a new node with the same data
        Node copy = new Node(temp.data);

        // Point the copy's next to
        // the original node's next
        copy.next = nextElement;

        // Point the original
        // node's next to the copy
        temp.next = copy;

        // Move to the next original node
        temp = nextElement;
    }
}

// Function to connect random
// pointers of the copied nodes
void connectRandomPointers(Node head) {
    Node temp = head;
    while (temp != null) {
        // Access the copied node
        Node copyNode = temp.next;

        // If the original node
        // has a random pointer
        if (temp.random != null) {
            // Point the copied node's random to the
            // corresponding copied random node
            copyNode.random = temp.random.next;
        } else {
            // Set the copied node's random to
            // null if the original random is null
            copyNode.random = null;
        }

        // Move to the next original node
        temp = temp.next.next;
    }
}

// Function to retrieve the
// deep copy of the linked list
Node getDeepCopyList(Node head) {
    Node temp = head;
    // Create a dummy node
    Node dummyNode = new Node(-1);
    // Initialize a result pointer
    Node res = dummyNode;

    while (temp != null) {
        // Creating a new List by
        // pointing to copied nodes
        res.next = temp.next;
        res = res.next;

        // Disconnect and revert back to the
        // initial state of the original linked list
        temp.next = temp.next.next;
        temp = temp.next;
    }

    // Return the deep copy of the
    // list starting from the dummy node
    return dummyNode.next;
}

// Function to clone the linked list
Node cloneLL(Node head) {
    // If the original list
    // is empty, return null
    if (head == null) return null;

    // Step 1: Insert copy of
    // nodes in between
    insertCopyInBetween(head);
    // Step 2: Connect random
    // pointers of copied nodes
    connectRandomPointers(head);
    // Step 3: Retrieve the deep
    // copy of the linked list
    return getDeepCopyList(head);
}

// Function to print the cloned linked list
void printClonedLinkedList(Node head) {
    while (head != null) {
        System.out.print("Data: " + head.data);
        if (head.random != null) {
            System.out.print(", Random: " + head.random.data);
        } else {
            System.out.print(", Random: null");
        }
        System.out.println();
        // Move to the next node
        head = head.next;
    }
}

// Main function
public static void main(String[] args) {
    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    Node head = new Node(7);
    head.next = new Node(14);
    head.next.next = new Node(21);
    head.next.next.next = new Node(28);

    // Assigning random pointers
    head.random = head.next.next;
    head.next.random = head;
    head.next.next.random = head.next.next.next;
    head.next.next.next.random = head.next;

    System.out.println("Original Linked List with Random Pointers:");
    printClonedLinkedList(head);

    // Clone the linked list
    Node clonedList = cloneLL(head);

    System.out.println("\nCloned Linked List with Random Pointers:");
    printClonedLinkedList(clonedList);
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
# Node class to represent
# elements in the linked list
class Node:
    # Data stored in the node
    def __init__(self, x):
        self.data = x
        # Pointer to the next node
        self.next = None
        # Pointer to a random
        # node in the list
        self.random = None

# Function to insert a copy of each
# node in between the original nodes
def insertCopyInBetween(head):
    temp = head
    while temp:
        nextElement = temp.next
        # Create a new node with the same data
        copy = Node(temp.data)

        # Point the copy's next to
        # the original node's next
        copy.next = nextElement

        # Point the original
        # node's next to the copy
        temp.next = copy

        # Move to the next original node
        temp = nextElement

# Function to connect random
# pointers of the copied nodes
def connectRandomPointers(head):
    temp = head
    while temp:
        # Access the copied node
        copyNode = temp.next

        # If the original node
        # has a random pointer
        if temp.random:
            # Point the copied node's random to the
            # corresponding copied random node
            copyNode.random = temp.random.next
        else:
            # Set the copied node's random to
            # null if the original random is null
            copyNode.random = None

        # Move to the next original node
        temp = temp.next.next

# Function to retrieve the
# deep copy of the linked list
def getDeepCopyList(head):
    temp = head
    # Create a dummy node
    dummyNode = Node(-1)
    # Initialize a result pointer
    res = dummyNode

    while temp:
        # Creating a new List by
        # pointing to copied nodes
        res.next = temp.next
        res = res.next

        # Disconnect and revert back to the
        # initial state of the original linked list
        temp.next = temp.next.next
        temp = temp.next

    # Return the deep copy of the
    # list starting from the dummy node
    return dummyNode.next

# Function to clone the linked list
def cloneLL(head):
    # If the original list
    # is empty, return null
    if not head:
        return None

    # Step 1: Insert copy of
    # nodes in between
    insertCopyInBetween(head)
    # Step 2: Connect random
    # pointers of copied nodes
    connectRandomPointers(head)
    # Step 3: Retrieve the deep
    # copy of the linked list
    return getDeepCopyList(head)

# Function to print the cloned linked list
def printClonedLinkedList(head):
    while head:
        print("Data:", head.data, end="")
        if head.random:
            print(", Random:", head.random.data, end="")
        else:
            print(", Random: None", end="")
        print()
        # Move to the next node
        head = head.next

# Main function
if __name__ == "__main__":
    # Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    head = Node(7)
    head.next = Node(14)
    head.next.next = Node(21)
    head.next.next.next = Node(28)

    # Assigning random pointers
    head.random = head.next.next
    head.next.random = head
    head.next.next.random = head.next.next.next
    head.next.next.next.random = head.next

    print("Original Linked List with Random Pointers:")
    printClonedLinkedList(head)

    # Clone the linked list
    clonedList = cloneLL(head)

    print("\nCloned Linked List with Random Pointers:")
    printClonedLinkedList(clonedList)

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
 // Node class to represent
// elements in the linked list
class Node {
    // Data stored in the node
    constructor(x, nextNode = null, randomNode = null) {
        this.data = x;
        // Pointer to the next node
        this.next = nextNode;
        // Pointer to a random
        // node in the list
        this.random = randomNode;
    }
}

// Function to insert a copy of each
// node in between the original nodes
function insertCopyInBetween(head) {
    let temp = head;
    while (temp !== null) {
        let nextElement = temp.next;
        // Create a new node with the same data
        let copy = new Node(temp.data);

        // Point the copy's next to
        // the original node's next
        copy.next = nextElement;

        // Point the original
        // node's next to the copy
        temp.next = copy;

        // Move to the next original node
        temp = nextElement;
    }
}

// Function to connect random
// pointers of the copied nodes
function connectRandomPointers(head) {
    let temp = head;
    while (temp !== null) {
        // Access the copied node
        let copyNode = temp.next;

        // If the original node
        // has a random pointer
        if (temp.random) {
            // Point the copied node's random to the
            // corresponding copied random node
            copyNode.random = temp.random.next;
        } else {
            // Set the copied node's random to
            // null if the original random is null
            copyNode.random = null;
        }

        // Move to the next original node
        temp = temp.next.next;
    }
}

// Function to retrieve the
// deep copy of the linked list
function getDeepCopyList(head) {
    let temp = head;
    // Create a dummy node
    let dummyNode = new Node(-1);
    // Initialize a result pointer
    let res = dummyNode;

    while (temp !== null) {
        // Creating a new List by
        // pointing to copied nodes
        res.next = temp.next;
        res = res.next;

        // Disconnect and revert back to the
        // initial state of the original linked list
        temp.next = temp.next.next;
        temp = temp.next;
    }

    // Return the deep copy of the
    // list starting from the dummy node
    return dummyNode.next;
}

// Function to clone the linked list
function cloneLL(head) {
    // If the original list
    // is empty, return null
    if (!head) return null;

    // Step 1: Insert copy of
    // nodes in between
    insertCopyInBetween(head);
    // Step 2: Connect random
    // pointers of copied nodes
    connectRandomPointers(head);
    // Step 3: Retrieve the deep
    // copy of the linked list
    return getDeepCopyList(head);
}

// Function to print the cloned linked list
function printClonedLinkedList(head) {
    while (head !== null) {
        console.log(`Data: ${head.data}${head.random ? `, Random: ${head.random.data}` : ', Random: nullptr'}`);
        // Move to the next node
        head = head.next;
    }
}

// Main function
function main() {
    // Example linked list: 7 -&gt; 14 -&gt; 21 -&gt; 28
    let head = new Node(7);
    head.next = new Node(14);
    head.next.next = new Node(21);
    head.next.next.next = new Node(28);

    // Assigning random pointers
    head.random = head.next.next;
    head.next.random = head;
    head.next.next.random = head.next.next.next;
    head.next.next.next.random = head.next;

    console.log("Original Linked List with Random Pointers:");
    printClonedLinkedList(head);

    // Clone the linked list
    let clonedList = cloneLL(head);

    console.log("\nCloned Linked List with Random Pointers:");
    printClonedLinkedList(clonedList);
}

main();

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Original Linked List with Random Pointers:
                             Data: 7, Random: 21
                             Data: 14, Random: 7
                             Data: 21, Random: 28
                             Data: 28, Random: 14

                             Cloned Linked List with Random Pointers:
                             Data: 7, Random: 21
                             Data: 14, Random: 7
                             Data: 21, Random: 28
                             Data: 28, Random: 14</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(3N)</strong>where N is the number of nodes in the linked list. The algorithm makes three traversals of the linked list, once to create copies and insert them between original nodes, then to set the random pointers of the copied nodes to their appropriate copied nodes and then to separate the copied and original nodes.</p>
<p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the linked list as the only extra additional space allocated it to create the copied list without creating any other additional data structures.</p>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/q570bKdrnlw?si=CWydsZr5rjJ_g8Tf" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>