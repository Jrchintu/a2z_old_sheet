<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Detect a Cycle in a Linked List</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            /* line-height: 1.7; */
            color: #333;
            background-color: #fdfdfd;
            margin: 5px;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            border: 1px solid #e7e7e7;
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 5px;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Detect a Cycle in a Linked List</h1>
</header>
<article>
<!-- wp:html -->
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
Examples
</strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<p><strong>Example 1:</strong></p>
<p><strong>Input Format</strong>:</p>
<p>LL: 1 2 3 4 5</p>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13034" height="338" src="assets/7b77117212bc16f5cc1fcce4ce26170c.png" width="768"/></figure>
<p><strong>Result</strong>: True</p>
<p><strong>Explanation</strong>: The last node with the value of 5 has its 'next' pointer pointing back to a previous node with the value of 3. This has resulted in a loop, hence we return true.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input Format:</strong></p>
<p>LL: 1 2 3 4 9 9</p>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13035" height="201" src="assets/5e0f4a61bdbb007dd17113b8245bf7d1.jpg" width="768"/></figure>
<p><strong>Result: </strong>False</p>
<p><strong>Explanation</strong>: : In this example, the linked list does not have a loop hence returns false.</p>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/cycle-detection-in-a-singly-linked-list_628974?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/86dd2cadbd0e7ef71ad98d3b7f2f2efc.png"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out
yourself first. </em></p>
<!-- /wp:html -->
<!-- wp:html -->
<div class="horizontal_navbar_dsa_article">
<div class="grid_container_two">
<a class="two-boxes box-a" href="#brute-force-approach">
Brute Force Approach
</a>
<a class="two-boxes box-c" href="#optimal-approach">
Optimal Approach
</a>
<a class="three-boxes box-d" href="#dsa_article_video_explanation">
<svg fill="none" height="26" viewbox="0 0 20 14" width="26" xmlns="http://www.w3.org/2000/svg">
<path d="M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z" fill="red"></path>
</svg>
</a>
<div class="box-e tooltip">
<svg fill="none" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z" fill="black"></path>
</svg>
<div class="bottom">
<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,
closes all other expands. You can manually expand more than one approach at a time</p>
<i></i>
</div>
</div>
</div>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Brute Force Approach Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
Brute Force Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>A <strong>loop</strong> in a linked list occurs when there's a node that, <strong>when followed</strong>, <strong>brings you back</strong> to it, indicating a <strong>closed loop</strong> in the list.</p>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13102" height="434" src="assets/0c69e45b908c052bad76cab7a759f980.png" width="768"/></figure>
<p>Hence it's important to keep track of nodes that have already been visited so that loops can be detected. One common way to do this is by using hashing.</p>
<h3><strong>Algorithm:</strong></h3>
<p><strong>Step 1: Traverse</strong> through the LL using the traversal technique of assigning a <strong>temp</strong> node to the head and <strong>iterating</strong> by moving to the next element till we reach <strong>null</strong>.</p>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13103" height="310" src="assets/ded35acdc9c37a2a429c77f3b63e058c.png" width="768"/></figure>
<p><strong>Step 2: </strong>While traversing, keep a track of the visited nodes in the map data structure. </p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-13106" height="722" src="assets/42c9b4c9e03817f2f82ebbcf679d6d9a.png" width="515"/></figure>
<p><strong>Note: </strong>Storing the entire node in the map is essential to distinguish between nodes with <strong>identical values</strong> but <strong>different positions</strong> in the list. This ensures <strong>accurate loop detection</strong> and not just duplicate value checks.</p>
<p><strong>Step 3:</strong> If a <strong>previously</strong> <strong>visited</strong> <strong>node</strong> is encountered again, that proves that there is a <strong>loop</strong> in the linked list hence return <strong>true</strong>.</p>
<p><strong>Step 4:</strong> If the traversal is completed, and we reach the last point of the LL which is <strong>null</strong>, it means there was <strong>noloop</strong>, hence we return <strong>false</strong>.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

// Node class represents a
// node in a linked list
class Node {
public:
    // Data stored in the node
    int data;        
    
    // Pointer to the next node in the list
    Node* next;      

    // Constructor with both data 
    // and next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as
    // a parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// function to detect loop in linked list
bool detectLoop(Node* head) {
    
    // Initialize a pointer 'temp'
    // at the head of the linked list
    Node* temp = head;  
    
    // Create a map to keep track of
    // encountered nodes
    std::unordered_map&lt;Node*, int&gt; nodeMap;  

    // Step 2: Traverse the linked list
    while (temp != nullptr) {
        // If the node is already in the
        // map, there is a loop
        if (nodeMap.find(temp) != nodeMap.end()) {
            return true;
        }
        // Store the current node
        // in the map
        nodeMap[temp] = 1;
        
        // Move to the next node
        temp = temp-&gt;next;  
    }

    // Step 3: If the list is successfully traversed 
    // without a loop, return false
    return false;
}

int main() {
    // Create a sample linked list
    // with a loop for testing
    
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    head-&gt;next = second;
    second-&gt;next = third;
    third-&gt;next = fourth;
    fourth-&gt;next = fifth;
     // Create a loop
    fifth-&gt;next = third; 

    // Check if there is a loop 
    // n the linked list
    if (detectLoop(head)) {
        cout &lt;&lt; "Loop detected in the linked list." &lt;&lt; endl;
    } else {
        cout &lt;&lt; "No loop detected in the linked list." &lt;&lt; endl;
    }

    // Clean up memory (free the allocated nodes)
    delete head;
    delete second;
    delete third;
    delete fourth;
    delete fifth;

    return 0;
}

</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.HashMap;
import java.util.Map;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    public int data;   
    // Pointer to the next node in the list
    public Node next;  

    // Constructor with both data
    // and next node as parameters
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Main {
    // Function to detect a
    // loop in a linked list
    public static boolean detectLoop(Node head) {
        // Initialize a pointer 'temp'
        // at the head of the linked list
        Node temp = head;
        
        // Create a map to keep track
        // of encountered nodes
        Map&lt;Node, int&gt; nodeMap = new HashMap&lt;&gt;();

        // Step 2: Traverse the linked list
        while (temp != null) {
            // If the node is already in
            // the map, there is a loop
            if (nodeMap.containsKey(temp)) {
                return true;
            }
            // Store the current node in the map
            nodeMap.put(temp, 1);
            // Move to the next node
            temp = temp.next;
        }

        // Step 3: If the list is successfully
        // traversed without a loop, return false
        return false;
    }

    public static void main(String[] args) {
        // Create a sample linked list
        // with a loop for testing
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);
        Node fourth = new Node(4);
        Node fifth = new Node(5);

        head.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        // Create a loop
        fifth.next = third;

        // Check if there is a loop
        // in the linked list
        if (detectLoop(head)) {
            System.out.println("Loop detected in the linked list.");
        } else {
            System.out.println("No loop detected in the linked list.");
        }

        // No need to explicitly free memory
        // in Java; the garbage collector handles it
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
# Node class represents
# a node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to detect a loop 
# n a linked list
def detect_loop(head):
    # Initialize a pointer 'temp' at 
    # the head of the linked list
    temp = head

    # Create a set to keep track
    # of encountered nodes
    node_set = set()

    # Step 2: Traverse the linked list
    while temp is not None:
        # If the node is already
        # in the set, there is a loop
        if temp in node_set:
            return True

        # Store the current node in the set
        node_set.add(temp)

        # Move to the next node
        temp = temp.next

    # Step 3: If the list is successfully
    # traversed without a loop, return False
    return False

if __name__ == "__main__":
    # Create a sample linked list with
    # a loop for testing
    head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    fifth = Node(5)

    head.next = second
    second.next = third
    third.next = fourth
    fourth.next = fifth
    # Create a loop
    fifth.next = third

    # Check if there is a loop
    # in the linked list
    if detect_loop(head):
        print("Loop detected in the linked list.")
    else:
        print("No loop detected in the linked list.")

    # No need to explicitly free memory
    # in Python; memory management is automatic

</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
// Node class represents a
// node in a linked list
class Node {
    constructor(data, next) {
        // Data stored in the node
        this.data = data; 
        
        // Pointer to the next node in the list
        this.next = next;  
    }
}

// Function to detect a loop
// in a linked list
function detectLoop(head) {
    // Initialize a pointer 'temp'
    // at the head of the linked list
    let temp = head;

    // Create a map to keep track of encountered nodes
    const nodeMap = new Map();

    // Step 2: Traverse the linked list
    while (temp !== null) {
        // If the node is already in
        // the map, there is a loop
        if (nodeMap.has(temp)) {
            return true;
        }
        // Store the current node in the map
        nodeMap.set(temp, true);
        // Move to the next node
        temp = temp.next;
    }

    // Step 3: If the list is successfully
    // traversed without a loop, return false
    return false;
}

// Create a sample linked list
// with a loop for testing
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);
const fourth = new Node(4);
const fifth = new Node(5);

head.next = second;
second.next = third;
third.next = fourth;
fourth.next = fifth;
// Create a loop
fifth.next = third;

// Check if there is a loop in the linked list
if (detectLoop(head)) {
    console.log("Loop detected in the linked list.");
} else {
    console.log("No loop detected in the linked list.");
}

</code>
</pre>
</div>
<p>
<!-- Insert Output of Brute Force Here -->
<strong>Output:</strong> 
Loop detected in the linked list.

</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Brute Force Here -->
</p><p><strong>Time Complexity: O(N * 2 * log(N) )</strong>The algorithm traverses the linked list <strong>once</strong>, performing hashmap <strong>insertions</strong> and <strong>searches</strong> in the while loop for each node. The insertion and search operations in the unordered_map have a worst-case time complexity of <strong>O(log(N))</strong>. As the loop iterates through N nodes, the total time complexity is determined by the product of the traversal <strong>(O(N))</strong> and the average-case complexity of the <strong>hashmap operations (insert and search)</strong>, resulting in <strong>O(N * 2 * log(N)). </strong></p>
<p>Hashmaps and their time complexities are discussed in more detail <a href="https://takeuforward.org/hashing/hashing-maps-time-complexity-collisions-division-rule-of-hashing-strivers-a2z-dsa-course/" rel="noopener" target="_blank" title="">here</a>. </p>
<p><strong>Space Complexity: O(N) </strong>The code uses a <strong>hashmap</strong>/<strong>dictionary</strong> to store encountered nodes, which can take up to O(N) additional space, where 'n' is the number of nodes in the list. Hence, the <strong>spacecomplexity</strong> is O(N) due to the use of the map to track nodes.</p>
<p></p>
</details>
</div>
</details>
</div>
<!-- Brute Force Approach Ends here -->
<!-- Optimal Approach Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
Optimal Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm of Better Approach Here -->
<p>The previous method uses O(N) <strong>additional</strong> <strong>memory</strong>, which can become quite large as the <strong>linked</strong> <strong>list</strong> <strong>length</strong> <strong>grows</strong>. To enhance efficiency, the <strong>Tortoise</strong> and <strong>Hare</strong> <strong>Algorithm</strong> is introduced as an <strong>optimization</strong>.</p>
<p>The Tortoise and Hare approach has been discussed in this <a href="https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/" rel="noopener" target="_blank" title=""><strong>article</strong></a>. </p>
<p>When the <strong>tortoise</strong> and <strong>hare</strong> enter the loop, they may be at different positions within the loop due to the difference in their <strong>speeds</strong>. The hare is moving <strong>faster</strong>, so it will traverse a <strong>greater</strong> <strong>distance</strong> in the same amount of time.</p>
<p>If there is <strong>no loop</strong> in the linked list, the hare will eventually reach the <strong>end</strong>, and the algorithm will terminate without a meeting occurring.</p>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13107" height="334" src="assets/4c0e54befc83537342462e7f5b193ac2.png" width="768"/></figure>
<h3><strong>Algorithm</strong></h3>
<p><strong>Step 1:</strong> Initialise two pointers, <strong>`slow`</strong> and <strong>`fast`</strong>, to the head of the linked list. <strong>`slow`</strong> will advance <strong>one</strong> <strong>step</strong> at a time, while <strong>`fast`</strong> will advance <strong>two</strong> <strong>steps</strong> at a time. These pointers will move <strong>simultaneously</strong>.</p>
<p><strong>Step 2: </strong>Traverse the linked list with the <strong>`slow`</strong> and <strong>`fast`</strong> pointers. While traversing, repeatedly move <strong>`slow`</strong> <strong>one</strong> <strong>step</strong> and <strong>`fast`</strong> <strong>two</strong> <strong>steps</strong> at a time.</p>
<p><strong>Step 3: </strong>Continue this traversal until one of the following conditions is met:</p>
<ol><li><strong>`fast</strong>` or<strong> `fast.next`</strong> reaches the end of the linked list (i.e., becomes <strong>null</strong>). In this case, there is <strong>no loop</strong> in the linked list ie. the linked list is <strong>linear</strong>, and the algorithm terminates by returning <strong>false</strong>.<br/></li><li><strong>`fast`</strong> and <strong>`slow`</strong> pointers meet at the same node. This indicates the presence of a <strong>loop</strong> in the linked list, and the algorithm terminates by returning <strong>`true`</strong>.</li></ol>
<figure class="wp-block-image size-large is-resized"><img alt="" class="wp-image-13108" height="423" src="assets/4ac8a261d5f08fc73ab11ceacc7c3e86.png" width="768"/></figure>
<h3><strong>Intuition: </strong></h3>
<p>In a linked list with a loop, consider two pointers: one that moves one node at a time (<strong>slow</strong>) and another that moves two nodes at a time (<strong>fast</strong>). If we start moving these pointers with their defined speed they will surely enter the loop and might be at some distance <strong>'d'</strong> from each other within the loop.</p>
<p>The key insight here is the <strong>relative</strong> <strong>speed</strong> between these pointers. The fast pointer, moving at double the speed of the slow one, <strong>closes</strong> <strong>the</strong> <strong>gap</strong> between them by <strong>one</strong> <strong>node</strong> <strong>in</strong> <strong>every</strong> <strong>iteration</strong>. This means that with each step, the distance decreases by one node.</p>
<p>Imagine a race where one runner moves at <strong>twice</strong> the speed of another. The faster runner covers the ground faster and closes the gap, resulting in a reduction in the distance between them. Similarly, the <strong>fast</strong> pointer catches up to the <strong>slow</strong> pointer in the looped linked list, closing in the gap between them until it reaches zero.</p>
<h3><strong>Proof: </strong></h3>
<p>Let <strong>'d'</strong> denote the initial distance between the <strong>slow</strong> and <strong>fast</strong> pointers inside the loop. At each step, the fast pointer moves ahead by two nodes while the slow pointer advances by one node.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-13109" height="287" src="assets/29e2865d3f5028c134e00540d564ee8e.png" width="465"/></figure>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-13110" height="563" src="assets/eba24836d4d91d1a4b27d24318591256.png" width="482"/></figure>
<p>The <strong>relative</strong> <strong>speed</strong> between them causes the gap to decrease by one node in each iteration (fast gains two nodes while slow gains one node). This continuous reduction ensures that the difference between their positions <strong>decreases</strong> <strong>steadily</strong>. Mathematically, if the fast pointer <strong>gains ground</strong> twice as fast as the slow pointer, the difference in their positions reduces by one node after each step. Consequently, this reduction in the distance between them continues <strong>until</strong> the<strong> difference becomes zero</strong>.</p>
<p>Hence, the proof lies in this <strong>iterative</strong> <strong>process</strong> where the faster rate of the fast pointer leads to a continual decrease in the gap distance, ultimately resulting in their collision within the looped linked list.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt;

using namespace std;

// Node class represents a
// node in a linked list
class Node {
public:
    // Data stored in the node
    int data;        
    
    // Pointer to the next node in the list
    Node* next;      

    // Constructor with both data 
    // and next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as
    // a parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Function to detect a loop in a linked
// list using the Tortoise and Hare Algorithm
bool detectCycle(Node* head) {
    // Initialize two pointers, slow and fast,
    // to the head of the linked list
    Node* slow = head;
    Node* fast = head;

    // Step 2: Traverse the linked list with
    // the slow and fast pointers
    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {
        // Move slow one step
        slow = slow-&gt;next;
        // Move fast two steps
        fast = fast-&gt;next-&gt;next;

        // Check if slow and fast pointers meet
        if (slow == fast) {
            return true;  // Loop detected
        }
    }

    // If fast reaches the end of the list,
    // there is no loop
    return false;
}


int main() {
    // Create a sample linked list
    // with a loop for testing
    
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    Node* fourth = new Node(4);
    Node* fifth = new Node(5);

    head-&gt;next = second;
    second-&gt;next = third;
    third-&gt;next = fourth;
    fourth-&gt;next = fifth;
     // Create a loop
    fifth-&gt;next = third; 

    // Check if there is a loop 
    // n the linked list
    if (detectCycle(head)) {
        cout &lt;&lt; "Loop detected in the linked list." &lt;&lt; endl;
    } else {
        cout &lt;&lt; "No loop detected in the linked list." &lt;&lt; endl;
    }

    // Clean up memory (free the allocated nodes)
    delete head;
    delete second;
    delete third;
    delete fourth;
    delete fifth;

    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.HashMap;
import java.util.Map;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    public int data;   
    // Pointer to the next node in the list
    public Node next;  

    // Constructor with both data
    // and next node as parameters
    public Node(int data, Node next) {
        this.data = data;
        this.next = next;
    }

    // Constructor with only data as
    // a parameter, sets next to null
    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

public class Main {

    // Function to detect a loop in a linked list
    // using the Tortoise and Hare Algorithm
    public static boolean detectCycle(Node head) {
        // Initialize two pointers, slow and fast,
        // to the head of the linked list
        Node slow = head;
        Node fast = head;

        // Step 2: Traverse the linked list
        // with the slow and fast pointers
        while (fast != null &amp;&amp; fast.next != null) {
            // Move slow one step
            slow = slow.next;
            // Move fast two steps
            fast = fast.next.next;

            // Check if slow and fast pointers meet
            if (slow == fast) {
                return true;  // Loop detected
            }
        }

        // If fast reaches the end of the
        // list, there is no loop
        return false;
    }


    public static void main(String[] args) {
        // Create a sample linked list
        // with a loop for testing
        Node head = new Node(1);
        Node second = new Node(2);
        Node third = new Node(3);
        Node fourth = new Node(4);
        Node fifth = new Node(5);

        head.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        // Create a loop
        fifth.next = third;

        // Check if there is a loop
        // in the linked list
        if (detectCycle(head)) {
            System.out.println("Loop detected in the linked list.");
        } else {
            System.out.println("No loop detected in the linked list.");
        }

        // No need to explicitly free memory
        // in Java; the garbage collector handles it
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
# Node class represents
# a node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        self.data = data
        self.next = next_node

# Function to detect a loop in a
# linked list using the Tortoise and Hare Algorithm
def detect_cycle(head):
    # Initialize two pointers, slow and fast,
    # to the head of the linked list
    slow = head
    fast = head

    # Step 2: Traverse the linked list
    # with the slow and fast pointers
    while fast is not None and fast.next is not None:
        # Move slow one step
        slow = slow.next
        # Move fast two steps
        fast = fast.next.next

        # Check if slow and fast pointers meet
        if slow == fast:
            return True  # Loop detected

    # If fast reaches the end of the
    # list, there is no loop
    return False


if __name__ == "__main__":
    # Create a sample linked list with
    # a loop for testing
    head = Node(1)
    second = Node(2)
    third = Node(3)
    fourth = Node(4)
    fifth = Node(5)

    head.next = second
    second.next = third
    third.next = fourth
    fourth.next = fifth
    # Create a loop
    fifth.next = third

    # Check if there is a loop
    # in the linked list
    if detect_cycle(head):
        print("Loop detected in the linked list.")
    else:
        print("No loop detected in the linked list.")

    # No need to explicitly free memory
    # in Python; memory management is automatic
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
// Node class represents a
// node in a linked list
class Node {
    constructor(data, next) {
        // Data stored in the node
        this.data = data; 
        
        // Pointer to the next node in the list
        this.next = next;  
    }
}

// Function to detect a loop in a linked list
// using the Tortoise and Hare Algorithm
function detectCycle(head) {
    // Initialize two pointers, slow and fast,
    // to the head of the linked list
    let slow = head;
    let fast = head;

    // Step 2: Traverse the linked list
    // with the slow and fast pointers
    while (fast !== null &amp;&amp; fast.next !== null) {
        // Move slow one step
        slow = slow.next;
        // Move fast two steps
        fast = fast.next.next;

        // Check if slow and fast pointers meet
        if (slow === fast) {
            return true;  // Loop detected
        }
    }

    // If fast reaches the end of the list, there is no loop
    return false;
}


// Create a sample linked list
// with a loop for testing
const head = new Node(1);
const second = new Node(2);
const third = new Node(3);
const fourth = new Node(4);
const fifth = new Node(5);

head.next = second;
second.next = third;
third.next = fourth;
fourth.next = fifth;
// Create a loop
fifth.next = third;

// Check if there is a loop in the linked list
if (detectCycle(head)) {
    console.log("Loop detected in the linked list.");
} else {
    console.log("No loop detected in the linked list.");
}
</code>
</pre>
</div>
<p>
<!-- Insert Output of Optimal Apporach Here -->
<strong>Output:</strong> 
Loop detected in the linked list.

</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Optimal Approach-->
</p><p><strong>Time Complexity: O(N)</strong>, where N is the number of nodes in the linked list. This is because in the <strong>worst-case scenario</strong>, the <strong>fast</strong> pointer, which <strong>moves</strong> <strong>quicker</strong>, will either reach the end of the list (in case of no loop) or meet the <strong>slow</strong> pointer (in case of a loop) in a <strong>linear time</strong> relative to the length of the list.</p>
<p>The key insight into why this is <strong>O(N)</strong> and <strong>not something slower</strong> is that each step of the algorithm reduces the distance between the fast and slow pointers (when they are in the loop) by one. Therefore, the <strong>maximum</strong> <strong>number</strong> of <strong>steps</strong> needed for them to meet is <strong>proportional</strong> to the number of nodes in the list.</p>
<p><br/><strong>Space Complexity : O(1)</strong> The code uses only a <strong>constantamount</strong> of <strong>additionalspace</strong>, regardless of the linked list's length. This is achieved by using two pointers (<strong>slow</strong> and <strong>fast</strong>) to detect the loop without any significant extra memory usage, resulting in <strong>constantspace</strong> complexity, O(1).</p>
<p></p>
</details>
</div>
</details>
</div>
<!-- Optimal Approach Starts from here -->
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
Video Explanation
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" class="lazy-loaded" data-lazy-type="iframe" data-src="https://www.youtube.com/embed/wiOo4DC5GGA?si=2K96t4rt0tRlch5c" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/wiOo4DC5GGA?feature=oembed" title="Detect a loop in a Linked List" width="810"></iframe><noscript>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/wiOo4DC5GGA?si=2K96t4rt0tRlch5c" title="Detect a loop in a Linked List" width="810"></iframe></noscript>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<script>

const codeSections = document.querySelectorAll('.code-section');

// Get last selected language from localStorage or set default value
let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

// Update last selected language for all sections and store in localStorage
lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

// Handle copy button click event
copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

// Set initial state of the tabs
codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<script>
const codeSections = document.querySelectorAll('.code-section');

let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
<!-- /wp:html -->
<!-- wp:html -->
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<!-- /wp:html -->
<!-- wp:paragraph -->
<p>In case you are learning DSA, you should check out our free <a href="https://takeuforward.org/strivers-a2z-dsa-course/strivers-a2z-dsa-course-sheet-2/" rel="noopener" target="_blank" title="">A2Z DSA Course</a> with videos and blogs.</p>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to </em><strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268" rel="noreferrer noopener" target="_blank">Gauri Tomar</a></strong><em> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam</em>, <a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/" rel="noopener" target="_blank" title="">please check out this article</a></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>