<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Two Sum : Check if a pair with given sum exists in Array</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 0;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                /* margin: 5px; */
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Two Sum : Check if a pair with given sum exists in Array</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong> Given an array of integers arr[] and an integer target. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>1st variant: </strong>Return <strong>YES</strong> if there exist two numbers such that their sum is equal to the target. Otherwise, return <strong>NO.</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>2nd variant: </strong>Return indices of the two numbers such that their sum is equal to the target. Otherwise, we will return {-1, -1}.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note:</strong> You are not allowed to use the same element twice. Example: If the target is equal to 6 and num[1] = 3, then nums[1] + nums[1] = target is not a solution.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input Format:</strong> N = 5, arr[] = {2,6,5,8,11}, target = 14
<strong>Result:</strong> YES (for 1st variant)
       [1, 3] (for 2nd variant)
<strong>Explanation:</strong> arr[1] + arr[3] = 14. So, the answer is “YES” for the first variant and [1, 3] for 2nd variant.

<strong>Example 2:</strong>
<strong>Input Format:</strong> N = 5, arr[] = {2,6,5,8,11}, target = 15
<strong>Result:</strong> NO (for 1st variant)
	[-1, -1] (for 2nd variant)
<strong>Explanation:</strong> There exist no such two numbers whose sum is equal to the target.
</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><span class="has-inline-color has-vivid-red-color"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></span></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><a href="https://www.codingninjas.com/codestudio/problems/reading_6845742?utm_source=youtube&amp;utm_medium=affiliate&amp;utm_campaign=striver_Arrayproblems"><em>Problem Link</em></a><em>.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Naive Approach(Brute-force approach)</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Intuition: </strong>For each element of the given array, we will try to search for another element such that its sum is equal to the target. If such two numbers exist, we will return the indices or “YES” accordingly.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>First, we will use a loop(say i) to select the indices of the array one by one.</li><li>For every index i, we will traverse through the remaining array using another loop(say j) to find the other number such that the sum is equal to the target (i.e. <strong>arr[i] + arr[j] = target</strong>).</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Observation: </strong>In every iteration, if the inner loop starts from index 0, we will be checking the same pair of numbers multiple times. For example, in iteration 1, for i = 0, we will check for the pair arr[0] and arr[1]. Again in iteration 2, for i = 1, we will check arr[1] and arr[0]. So, to eliminate these same pairs, we will start the inner loop from i+1.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong> Given array, nums = [2,1,3,4], target = 4</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Using the naive approach, we first select one number and then find the second one.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>For index 0, element= 2,</strong><br/>Then, we iterate through indices 1 to 3 to check if target – x, i.e. 4 – 2 = 2 exists. 2 does not exist from index 1 to 3, we move to the next index.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>For index 1, element=1,</strong><br/>Then, we iterate through indices 2 to 3 to find if target – x, i.e. 4 – 1 = 3 exists. 3 exists at index 2, so we store the indices 1 and 2, break the loop, and return the indices.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code Variant 1</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

string twoSum(int n, vector&lt;int&gt; &amp;arr, int target) {
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[i] + arr[j] == target) return "YES";
        }
    }
    return "NO";
}

int main()
{
    int n = 5;
    vector&lt;int&gt; arr = {2, 6, 5, 8, 11};
    int target = 14;
    string ans = twoSum(n, arr, target);
    cout &lt;&lt; "This is the answer for variant 1: " &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N<sup>2</sup>), where N = size of the array.<br/><strong>Reason: </strong>There are two loops(i.e. nested) each running for approximately N times.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;

public class tUf {
    public static String twoSum(int n, int []arr, int target) {
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[i] + arr[j] == target) return "YES";
            }
        }
        return "NO";
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        String ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 1: " + ans);
    }

}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N<sup>2</sup>), where N = size of the array.<br/><strong>Reason: </strong>There are two loops(i.e. nested) each running for approximately N times.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code Variant 2</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; twoSum(int n, vector&lt;int&gt; &amp;arr, int target) {
    vector&lt;int&gt; ans;
    for (int i = 0; i &lt; n; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[i] + arr[j] == target) {
                ans.push_back(i);
                ans.push_back(j);
                return ans;
            }
        }
    }
    return { -1, -1};
}

int main()
{
    int n = 5;
    vector&lt;int&gt; arr = {2, 6, 5, 8, 11};
    int target = 14;
    vector&lt;int&gt; ans = twoSum(n, arr, target);
    cout &lt;&lt; "This is the answer for variant 2: [" &lt;&lt; ans[0] &lt;&lt; ", "
         &lt;&lt; ans[1] &lt;&lt; "]" &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 2: [1, 3]</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N<sup>2</sup>), where N = size of the array.<br/><strong>Reason: </strong>There are two loops(i.e. nested) each running for approximately N times.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;

public class Main {
    public static int[] twoSum(int n, int []arr, int target) {
        int[] ans = new int[2];
        ans[0] = ans[1] = -1;
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                if (arr[i] + arr[j] == target) {
                    ans[0] = i;
                    ans[1] = j;
                    return ans;
                }
            }
        }
        return ans;
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        int[] ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 2: [" + ans[0] + ", "
                           + ans[1] + "]");
    }

}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 2: [1, 3]</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N<sup>2</sup>), where N = size of the array.<br/><strong>Reason: </strong>There are two loops(i.e. nested) each running for approximately N times.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Better Approach(using Hashing)</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Intuition: </strong>Basically, in the previous approach we selected one element and then searched for the other one using a loop. Here instead of using a loop, we will use the HashMap to check if the other element i.e. target-(selected element) exists. Thus we can trim down the time complexity of the problem.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>And for the second variant, we will store the element along will its index in the HashMap. Thus we can easily retrieve the index of the other element i.e. target-(selected element) without iterating the array.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>We will select the element of the array one by one using a loop(say i).</li><li>Then we will check if the other required element(<em>i.e. </em><strong><em>target-arr[i]</em></strong>) exists in the hashMap.<ol><li>If <strong>that element exists</strong>, then we will return “YES” for the first variant or we will return the current index i.e. i, and the index of the element found using map i.e. mp[<strong><em>target-arr[i]</em></strong>].</li><li>If <strong>that element does not exist, </strong>then we will just store the current element in the hashMap along with its index. Because in the future, the current element might be a part of our answer.</li></ol></li><li>Finally, if we are out of the loop, that means there is no such pair whose sum is equal to the target. In this case, we will return either “NO” or {-1, -1} as per the variant of the question.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong> Given array, nums = [2,3,1,4], target = 4</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><em>Note:</em></strong><em> Here x denotes the currently selected element.</em></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">For index 0, x = 2, and currently map is empty.
We try to find if target – x = 4 – 2 = 2 is present in the map or not.
For now, 2 does not exist on the map.
And we store the index of element 2. i.e., mp[2] = 0,

For index 1, x = 3
We try to find if target – x = 4  – 3 = 1 is present in the map or not.
For now, 1 does not exist on the map.
And we store the index of element 3. i.e., mp[3] = 1,

For index 2, x = 1 
We try to find if target – i = 4  – 1 = 3 is present in the map or not. 3 exists in the map, so we store index 2 and the value stored for key 3 in the map and break the loop. And return [1,2].</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><strong>Code for Variant 1</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

string twoSum(int n, vector&lt;int&gt; &amp;arr, int target) {
    unordered_map&lt;int, int&gt; mpp;
    for (int i = 0; i &lt; n; i++) {
        int num = arr[i];
        int moreNeeded = target - num;
        if (mpp.find(moreNeeded) != mpp.end()) {
            return "YES";
        }
        mpp[num] = i;
    }
    return "NO";
}

int main()
{
    int n = 5;
    vector&lt;int&gt; arr = {2, 6, 5, 8, 11};
    int target = 14;
    string ans = twoSum(n, arr, target);
    cout &lt;&lt; "This is the answer for variant 1: " &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N), where N = size of the array.<br/><strong>Reason: </strong>The loop runs N times in the worst case and searching in a hashmap takes O(1) generally. So the time complexity is O(N). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>In the worst case(which rarely happens), the unordered_map takes <strong>O(N)</strong> to find an element. In that case, the time complexity will be <strong>O(N</strong><strong><sup>2</sup></strong><strong>)</strong>. If we use map instead of unordered_map, the time complexity will be <strong>O(N* logN)</strong> as the map data structure takes logN time to find an element.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(N) as we use the map data structure.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>We have optimized this problem enough. But if in the interview, we are not allowed to use the map data structure, then we should move on to the following approach i.e. two pointer approach. This approach will have the same time complexity as the better approach.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">import java.util.*;

public class tUf {
    public static String twoSum(int n, int []arr, int target) {
        HashMap&lt;Integer, Integer&gt; mpp = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            int num = arr[i];
            int moreNeeded = target - num;
            if (mpp.containsKey(moreNeeded)) {
                return "YES";
            }

            mpp.put(arr[i], i);
        }
        return "NO";
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        String ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 1: " + ans);
    }

}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N), where N = size of the array.<br/><strong>Reason: </strong>The loop runs N times in the worst case and searching in a hashmap takes O(1) generally. So the time complexity is O(N).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>In the worst case(which rarely happens), the unordered_map takes <strong>O(N)</strong> to find an element. In that case, the time complexity will be <strong>O(N</strong><strong><sup>2</sup></strong><strong>)</strong>. If we use map instead of unordered_map, the time complexity will be <strong>O(N* logN)</strong> as the map data structure takes logN time to find an element.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(N) as we use the map data structure.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>We have optimized this problem enough. But if in the interview, we are not allowed to use the map data structure, then we should move on to the following approach i.e. two pointer approach. This approach will have the same time complexity as the better approach.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code for Variant 2</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

vector&lt;int&gt; twoSum(int n, vector&lt;int&gt; &amp;arr, int target) {
    unordered_map&lt;int, int&gt; mpp;
    for (int i = 0; i &lt; n; i++) {
        int num = arr[i];
        int moreNeeded = target - num;
        if (mpp.find(moreNeeded) != mpp.end()) {
            return {mpp[moreNeeded], i};
        }
        mpp[num] = i;
    }
    return { -1, -1};
}

int main()
{
    int n = 5;
    vector&lt;int&gt; arr = {2, 6, 5, 8, 11};
    int target = 14;
    vector&lt;int&gt; ans = twoSum(n, arr, target);
    cout &lt;&lt; "This is the answer for variant 2: [" &lt;&lt; ans[0] &lt;&lt; ", "
         &lt;&lt; ans[1] &lt;&lt; "]" &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 2: [1, 3]</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N), where N = size of the array.<br/><strong>Reason: </strong>The loop runs N times in the worst case and searching in a hashmap takes O(1) generally. So the time complexity is O(N).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>In the worst case(which rarely happens), the unordered_map takes <strong>O(N)</strong> to find an element. In that case, the time complexity will be <strong>O(N</strong><strong><sup>2</sup></strong><strong>)</strong>. If we use map instead of unordered_map, the time complexity will be <strong>O(N* logN)</strong> as the map data structure takes logN time to find an element.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(N) as we use the map data structure.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>We have optimized this problem enough. But if in the interview, we are not allowed to use the map data structure, then we should move on to the following approach i.e. two pointer approach. This approach will have the same time complexity as the better approach.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;

public class tUf {
    public static int[] twoSum(int n, int []arr, int target) {
        int[] ans = new int[2];
        ans[0] = ans[1] = -1;
        HashMap&lt;Integer, Integer&gt; mpp = new HashMap&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            int num = arr[i];
            int moreNeeded = target - num;
            if (mpp.containsKey(moreNeeded)) {
                ans[0] = mpp.get(moreNeeded);
                ans[1] = i;
                return ans;
            }

            mpp.put(arr[i], i);
        }
        return ans;
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        int[] ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 2: [" + ans[0] + ", "
                           + ans[1] + "]");

    }

}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 2: [1, 3]</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N), where N = size of the array.<br/><strong>Reason: </strong>The loop runs N times in the worst case and searching in a hashmap takes O(1) generally. So the time complexity is O(N). </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>In the worst case(which rarely happens), the unordered_map takes <strong>O(N)</strong> to find an element. In that case, the time complexity will be <strong>O(N</strong><strong><sup>2</sup></strong><strong>)</strong>. If we use map instead of unordered_map, the time complexity will be <strong>O(N* logN)</strong> as the map data structure takes logN time to find an element.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(N) as we use the map data structure.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>We have optimized this problem enough. But if in the interview, we are not allowed to use the map data structure, then we should move on to the following approach i.e. two pointer approach. This approach will have the same time complexity as the better approach.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Optimized Approach(using two-pointer)</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Intuition: </strong>In this approach, we will first sort the array and will try to choose the numbers in a greedy way.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We will keep a left pointer at the first index and a right pointer at the last index. Now until <strong>left &lt; right, </strong>we will check the sum of arr[left] and arr[right]. Now if the <strong>sum &lt; target, </strong>we need bigger numbers and so we will increment the left pointer. But if <strong>sum &gt; target, </strong>we need to consider lesser numbers and so we will decrement the right pointer. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>If <strong>sum == target </strong>we will return either “YES” or the indices as per the question.<br/>But if the left crosses the right pointer, we will return “NO” or {-1, -1}.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The steps are the following:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>We will sort the given array first.</li><li>Now, we will take two pointers i.e. <strong>left</strong>, which points to the first index, and <strong>right</strong>, which points to the last index.</li><li>Now using a loop we will check the sum of arr[left] and arr[right] until <strong>left &lt; right</strong>.<ol><li>If arr[left] + arr[right] &gt; sum, we will decrement the right pointer.</li><li>If arr[left] + arr[right] &lt; sum, we will increment the left pointer.</li><li>If arr[left] + arr[right] == sum, we will return the result.</li></ol></li><li>Finally, if no results are found we will return “No” or {-1, -1}.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Dry Run:</strong> Given array, nums = [2,1,3,4], target = 4</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>First, we sort the array. So nums after sorting are [1,2,3,4]</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We take two-pointers, left and right. The left points to index 0 and the right points to index 3.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now we check if nums[left] + nums[right] == target. In this case, they don’t sum up, and nums[left] + nums[right] &gt; target so that we will reduce right by 1.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now, left = 0, right=2</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Here, nums[left] + nums[right] == 1 + 3 == 4, which is the required target, so we will return the result.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

string twoSum(int n, vector&lt;int&gt; &amp;arr, int target) {
    sort(arr.begin(), arr.end());
    int left = 0, right = n - 1;
    while (left &lt; right) {
        int sum = arr[left] + arr[right];
        if (sum == target) {
            return "YES";
        }
        else if (sum &lt; target) left++;
        else right--;
    }
    return "NO";
}

int main()
{
    int n = 5;
    vector&lt;int&gt; arr = {2, 6, 5, 8, 11};
    int target = 14;
    string ans = twoSum(n, arr, target);
    cout &lt;&lt; "This is the answer for variant 1: " &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>For variant 2, we can store the elements of the array along with its index in a new array. Then the rest of the code will be similar. And while returning, we need to return the stored indices instead of returning “YES”. But for this variant, the recommended approach is approach 2 i.e. hashing approach.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N) + O(N*logN), where N = size of the array.<br/><strong>Reason: </strong>The loop will run at most N times. And sorting the array will take N*logN time complexity.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>Here we are distorting the given array. So, if we need to consider this change, the space complexity will be O(N).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-python" lang="python">import java.util.*;

public class Main {
    public static String twoSum(int n, int []arr, int target) {
        Arrays.sort(arr);
        int left = 0, right = n - 1;
        while (left &lt; right) {
            int sum = arr[left] + arr[right];
            if (sum == target) {
                return "YES";
            } else if (sum &lt; target) left++;
            else right--;
        }
        return "NO";
    }

    public static void main(String args[]) {
        int n = 5;
        int[] arr = {2, 6, 5, 8, 11};
        int target = 14;
        String ans = twoSum(n, arr, target);
        System.out.println("This is the answer for variant 1: " + ans);

    }

} 
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong>This is the answer for variant 1: YES</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>For variant 2, we can store the elements of the array along with its index in a new array. Then the rest of the code will be similar. And while returning, we need to return the stored indices instead of returning “YES”. But for this variant, the recommended approach is approach 2 i.e. hashing approach.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(N) + O(N*logN), where N = size of the array.<br/><strong>Reason: </strong>The loop will run at most N times. And sorting the array will take N*logN time complexity.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(1) as we are not using any extra space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>Here we are distorting the given array. So, if we need to consider this change, the space complexity will be O(N).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <a data-id="https://www.linkedin.com/in/pranendu/" data-type="URL" href="https://www.linkedin.com/in/pranendu/" rel="noreferrer noopener" target="_blank"><strong>Pranendu Bikash Pradhan</strong></a> and  <em><a href="https://www.linkedin.com/in/imsudip/" rel="noopener" target="_blank" title=""><strong>Sudip Ghosh</strong></a></em></em> and <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noopener" target="_blank" title="">KRITIDIPTA GHOSH</a></strong> <em>for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/contribute/help-us-grow-takeuforward/">please check out this article</a><em>.</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>