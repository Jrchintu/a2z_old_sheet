<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Implement Trie - II</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1; /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs); /* 5px */
            padding: var(--spacing-sm); /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm); /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm); /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1em;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg); /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px; /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm); /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto; /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm); /* 10px */
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Implement Trie - II</h1>
</header>
<article>
<p><strong>Problem Statement: </strong>Implement a Trie data structure that supports the following methods:
<ol><li>Insert (word): To insert a string `word` in the Trie.</li><li>Count Words Equal To (word): Return the count of occurrences of the string word in the Trie.</li><li>Count Words Starting With (prefix): Return the count of words in the Trie that have the string “prefix” as a prefix.</li><li>Erase (word): Delete one occurrence of the string word from the Trie.</li></ol>
</p>
<p>Note:
<ol><li>The Erase(word) function is guaranteed to be called only when a word is present in the Trie.</li><li>Release the memory associated with variables using dynamic memory allocation at the end of your solution.</li></ol></p>
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
				<span><strong>Input:</strong></span>
				<span>Insert: ‘apple’, ‘apps’, ‘apxl’</span>
				<span>Count Number of Words Equal to: ‘apple’</span>
				<span>Count Number of Words Starting with: ‘app’, ‘ap’</span>
				<span>Erase word: ‘apxl’</span>
				
				<span><strong>Output: </strong></span>
				<span>Inserted ‘apple’, Inserted ‘apps’,Inserted, ‘apxl’.</span>
				<span>Number of Words Equal to ‘apple’: 1</span>
				<span>Number of Words Starting with ‘app’: 2 and ‘ap’: 3</span>
				<span>Erased ‘apxl’</span>
		
				<span><strong>Explanation: </strong>Insert Operations: “apple”, “apps” and “apxl” are inserted. </span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/5a868733f7d4298d971a4478086bcac5" width="439"/></figure>
				<span>Count Number of Words Equal to: ‘apple’</span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/6ed98b639a45856108ca9656266ce2a0" width="439"/></figure>
				<span>Count Number of Words Starting with: ‘app’, ‘ap’</span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/784d38599aa69b2b84bfa8ab8775c4d3" width="439"/></figure>
				<span>Erase word: ‘apxl’</span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/194b324bbaeb72571c2e6382c379d187" width="439"/></figure>
				
					
            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/trie-delete-operation_1062663?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
<!--<div class="problem-buttons">
         Add Problem Link inside href 
        <a href="" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp"
                alt="leetcode">
        </a>
    </div>-->
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out
        yourself first. </em></p>
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
                Optimal Approach 
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                        Algorithm / Intuition
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>The Trie data structure is used to efficiently store and retrieve a set of strings.</p>
<p>It organises strings such that common prefixes are shared among strings, making operations like searching for words with a given prefix efficient. Trie allows for quick retrieval of all strings with a given prefix, making it highly efficient for autocomplete and predictive text applications.</p>
<p>The prefix tree specifically uses counters to keep track of the number of words ending with the current node and how many words contain the current node letter. A classical Trie accomplished this using the boolean flag to indicate that a word ends at this node.</p>
<p>Each node in this Prefix Trie contains:
                   	<ol><li>An array of pointers to child nodes (26 slots, one for each lowercase English letter).</li><li>Counters for tracking the number of words that end at the node (‘cntEndWith’) and the number of words that have the node as a prefix (‘cntPrefix’).</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/049f3ad17dd4e9ac101ae4b704de0dd7" width="439"/></figure>
<h3>Algorithm 1: To Insert a Node in the Prefix Trie:</h3>
<p><strong>Step 1:</strong>Start at the root node.</p>
<p><strong>Step 2: </strong>Iterate over each character in the word. For each character:
                    <ol><li>Check if a child node corresponding to that character exists.</li><li>If not, create a new node for that character and link it to the current node.</li><li>Increment the prefix count for each node.</li></ol></p>
<p><strong>Step 3: </strong>
                    Finally, increment the end count for the last node of the word. </p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/5a868733f7d4298d971a4478086bcac5" width="439"/></figure>
<h3>Algorithm 2: To Count the Number of Words Equal to the Given Word in the Trie</h3>
<p><strong>Step 1:</strong>Start at the root node.</p>
<p><strong>Step 2: </strong>Iterate over each character in the word. For each character:
                    <ol><li>Traverse down the Trie following the characters of the word.</li><li>If any character is not found, return 0 (Indicating the word is not in the Trie).</li></ol></p>
<p><strong>Step 3: </strong>
                    Once all characters are found, return the end count of the node corresponding to the last character.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/6ed98b639a45856108ca9656266ce2a0" width="439"/></figure>
<h3>Algorithm 3: To Count the Number of Words Starting with the Given Word in the Trie:</h3>
<p><strong>Step 1:</strong>Start at the root node.</p>
<p><strong>Step 2: </strong>Iterate over each character in the word. For each character:
                    <ol><li>Traverse down the Trie following the characters of the word.</li><li>If any character is not found, return 0 (Indicating no words start with the given prefix).</li></ol></p>
<p><strong>Step 3: </strong>
                    Once all characters are found, return the prefix count of the node corresponding to the last character.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/784d38599aa69b2b84bfa8ab8775c4d3" width="439"/></figure>
<h3>Algorithm 4: To Erase the Given Word from the Trie</h3>
<p><strong>Step 1:</strong>Start at the root node.</p>
<p><strong>Step 2: </strong>Iterate over each character in the word. For each character traverse down the Trie following the characters of the word and at each node:
                    <ol><li>Decrement the prefix count.</li><li>It is given that the given word to erase will always be found in the Trie.</li></ol></p>
<p><strong>Step 3: </strong>
                    Once the end of the word is reached, decrement the end count.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/194b324bbaeb72571c2e6382c379d187" width="439"/></figure>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                        Code
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                            <code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt; 

using namespace std;

// Define a struct for
// each node in the trie
struct Node {
     // Array to store
     // links to child nodes
    Node* links[26];
     // Counter for number of
     // words that end at this node
    int cntEndWith = 0;
    // Counter for number of words
    // that have this node as a prefix
    int cntPrefix = 0; 

    // Function to check if the
    // node contains a specific key
    bool containsKey(char ch) {
        // Check if the link corresponding
        // to the character exists
        return (links[ch - 'a'] != NULL); 
    }

    // Function to get the child
    // node corresponding to a key
    Node* get(char ch) {
        // Return the link
        // corresponding to the character
        return links[ch - 'a']; 
    }

    // Function to insert a child
    // node with a specific key
    void put(char ch, Node* node) {
         // Set the link corresponding to
         // the character to the provided node
        links[ch - 'a'] = node;
    }

    // Function to increment the
    // count of words that end at this node
    void increaseEnd() {
        // Increment the counter
        cntEndWith++; 
    }

    // Function to increment the count of
    // words that have this node as a prefix
    void increasePrefix() {
         // Increment the counter
        cntPrefix++;
    }

    // Function to decrement the count
    // of words that end at this node
    void deleteEnd() {
        // Decrement the counter
        cntEndWith--; 
    }

    // Function to decrement the count of
    // words that have this node as a prefix
    void reducePrefix() {
        // Decrement the counter
        cntPrefix--; 
    }
};

// Define a class for the
// trie data structure
class Trie {
private:
    // Pointer to the
    // root node of the trie
    Node* root; 

public:
    // Constructor to initialize
    // the trie with an empty root node
    Trie() {
        // Create a new root node
        root = new Node(); 
    }

    // Function to insert
    // a word into the trie
    void insert(string word) {
        // Start from the root node
        Node* node = root; 
        // Iterate over each
        // character in the word
        for (int i = 0; i &lt; word.size(); i++) { 
             // If the character is
             // not already in the trie
            if (!node-&gt;containsKey(word[i])) {
                // Create a new node
                // for the character
                node-&gt;put(word[i], new Node()); 
            }
             // Move to the child node
             // corresponding to the character
            node = node-&gt;get(word[i]);
            // Increment the prefix
            // count for the node
            node-&gt;increasePrefix(); 
        }
        // Increment the end count
        // for the last node of the word
        node-&gt;increaseEnd(); 
    }

    // Function to count the number
    // of words equal to a given word
    int countWordsEqualTo(string word) {
         // Start from the root node
        Node* node = root;
        // Iterate over each character in the word
        for (int i = 0; i &lt; word.size(); i++) { 
            // If the character is found in the trie
            if (node-&gt;containsKey(word[i])) { 
                // Move to the child node
                // corresponding to the character
                node = node-&gt;get(word[i]); 
            } else {
                 // Return 0 if the
                 // character is not found
                return 0;
            }
        }
        // Return the count of
        // words ending at the node
        return node-&gt;cntEndWith; 
    }

    // Function to count the number of
    // words starting with a given prefix
    int countWordsStartingWith(string word) {
         // Start from the root node
        Node* node = root;
        // Iterate over each character in the prefix
        for (int i = 0; i &lt; word.size(); i++) { 
            // If the character is found in the trie
            if (node-&gt;containsKey(word[i])) { 
                // Move to the child node
                // corresponding to the character
                node = node-&gt;get(word[i]); 
            } else {
                // Return 0 if the
                // character is not found
                return 0; 
            }
        }
        // Return the count of
        // words with the prefix
        return node-&gt;cntPrefix; 
    }

    // Function to erase a
    // word from the trie
    void erase(string word) {
         // Start from the root node
        Node* node = root;
        // Iterate over each
        // character in the word
        for (int i = 0; i &lt; word.size(); i++) { 
            // If the character is
            // found in the trie
            if (node-&gt;containsKey(word[i])) { 
                 // Move to the child node
                 // corresponding to the character
                node = node-&gt;get(word[i]);
                // Decrement the prefix
                // count for the node
                node-&gt;reducePrefix(); 
            } else {
                // Return if the
                // character is not found
                return; 
            }
        }
        // Decrement the end count
        // for the last node of the word
        node-&gt;deleteEnd(); 
    }
};


int main() {
    Trie trie; 
    trie.insert("apple"); 
    trie.insert("app"); 
    cout &lt;&lt; "Inserting strings 'apple', 'app' into Trie"&lt;&lt; endl;
    cout &lt;&lt; "Count Words Equal to 'apple': ";
    cout &lt;&lt; trie.countWordsEqualTo("apple") &lt;&lt; endl; 
    cout &lt;&lt; "Count Words Starting With 'app': ";
    cout &lt;&lt; trie.countWordsStartingWith("app") &lt;&lt; endl; 
    cout &lt;&lt; "Erasing word 'app' from trie"&lt;&lt; endl;
    trie.erase("app"); 
    cout &lt;&lt; "Count Words Equal to 'apple': ";
    cout &lt;&lt; trie.countWordsEqualTo("apple") &lt;&lt; endl; 
    cout &lt;&lt; "Count Words Starting With 'apple': ";
    cout &lt;&lt; trie.countWordsStartingWith("app") &lt;&lt; endl; 
    return 0; 
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                            <code class="language-java" lang="java">
// Define a class for the trie data structure
class Trie {
    // Define a struct for
    // each node in the trie
    static class Node {
        // Array to store
        // links to child nodes
        Node[] links;
        // Counter for number of
        // words that end at this node
        int cntEndWith;
        // Counter for number of words
        // that have this node as a prefix
        int cntPrefix;

        // Constructor for Node
        Node() {
            links = new Node[26];
            cntEndWith = 0;
            cntPrefix = 0;
        }

        // Function to check if the
        // node contains a specific key
        boolean containsKey(char ch) {
            // Check if the link corresponding
            // to the character exists
            return links[ch - 'a'] != null;
        }

        // Function to get the child
        // node corresponding to a key
        Node get(char ch) {
            // Return the link
            // corresponding to the character
            return links[ch - 'a'];
        }

        // Function to insert a child
        // node with a specific key
        void put(char ch, Node node) {
            // Set the link corresponding to
            // the character to the provided node
            links[ch - 'a'] = node;
        }

        // Function to increment the
        // count of words that end at this node
        void increaseEnd() {
            // Increment the counter
            cntEndWith++;
        }

        // Function to increment the count of
        // words that have this node as a prefix
        void increasePrefix() {
            // Increment the counter
            cntPrefix++;
        }

        // Function to decrement the count
        // of words that end at this node
        void deleteEnd() {
            // Decrement the counter
            cntEndWith--;
        }

        // Function to decrement the count of
        // words that have this node as a prefix
        void reducePrefix() {
            // Decrement the counter
            cntPrefix--;
        }
    }

    // Pointer to the
    // root node of the trie
    private Node root;

    // Constructor to initialize
    // the trie with an empty root node
    Trie() {
        // Create a new root node
        root = new Node();
    }

    // Function to insert
    // a word into the trie
    void insert(String word) {
        // Start from the root node
        Node node = root;
        // Iterate over each
        // character in the word
        for (int i = 0; i &lt; word.length(); i++) {
            // If the character is
            // not already in the trie
            if (!node.containsKey(word.charAt(i))) {
                // Create a new node
                // for the character
                node.put(word.charAt(i), new Node());
            }
            // Move to the child node
            // corresponding to the character
            node = node.get(word.charAt(i));
            // Increment the prefix
            // count for the node
            node.increasePrefix();
        }
        // Increment the end count
        // for the last node of the word
        node.increaseEnd();
    }

    // Function to count the number
    // of words equal to a given word
    int countWordsEqualTo(String word) {
        // Start from the root node
        Node node = root;
        // Iterate over each character in the word
        for (int i = 0; i &lt; word.length(); i++) {
            // If the character is found in the trie
            if (node.containsKey(word.charAt(i))) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word.charAt(i));
            } else {
                // Return 0 if the
                // character is not found
                return 0;
            }
        }
        // Return the count of
        // words ending at the node
        return node.cntEndWith;
    }

    // Function to count the number of
    // words starting with a given prefix
    int countWordsStartingWith(String word) {
        // Start from the root node
        Node node = root;
        // Iterate over each character in the prefix
        for (int i = 0; i &lt; word.length(); i++) {
            // If the character is found in the trie
            if (node.containsKey(word.charAt(i))) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word.charAt(i));
            } else {
                // Return 0 if the
                // character is not found
                return 0;
            }
        }
        // Return the count of
        // words with the prefix
        return node.cntPrefix;
    }

    // Function to erase a
    // word from the trie
    void erase(String word) {
        // Start from the root node
        Node node = root;
        // Iterate over each
        // character in the word
        for (int i = 0; i &lt; word.length(); i++) {
            // If the character is
            // found in the trie
            if (node.containsKey(word.charAt(i))) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word.charAt(i));
                // Decrement the prefix
                // count for the node
                node.reducePrefix();
            } else {
                // Return if the
                // character is not found
                return;
            }
        }
        // Decrement the end count
        // for the last node of the word
        node.deleteEnd();
    }
}

public class Main {
    public static void main(String[] args) {
        Trie trie = new Trie();
        trie.insert("apple");
        trie.insert("app");
        System.out.println("Inserting strings 'apple', 'app' into Trie");
        System.out.print("Count Words Equal to 'apple': ");
        System.out.println(trie.countWordsEqualTo("apple"));
        System.out.print("Count Words Starting With 'app': ");
        System.out.println(trie.countWordsStartingWith("app"));
        System.out.println("Erasing word 'app' from trie");
        trie.erase("app");
        System.out.print("Count Words Equal to 'apple': ");
        System.out.println(trie.countWordsEqualTo("apple"));
        System.out.print("Count Words Starting With 'apple': ");
        System.out.println(trie.countWordsStartingWith("app"));
    }
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                            <code class="language-python" lang="python">
class Node:
    """
    Define a class for each node in the trie.
    """

    def __init__(self):
        # Array to store links
        # to child nodes
        self.links = [None] * 26
        # Counter for number of words
        # that end at this node
        self.cntEndWith = 0
        # Counter for number of words that
        # have this node as a prefix
        self.cntPrefix = 0

    def contains_key(self, ch):
        """
        Function to check if the
        node contains a specific key.
        """
        # Check if the link corresponding
        # to the character exists
        return self.links[ord(ch) - ord('a')] is not None

    def get(self, ch):
        """
        Function to get the child node
        corresponding to a key.
        """
        # Return the link corresponding
        # to the character
        return self.links[ord(ch) - ord('a')]

    def put(self, ch, node):
        """
        Function to insert a child node
        with a specific key.
        """
        # Set the link corresponding to
        # the character to the provided node
        self.links[ord(ch) - ord('a')] = node

    def increase_end(self):
        """
        Function to increment the count
        of words that end at this node.
        """
        # Increment the counter
        self.cntEndWith += 1

    def increase_prefix(self):
        """
        Function to increment the count of
        words that have this node as a prefix.
        """
        # Increment the counter
        self.cntPrefix += 1

    def delete_end(self):
        """
        Function to decrement the count of
        words that end at this node.
        """
        # Decrement the counter
        self.cntEndWith -= 1

    def reduce_prefix(self):
        """
        Function to decrement the count of 
        words that have this node as a prefix.
        """
        # Decrement the counter
        self.cntPrefix -= 1


class Trie:
    """
    Define a class for the
    trie data structure.
    """

    def __init__(self):
        """
        Constructor to initialize the
        trie with an empty root node.
        """
        # Create a new root node
        self.root = Node()

    def insert(self, word):
        """
        Function to insert a
        word into the trie.
        """
        # Start from the root node
        node = self.root
        
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is not
            # already in the trie
            
            if not node.contains_key(ch):
            
                # Create a new node
                # for the character
                node.put(ch, Node())
           
            # Move to the child node
            # corresponding to the character
            
            node = node.get(ch)
            # Increment the prefix
            # count for the node
            node.increase_prefix()
        # Increment the end count
        # for the last node of the word
        node.increase_end()

    def count_words_equal_to(self, word):
        """
        Function to count the number
        of words equal to a given word.
        """
        # Start from the
        # root node
        node = self.root
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
            else:
                # Return 0 if the
                # character is not found
                return 0
        # Return the count of
        # words ending at the node
        return node.cntEndWith

    def count_words_starting_with(self, word):
        """
        Function to count the number of
        words starting with a given prefix.
        """
        # Start from the root node
        node = self.root
        # Iterate over each
        # character in the prefix
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
            else:
                # Return 0 if the
                # character is not found
                return 0
        # Return the count of
        # words with the prefix
        return node.cntPrefix

    def erase(self, word):
        """
        Function to erase
        a word from the trie.
        """
        # Start from the root node
        node = self.root
        # Iterate over each
        # character in the word
        for ch in word:
            # If the character is
            # found in the trie
            if node.contains_key(ch):
                # Move to the child node
                # corresponding to the character
                node = node.get(ch)
                # Decrement the prefix
                # count for the node
                node.reduce_prefix()
            else:
                # Return if the
                # character is not found
                return
        # Decrement the end count
        # for the last node of the word
        node.delete_end()


if __name__ == "__main__":
    trie = Trie()
    trie.insert("apple")
    trie.insert("app")
    print("Inserting strings 'apple', 'app' into Trie")
    print("Count Words Equal to 'apple':", trie.count_words_equal_to("apple"))
    print("Count Words Starting With 'app':", trie.count_words_starting_with("app"))
    print("Erasing word 'app' from trie")
    trie.erase("app")
    print("Count Words Equal to 'apple':", trie.count_words_equal_to("apple"))
    print("Count Words Starting With 'apple':", trie.count_words_starting_with("app"))
                           </code>
                        </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Define a class for the
// trie data structure
class Node {
    // Define a struct for
    // each node in the trie
    constructor() {
        // Array to store
        // links to child nodes
        this.links = new Array(26).fill(null);
        // Counter for number of
        // words that end at this node
        this.cntEndWith = 0;
        // Counter for number of words
        // that have this node as a prefix
        this.cntPrefix = 0;
    }

    // Function to check if the
    // node contains a specific key
    containsKey(ch) {
        // Check if the link corresponding
        // to the character exists
        return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] !== null;
    }

    // Function to get the child
    // node corresponding to a key
    get(ch) {
        // Return the link 
        // orresponding to the character
        return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)];
    }

    // Function to insert a
    // child node with a specific key
    put(ch, node) {
        // Set the link corresponding
        // to the character to the provided node
        this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] = node;
    }

    // Function to increment the count
    // of words that end at this node
    increaseEnd() {
        // Increment the counter
        this.cntEndWith++;
    }

    // Function to increment the count
    // of words that have this node as a prefix
    increasePrefix() {
        // Increment the counter
        this.cntPrefix++;
    }

    // Function to decrement the count
    // of words that end at this node
    deleteEnd() {
        // Decrement the counter
        this.cntEndWith--;
    }

    // Function to decrement the count of
    // words that have this node as a prefix
    reducePrefix() {
        // Decrement the counter
        this.cntPrefix--;
    }
}

class Trie {
    // Constructor to initialize
    // the trie with an empty root node
    constructor() {
        // Create a new root node
        this.root = new Node();
    }

    // Function to insert
    // a word into the trie
    insert(word) {
        // Start from the root node
        let node = this.root;
        // Iterate over each
        // character in the word
        for (let i = 0; i &lt; word.length; i++) {
            // If the character
            // is not already in the trie
            if (!node.containsKey(word[i])) {
                // Create a new node
                // for the character
                node.put(word[i], new Node());
            }
            // Move to the child node
            // corresponding to the character
            node = node.get(word[i]);
            
            // Increment the prefix
            // count for the node
            node.increasePrefix();
        }
        // Increment the end count for
        // the last node of the word
        node.increaseEnd();
    }

    // Function to count the number
    // of words equal to a given word
    countWordsEqualTo(word) {
        // Start from the root node
        let node = this.root;
        // Iterate over each character in the word
        for (let i = 0; i &lt; word.length; i++) {
            // If the character is
            // found in the trie
            if (node.containsKey(word[i])) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word[i]);
            } else {
                // Return 0 if the
                // character is not found
                return 0;
            }
        }
        // Return the count of
        // words ending at the node
        return node.cntEndWith;
    }

    // Function to count the number of
    // words starting with a given prefix
    countWordsStartingWith(word) {
        // Start from the root node
        let node = this.root;
        // Iterate over each
        // character in the prefix
        for (let i = 0; i &lt; word.length; i++) {
            // If the character is
            // found in the trie
            if (node.containsKey(word[i])) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word[i]);
            } else {
                // Return 0 if the
                // character is not found
                return 0;
            }
        }
        // Return the count of
        // words with the prefix
        return node.cntPrefix;
    }

    // Function to erase
    // a word from the trie
    erase(word) {
        // Start from the root node
        let node = this.root;
        // Iterate over each character in the word
        for (let i = 0; i &lt; word.length; i++) {
            // If the character is
            // found in the trie
            if (node.containsKey(word[i])) {
                // Move to the child node
                // corresponding to the character
                node = node.get(word[i]);
                // Decrement the prefix
                // count for the node
                node.reducePrefix();
            } else {
                // Return if the
                // character is not found
                return;
            }
        }
        // Decrement the end count
        // for the last node of the word
        node.deleteEnd();
    }
}

// Main function
let trie = new Trie();
trie.insert("apple");
trie.insert("app");
console.log("Inserting strings 'apple', 'app' into Trie");
console.log("Count Words Equal to 'apple': ", trie.countWordsEqualTo("apple"));
console.log("Count Words Starting With 'app': ", trie.countWordsStartingWith("app"));
console.log("Erasing word 'app' from trie");
trie.erase("app");
console.log("Count Words Equal to 'apple': ", trie.countWordsEqualTo("apple"));
console.log("Count Words Starting With 'apple': ", trie.countWordsStartingWith("app"));
                            </code>
                        </pre>
</div>
<p>
<strong>Output</strong>
</p>
<p>Inserting strings 'apple', 'app' into Trie</p>
<p>Count Words Equal to 'apple': 1</p>
<p>Count Words Starting With 'app': 2</p>
<p>Erasing word 'app' from trie</p>
<p>Count Words Equal to 'apple': 1</p>
<p>Count Words Starting With 'apple': 1</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                        Complexity Analysis
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity  Here -->
<p><strong>Time Complexity: O(N)</strong>
                    where N is the length of the word or prefix being processed.
                    <ol><li>Each method (insertion, counting words equal to a given word, counting words starting with a prefix, and erasing a word) requires traversing the Trie for each character of the input word or prefix.</li><li>Therefore, the time complexity is linear with respect to the length of the word or prefix being processed.</li></ol></p>
<p><strong>Space Complexity: O(N)</strong>   
					where N is the total characters across all words inserted into the Trie. The space complexity is proportional to the number of unique words inserted into the Trie and the average length of those words.</p>
</p>
</details>
</div>
</details>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/K5pcpkEMCN0?si=9XQ6BYuvzG_8iNuc" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>
