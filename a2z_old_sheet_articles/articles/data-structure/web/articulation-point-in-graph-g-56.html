<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Articulation Point in Graph: G-56</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            /* line-height: 1.7; */
            color: #333;
            background-color: #fdfdfd;
            margin: 5px;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            /* margin: 5px; */
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                /* margin: 5px; */
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Articulation Point in Graph: G-56</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong> Given an undirected connected graph with V vertices and adjacency list adj. You are required to find all the vertices removing which (and edges through it) disconnect the graph into 2 or more components.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Note: Indexing is zero-based i.e nodes numbering from (0 to V-1). There might be loops present in the graph.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Pre-requisite: </strong><a href="https://www.youtube.com/watch?v=qrAub5z8FeA&amp;list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&amp;index=55" rel="noopener" target="_blank" title=""><strong>Bridges in Graph</strong></a> problem &amp; <a href="https://takeuforward.org/data-structure/depth-first-search-dfs/" rel="noopener" target="_blank" title=""><strong>DFS algorithm</strong></a>.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Example 1</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<pre>
<b>Input Format:</b>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7145" src="assets/48f9cb44111a919cc4e706e9210470c5.png"/></figure>
<b>Result:</b> {0, 2}
<b>Explanation:</b> If we remove node 0 or node 2, the graph will be divided into 2 or more components.
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7146" src="assets/a256f34e3f822ecbcf39312918ad4d5c.png"/></figure>
</pre>
<!-- /wp:html -->
<!-- wp:paragraph -->
<p><strong>Example 2</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<pre>
<b>Input Format:</b>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7147" src="assets/6123e982fc007ef6e15132a2f49fda71.png"/></figure>
<b>Result:</b> {1, 4}
<b>Explanation:</b> If we remove either node 1 or node 4, the graph breaks into multiple components.
</pre>
<!-- /wp:html -->
<!-- wp:heading {"level":3} -->
<h3><strong>Solution</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph {"textColor":"accent"} -->
<p class="has-accent-color has-text-color"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><a href="https://practice.geeksforgeeks.org/problems/articulation-point-1/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=articulation-point" rel="noopener" target="_blank" title=""><em>Problem Link</em></a><em>.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Before moving on to the solution, we need to understand the definition of the articulation point of a graph.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Articulation Point:</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>Articulation Points of a graph are the nodes on whose removal, the graph breaks into multiple components. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Example:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7148,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7148" src="assets/55493c6e7dc018a685b8ff7fb0bb35e0.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>For the above graph node 0 and node, 2 are the articulation points. If we remove either of the two nodes, the graph breaks into multiple components like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7149,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7149" src="assets/c18ea5b628a6cf760e5d934b37e50f2e.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>But node 3 is not an articulation point as this node’s removal does not break the graph into multiple components. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>In order to find all the articulation points of a graph, we will implement some logic over the DFS algorithm. This is more of an algorithm-based approach. So, let’s discuss the algorithm in detail. Before that, we will discuss the two important concepts of the algorithm i.e. <strong><em>time of insertion and lowest time of insertion.</em></strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li><strong>Time of insertion: </strong>Dring the DFS call, the time when a node is visited, is called its time of insertion. For example, if in the above graph, we start DFS from node 0 it will visit node 1 first then node 2, node 3, and so on. So, the time of insertion for node 0 will be 1, node 1 will be 2, node 2 will be 3 and it will continue like this. <strong><em>We will use a time array to store the insertion time for each node</em></strong>.<br/>This definition remains the same as it was during the bridge problem.<br/></li><li><strong>Lowest time of insertion: </strong>In this case, the current node refers to all its adjacent nodes <strong><em>except the parent and the visited nodes </em></strong>and takes the minimum lowest time of insertion into account. To store this entity for each node, we will use another ‘<strong><em>low</em></strong>’ array.<br/><strong><em>The difference in finding the lowest time of insertion in this problem is that in the bridgealgorithm, we only excluded the parent node but in this algorithm, we are excluding the visited nodes along with the parent node.</em></strong></li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong><em>The logical modification of the DFS algorithm is discussed below</em></strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>To find out the bridges in the bridge problem, we checked inside the DFS, if there exists any alternative path from the adjacent node to the current node.<br/>But here we cannot do so as in this case, we are trying to remove the current node along with all the edges linked to it. For that reason, here we will check if there exists any path from the adjacent node to the previous node of the current node. <strong><em>In addition to that</em></strong>, we must ensure that the current node we are trying to remove must not be the starting node. </p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">The check conditions for this case will change like the following:<br/>if(low[it] &gt; tin[node])  converts to if(low[it] &gt;= tin[node] &amp;&amp; parent  != -1) </pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p>For the starting node, we will apply different logic.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>The logic for the starting node:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>If the node is a starting point we will check the number of children of the node. If the starting node has more than 1 child(The children must not be connected), it will definitely be one of the articulation points.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>To find the number of children, we will generally count the number of adjacent nodes. But there is a point to notice. In the following graph, the starting node 0 has two adjacent nodes, but it is not an articulation point.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7150,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7150" src="assets/59589ef5fd574f9b013b72c7d28d3389.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>To avoid this edge case, we will increment the number of children only if the adjacent node is not previously visited(<em>i.e. child++ will be inside the not visited if statement</em>).</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>We can get a single node as an articulation point multiple times:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>If we carefully observe, we can easily notice that we can get a single node as the articulation point multiple times. For example, consider the following graph:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7151,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7151" src="assets/a90d12af72c37da972b6f8ca4134db4f.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>While checking for node 2, we will get the node as the articulation point once for the first component that contains nodes 4, 5, and 6 and we will again get the same node 2 for the second component that includes the nodes 7, 8, and 9.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><em>To avoid the storing of duplicate nodes, we will store the nodes in a hash array(i.e. mark array used in the code) instead of directly inserting them in a simple array.</em></strong></p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Approach</strong>: </h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>First, we need to create the adjacency list for the given graph from the edge information(<strong><em>If not already given</em></strong>). And we will declare a variable timer(either globally or we can carry it while calling DFS), that will keep track of the time of insertion for each node. The timer may be initialized to 0 or 1 accordingly.</li><li>Then we will perform DFS for each component. For each component, the starting node will carry -1 as its parent.<ol><li>Inside DFS, we will first mark the node visited and then store the time of insertion and the lowest time of insertion properly. We will declare a child variable to implement the logic for starting node.</li><li>Now, it’s time to visit the adjacent nodes. <ol><li><strong><em>If the adjacent node is the parent itself</em></strong>, we will just continue to the next node.</li><li><strong><em>If the adjacent node is not visited</em></strong>, we will call DFS for the adjacent node with the current node as the parent.<br/>After the DFS gets completed, we will compare the lowest time of insertion of the current node and the adjacent node and take the minimum.<br/>Now, we will check if the lowest time of insertion of the adjacent node is greater or equal to the time of insertion of the current node and also ensure that the current node is not the starting node(checking parent not equal -1).<br/>If the condition matches, then we will mark the current node in our hash array as one of our answers as it is one of the articulation points of the graph.<br/>Then we will increment the child variable by 1.</li><li><strong><em>If the adjacent node is visited</em></strong>, we will just compare the lowest time of insertion of the current node and the time of insertion of the adjacent node and take the minimum.</li></ol></li><li>Finally, we will check if the child value is greater than 1 and if the current node is the starting node. If it is then we will keep the starting node marked in our hash array as the starting node is also an articulation point in this case.</li></ol></li><li>Finally, our answer array will store all the bridges.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>We are not considering the parent and the visited nodes during calculating the lowest insertion time as they may be the articulation points of the graph which means they may be the nodes we intend to remove.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

//User function Template for C++

class Solution {
private:
    int timer = 1;
    void dfs(int node, int parent, vector&lt;int&gt; &amp;vis, int tin[], int low[],
             vector&lt;int&gt; &amp;mark, vector&lt;int&gt;adj[]) {
        vis[node] = 1;
        tin[node] = low[node] = timer;
        timer++;
        int child = 0;
        for (auto it : adj[node]) {
            if (it == parent) continue;
            if (!vis[it]) {
                dfs(it, node, vis, tin, low, mark, adj);
                low[node] = min(low[node], low[it]);
                if (low[it] &gt;= tin[node] &amp;&amp; parent != -1) {
                    mark[node] = 1;
                }
                child++;
            }
            else {
                low[node] = min(low[node], tin[it]);
            }
        }
        if (child &gt; 1 &amp;&amp; parent == -1) {
            mark[node] = 1;
        }
    }
public:
    vector&lt;int&gt; articulationPoints(int n, vector&lt;int&gt;adj[]) {
        vector&lt;int&gt; vis(n, 0);
        int tin[n];
        int low[n];
        vector&lt;int&gt; mark(n, 0);
        for (int i = 0; i &lt; n; i++) {
            if (!vis[i]) {
                dfs(i, -1, vis, tin, low, mark, adj);
            }
        }
        vector&lt;int&gt; ans;
        for (int i = 0; i &lt; n; i++) {
            if (mark[i] == 1) {
                ans.push_back(i);
            }
        }
        if (ans.size() == 0) return { -1};
        return ans;
    }
};
int main() {

    int n = 5;
    vector&lt;vector&lt;int&gt;&gt; edges = {
        {0, 1}, {1, 4},
        {2, 4}, {2, 3}, {3, 4}
    };

    vector&lt;int&gt; adj[n];
    for (auto it : edges) {
        int u = it[0], v = it[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    Solution obj;
    vector&lt;int&gt; nodes = obj.articulationPoints(n, adj);
    for (auto node : nodes) {
        cout &lt;&lt; node &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: 1 4 (Example 2)</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(V+2E), where V = no. of vertices, E = no. of edges. It is because the algorithm is just a simple DFS traversal.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(3V), where V = no. of vertices. O(3V) is for the three arrays i.e. tin, low, and vis, each of size V.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.io.*;
import java.util.*;



class Solution {
    private int timer = 1;
    private void dfs(int node, int parent, int[] vis,
                     int tin[], int low[], int[] mark,
                     ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {
        vis[node] = 1;
        tin[node] = low[node] = timer;
        timer++;
        int child = 0;
        for (Integer it : adj.get(node)) {
            if (it == parent) continue;
            if (vis[it] == 0) {
                dfs(it, node, vis, tin, low, mark, adj);
                low[node] = Math.min(low[node], low[it]);
                // node --- it
                if (low[it] &gt;= tin[node] &amp;&amp; parent != -1) {
                    mark[node] = 1;
                }
                child++;
            } else {
                low[node] = Math.min(low[node], tin[it]);
            }
        }
        if (child &gt; 1 &amp;&amp; parent == -1) {
            mark[node] = 1;
        }
    }
    //Function to return Breadth First Traversal of given graph.
    public ArrayList&lt;Integer&gt; articulationPoints(int n,
            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {
        int[] vis = new int[n];
        int[] tin = new int[n];
        int[] low = new int[n];
        int[] mark = new int[n];
        for (int i = 0; i &lt; n; i++) {
            if (vis[i] == 0) {
                dfs(i, -1, vis, tin, low, mark, adj);
            }
        }
        ArrayList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            if (mark[i] == 1) {
                ans.add(i);
            }
        }
        if (ans.size() == 0) {
            ans.add(-1);
        }
        return ans;
    }
}

class Main {
    public static void main (String[] args) {
        int n = 5;
        int[][] edges = {
            {0, 1}, {1, 4},
            {2, 4}, {2, 3}, {3, 4}
        };
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adj.add(new ArrayList&lt;Integer&gt;());
        }
        for (int i = 0; i &lt; n; i++) {
            int u = edges[i][0], v = edges[i][1];
            adj.get(u).add(v);
            adj.get(v).add(u);
        }

        Solution obj = new Solution();
        ArrayList&lt;Integer&gt; nodes = obj.articulationPoints(n, adj);

        int size = nodes.size();
        for (int i = 0; i &lt; size; i++) {
            int node = nodes.get(i);
            System.out.print(node + " ");
        }
        System.out.println("");
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: 1 4 (Example 2)</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(V+2E), where V = no. of vertices, E = no. of edges. It is because the algorithm is just a simple DFS traversal.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(3V), where V = no. of vertices. O(3V) is for the three arrays i.e. tin, low, and vis, each of size V.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noreferrer noopener" target="_blank"><strong>KRITIDIPTA GHOSH</strong></a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>