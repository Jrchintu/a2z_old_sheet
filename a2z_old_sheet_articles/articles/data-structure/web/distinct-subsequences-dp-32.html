<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Distinct Subsequences| (DP-32)</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* Practice */
        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: 20px auto;
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Distinct Subsequences| (DP-32)</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong>Â Distinct Subsequences</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Problem Link: </strong><a href="https://www.youtube.com/redirect?event=video_description&amp;redir_token=QUFFLUhqbmxyQ3hISUZ6X1pTc0hNZGc1UmJOX2o2SXptUXxBQ3Jtc0tuSy13bVhSRlNjZDcxNXcycDQ2R3VXay1vYUh6RXlSXzk3Z2IzNTc1dHVOVGZVR1NLLWV5MW1VdzhjdFNuelJ5cFVmYk9La2puUjA2SzBZSkZVV3E2eUlGWUlQRHZtT2l4cExyR1AteS1yLWtQMlZxOA&amp;q=https%3A%2F%2Fbit.ly%2F3nZNxy7" rel="noreferrer noopener nofollow" target="_blank"><strong>Subsequence Counting</strong></a></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>We are given two strings S1 and S2, we want to know how many distinct subsequences of S2 are present in S1.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
Examples
</strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted"><!-- Insert New Examples Here -->
<pre class="wp-block-preformatted"><strong>Example:</strong>

<img height="304" src="assets/5bd0449a4b74d76fc401d4abc0699958" width="458"/>
</pre>
</pre>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/subsequence-counting_3755256?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/86dd2cadbd0e7ef71ad98d3b7f2f2efc.png"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Donâ€™t jump directly to the solution, try it out
yourself first. </em></p>
<!-- /wp:html -->
<!-- wp:html -->
<div class="horizontal_navbar_dsa_article">
<div class="grid_container_three">
<a class="three-boxes box-a" href="#brute-force-approach">
Memoization approach
</a>
<a class="three-boxes box-b" href="#better-approach">
Tabulation approach
</a>
<a class="three-boxes box-c" href="#optimal-approach">
Space Optimization
</a>
<a class="three-boxes box-d" href="#dsa_article_video_explanation">
<svg fill="none" height="26" viewbox="0 0 20 14" width="26" xmlns="http://www.w3.org/2000/svg">
<path d="M8 10L13.19 7L8 4V10ZM19.56 2.17C19.69 2.64 19.78 3.27 19.84 4.07C19.91 4.87 19.94 5.56 19.94 6.16L20 7C20 9.19 19.84 10.8 19.56 11.83C19.31 12.73 18.73 13.31 17.83 13.56C17.36 13.69 16.5 13.78 15.18 13.84C13.88 13.91 12.69 13.94 11.59 13.94L10 14C5.81 14 3.2 13.84 2.17 13.56C1.27 13.31 0.69 12.73 0.44 11.83C0.31 11.36 0.22 10.73 0.16 9.93C0.0900001 9.13 0.0599999 8.44 0.0599999 7.84L0 7C0 4.81 0.16 3.2 0.44 2.17C0.69 1.27 1.27 0.69 2.17 0.44C2.64 0.31 3.5 0.22 4.82 0.16C6.12 0.0899998 7.31 0.0599999 8.41 0.0599999L10 0C14.19 0 16.8 0.16 17.83 0.44C18.73 0.69 19.31 1.27 19.56 2.17Z" fill="red"></path>
</svg>
</a>
<div class="box-e tooltip">
<svg fill="none" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.842 9.25L11.9577 10.17C11.2502 10.89 10.8081 11.5 10.8081 13H8.84297V12.5C8.84297 11.39 9.28511 10.39 9.99255 9.67L11.2109 8.41C11.5745 8.05 11.7906 7.55 11.7906 7C11.7906 6.46957 11.5836 5.96086 11.2151 5.58579C10.8465 5.21071 10.3467 5 9.82552 5C9.30434 5 8.80451 5.21071 8.43598 5.58579C8.06745 5.96086 7.86041 6.46957 7.86041 7H5.89531C5.89531 5.93913 6.30938 4.92172 7.04644 4.17157C7.7835 3.42143 8.78316 3 9.82552 3C10.8679 3 11.8675 3.42143 12.6046 4.17157C13.3417 4.92172 13.7557 5.93913 13.7557 7C13.7543 7.84324 13.4259 8.65183 12.842 9.25ZM10.8081 17H8.84297V15H10.8081M9.82552 0C8.53521 0 7.25754 0.258658 6.06545 0.761205C4.87337 1.26375 3.79021 2.00035 2.87783 2.92893C1.03519 4.8043 0 7.34784 0 10C0 12.6522 1.03519 15.1957 2.87783 17.0711C3.79021 17.9997 4.87337 18.7362 6.06545 19.2388C7.25754 19.7413 8.53521 20 9.82552 20C12.4314 20 14.9306 18.9464 16.7732 17.0711C18.6158 15.1957 19.651 12.6522 19.651 10C19.651 4.47 15.2296 0 9.82552 0Z" fill="black"></path>
</svg>
<div class="bottom">
<p>Expand any one approach by clicking the given options in the bar. Clicking one approach on bar,
closes all other expands. You can manually expand more than one approach at a time</p>
<i></i>
</div>
</div>
</div>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Brute Force Approach Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
Memoization Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>We have to find distinct subsequences of S2 in S1. As there is no uniformity in data, there is no other way to find out than to <strong>try out all possible ways</strong>. To do so we will need to use <strong>recursion</strong>.</p>
<p><strong>Steps to form the recursive solution:Â </strong></p>
<p>We will first form the recursive solution by the three points mentioned in the <a href="https://takeuforward.org/data-structure/dynamic-programming-introduction/" rel="noreferrer noopener" target="_blank">Dynamic Programming Introduction</a>.Â </p>
<p><strong>Step 1: </strong>Express the problem in terms of indexes.</p>
<p>We are given two strings. We can represent them with the help of two indexes i and j. Initially, i=n-1 and j=m-1, where n and m are lengths of strings S1 and S2. Initially, we will call f(n-1,j-1), which means the count of all subsequences of string S2[0â€¦m-1] in string S1[0â€¦n-1]. We can generalize it as follows:</p>
<p><img height="87" src="assets/78d76806c4a561f3d525f339c5ff150b" width="579"/></p>
<p><strong>Step 2: </strong>Try out all possible choices at a given index.</p>
<p>Now, i and j represent two characters from strings S1 and S2 respectively. We want to find distinct subsequences. There are only two options that make sense: either the characters represented by i and j match or they donâ€™t.</p>
<p><strong>Case 1: When the characters match</strong></p>
<p><strong>if(S1[i]==S2[j])</strong>, letâ€™s understand it with the following example:</p>
<p><img height="186" src="assets/92840df025cf06310120b7bed8a7d27c" width="182"/></p>
<p>S1[i] == S2[j], now as the characters at i and j match, we would want to check the possibility of the remaining characters of S2 in S1 therefore we reduce the length of both the strings by 1 and call the function recursively.</p>
<p><img height="439" src="assets/01ef59b5a70768a791d4f6a8c1caa76a" width="526"/></p>
<p>Now, if we only make the above single recursive call, we are rejecting the opportunities to find more than one subsequences because it can happen that the jth character may match with more characters in S1[0â€¦i-1], for example where there are more occurrences of â€˜gâ€™ in S1 from which also an answer needs to be explored.</p>
<p><img height="281" src="assets/aaa64824294e53093484891a947983fc" width="527"/></p>
<p>To explore all such possibilities, we make another recursive call in which we reduce the length of the S1 string by 1 but keep the S2 string the same, i.e we call f(i-1,j).</p>
<p><img height="433" src="assets/e1d6cce1c51201949e77caaf5de76071" width="527"/></p>
<p><strong>Case 2: When the characters donâ€™t match</strong></p>
<p><strong>if(S1[i] != S2[j]), </strong>it means that we donâ€™t have any other choice than to try the next character of S1 and match it with the current character S2.</p>
<p><img height="594" src="assets/21cef56472f3a632213854f09bbced70" width="257"/></p>
<p>This can be summarized as :</p>
<ul><li><strong>if(S1[i]==S2[j]), </strong>call f(i-1,j-1) and f(i-1,j).</li><li><strong>if(S1[i]!=S2[j]), </strong>call f(i-1,j).</li></ul>
<p><strong>Step 3:Â  Return the sum of choicesÂ </strong></p>
<p>As we have to return the total count, we will return the <strong>sum</strong> of f(i-1,j-1) and f(i-1,j) in case 1 and simply return f(i-1,j) in case 2.Â </p>
<p><strong>Base Cases:</strong></p>
<p>We are reducing i and j in our recursive relation, there can be two possibilities, either i becomes -1 or j becomes -1.</p>
<ul><li>if j&lt;0, it means we have matched all characters of S2 with characters of S1, so we return 1.</li><li>if i&lt;0, it means we have checked all characters of S1 but we are not able to match all characters of S2, therefore we return 0.</li></ul>
<p>The final pseudocode after steps 1, 2, and 3:</p>
<p><img height="521" src="assets/ce05b94e73238d77d1770e089dd876c1" width="481"/></p>
<p><strong>Steps to memoize a recursive solution:</strong></p>
<p>If we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:</p>
<ol><li>Create a dp array of size [n][m]. The size of S1 and S2 are n and m respectively, so the variable i will always lie between â€˜0â€™ and â€˜n-1â€™ and the variable j between â€˜0â€™ and â€˜m-1â€™.</li><li>We initialize the dp array to -1.</li><li>Whenever we want to find the answer to particular parameters (say f(i,j)), we first check whether the answer is already calculated using the dp array(i.e dp[i][j]!= -1 ). If yes, simply return the value from the dp array.</li><li>If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[i][j] to the solution we get.</li></ol>
<!-- /wp:list -->
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int prime = 1e9 + 7;

// Function to count the number of distinct subsequences of s2 in s1
int countUtil(string s1, string s2, int ind1, int ind2, vector&lt;vector&lt;int&gt;&gt;&amp; dp) {
    // If s2 has been completely matched, return 1 (found a valid subsequence)
    if (ind2 &lt; 0)
        return 1;
    
    // If s1 has been completely traversed but s2 hasn't, return 0
    if (ind1 &lt; 0)
        return 0;

    // If the result for this state has already been calculated, return it
    if (dp[ind1][ind2] != -1)
        return dp[ind1][ind2];

    int result = 0;

    // If the characters match, consider two options: either leave one character in s1 and s2
    // or leave one character in s1 and continue matching s2
    if (s1[ind1] == s2[ind2]) {
        int leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
        int stay = countUtil(s1, s2, ind1 - 1, ind2, dp);

        result = (leaveOne + stay) % prime;
    } else {
        // If characters don't match, just leave one character in s1 and continue matching s2
        result = countUtil(s1, s2, ind1 - 1, ind2, dp);
    }

    // Store the result and return it
    dp[ind1][ind2] = result;
    return result;
}

// Function to count the number of distinct subsequences of s2 in s1
int subsequenceCounting(string &amp;s1, string &amp;s2, int lt, int ls) {
    vector&lt;vector&lt;int&gt;&gt; dp(lt, vector&lt;int&gt;(ls, -1));
    return countUtil(s1, s2, lt - 1, ls - 1, dp);
}

int main() {
    string s1 = "babgbag";
    string s2 = "bag";

    // Call the subsequenceCounting function and print the result
    cout &lt;&lt; "The Count of Distinct Subsequences is " &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());
    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
    static int prime = (int) (Math.pow(10, 9) + 7);

    // Function to count the number of distinct subsequences of s1 that are equal to s2
    static int countUtil(String s1, String s2, int ind1, int ind2, int[][] dp) {
        // If we have exhausted s2, there's one valid subsequence (empty string) in s1.
        if (ind2 &lt; 0)
            return 1;
        // If we have exhausted s1 but not s2, there are no valid subsequences.
        if (ind1 &lt; 0)
            return 0;

        // If the result is already computed, return it.
        if (dp[ind1][ind2] != -1)
            return dp[ind1][ind2];

        // If the characters at the current positions match, we can either leave one character from s1
        // or continue to the next character in s1 while staying at the same character in s2.
        if (s1.charAt(ind1) == s2.charAt(ind2)) {
            int leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
            int stay = countUtil(s1, s2, ind1 - 1, ind2, dp);

            // Add the two possibilities and take modulo prime to avoid integer overflow.
            return dp[ind1][ind2] = (leaveOne + stay) % prime;
        } else {
            // If the characters don't match, we can only continue to the next character in s1.
            return dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp);
        }
    }

    // Function to calculate the count of distinct subsequences of s1 equal to s2
    static int subsequenceCounting(String s1, String s2, int lt, int ls) {
        // Initialize a DP array to store intermediate results
        int dp[][] = new int[lt][ls];
        for (int rows[] : dp)
            Arrays.fill(rows, -1);

        // Call the recursive helper function to compute the count
        return countUtil(s1, s2, lt - 1, ls - 1, dp);
    }

    public static void main(String args[]) {
        String s1 = "babgbag";
        String s2 = "bag";

        System.out.println("The Count of Distinct Subsequences is " +
                subsequenceCounting(s1, s2, s1.length(), s2.length()));
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
prime = int(1e9 + 7)

# Recursive function to count distinct subsequences of s1 that match s2
def countUtil(s1, s2, ind1, ind2, dp):
    # If we have exhausted s2, we found a valid subsequence
    if ind2 &lt; 0:
        return 1
    # If we have exhausted s1, but not s2, no valid subsequence found
    if ind1 &lt; 0:
        return 0
    
    # If this subproblem has already been solved, return the cached result
    if dp[ind1][ind2] != -1:
        return dp[ind1][ind2]
    
    # If the current characters match, we can either choose to leave one character
    # or stay with the current character in s1
    if s1[ind1] == s2[ind2]:
        leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp)
        stay = countUtil(s1, s2, ind1 - 1, ind2, dp)
        
        # Store the result in the DP table and return it modulo prime
        dp[ind1][ind2] = (leaveOne + stay) % prime
        return dp[ind1][ind2]
    else:
        # If the characters don't match, we can only skip the character in s1
        dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp)
        return dp[ind1][ind2]
    
# Main function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, lt, ls):
    # Initialize a DP table to store intermediate results
    dp = [[-1 for j in range(ls)] for i in range(lt)]
    
    # Call the recursive function to count distinct subsequences
    return countUtil(s1, s2, lt - 1, ls - 1, dp)

def main():
    s1 = "babgbag"
    s2 = "bag"

    # Calculate and print the count of distinct subsequences
    print("The Count of Distinct Subsequences is", subsequenceCounting(s1, s2, len(s1), len(s2)))

if __name__ == "__main__":
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
const prime = 1e9 + 7;

// Function to count the distinct subsequences
function countUtil(s1, s2, ind1, ind2, dp) {
    // If ind2 goes below 0, we have found a valid subsequence
    if (ind2 &lt; 0) {
        return 1;
    }
    // If ind1 goes below 0, there are no more characters in s1 to form a subsequence
    if (ind1 &lt; 0) {
        return 0;
    }

    // Check if the result for the current indices is already calculated
    if (dp[ind1][ind2] !== -1) {
        return dp[ind1][ind2];
    }

    // If the characters at ind1 in s1 and ind2 in s2 match
    if (s1[ind1] === s2[ind2]) {
        // We have two choices: either leave one character in s1 and s2 and continue searching,
        // or leave one character in s1 and s2 and one character in s1, but we need to add them modulo prime
        const leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
        const stay = countUtil(s1, s2, ind1 - 1, ind2, dp);

        // Store the result in dp and return
        return (dp[ind1][ind2] = (leaveOne + stay) % prime);
    } else {
        // If the characters do not match, we can only leave one character in s1 and continue searching
        return (dp[ind1][ind2] = countUtil(s1, s2, ind1 - 1, ind2, dp));
    }
}

// Function to count the distinct subsequences
function subsequenceCounting(s1, s2) {
    const lt = s1.length;
    const ls = s2.length;

    // Create a 2D array to store dynamic programming values
    const dp = new Array(lt).fill(null).map(() =&gt; new Array(ls).fill(-1));

    // Start the counting process from the end of both strings
    return countUtil(s1, s2, lt - 1, ls - 1, dp);
}

// Main function
function main() {
    const s1 = "babgbag";
    const s2 = "bag";

    // Call the subsequenceCounting function and print the result
    console.log("The Count of Distinct Subsequences is " + subsequenceCounting(s1, s2));
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Brute Force Here -->
<p><strong>Output:</strong> The Count of Distinct Subsequences is 5


</p>
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Brute Force Here -->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are N*M states therefore at max â€˜N*Mâ€™ new problems will be solved.</p>
<p><strong>Space Complexity: O(N*M) + O(N+M)</strong></p>
<p>Reason: We are using a recursion stack space(O(N+M)) and a 2D array ( O(N*M)).</p>
</p>
</details>
</div>
</details>
</div>
<!-- Brute Force Approach Ends here -->
<!-- Better Approach Starts from here -->
<div id="better-approach">
<details>
<summary class="main-summary">
<span>
Tabulation Approach
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition For Better Approach Here -->
<p>In the recursive logic, we set the base case too if(i&lt;0 ) and if(j&lt;0) but we canâ€™t set the dp arrayâ€™s index to -1. Therefore a hack for this issue is to shift every index by 1 towards the right.</p>
<p><img height="109" src="assets/b1c14695d48ec15548b780a4e06df703" width="454"/></p>
<ul><li>First we initialize the dp array of size [n+1][m+1] as zero.</li><li>Next, we set the base condition (keep in mind 1-based indexing), we set the first columnâ€™s value as 1 and the first row as 1.</li><li>Similarly, we will implement the recursive code by keeping in mind the shifting of indexes, therefore S1[i] will be converted to S1[i-1]. Same for S2.</li><li>At last, we will print dp[N][M] as our answer.</li></ul>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int prime = 1e9 + 7;

// Function to count the number of distinct subsequences of s2 in s1
int subsequenceCounting(string &amp;s1, string &amp;s2, int n, int m) {
    // Create a 2D DP array to store the count of distinct subsequences
    vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, 0));

    // Initialize the first row: empty string s2 can be matched with any non-empty s1 in one way
    for (int i = 0; i &lt;= n; i++) {
        dp[i][0] = 1;
    }

    // Initialize the first column: s1 can't match any non-empty s2
    for (int i = 1; i &lt;= m; i++) {
        dp[0][i] = 0;
    }

    // Fill in the DP array
    for (int i = 1; i &lt;= n; i++) {
        for (int j = 1; j &lt;= m; j++) {
            if (s1[i - 1] == s2[j - 1]) {
                // If the characters match, we have two options:
                // 1. Match the current characters and move diagonally (dp[i-1][j-1])
                // 2. Leave the current character in s1 and match s2 with the previous characters (dp[i-1][j])
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;
            } else {
                // If the characters don't match, we can only leave the current character in s1
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    // The value at dp[n][m] contains the count of distinct subsequences
    return dp[n][m];
}

int main() {
    string s1 = "babgbag";
    string s2 = "bag";

    // Call the subsequenceCounting function and print the result
    cout &lt;&lt; "The Count of Distinct Subsequences is " &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());
    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
    static int prime = (int) (Math.pow(10, 9) + 7);

    // Function to calculate the count of distinct subsequences of s1 equal to s2
    static int subsequenceCounting(String s1, String s2, int n, int m) {
        // Create a 2D array to store the counts of subsequences
        int dp[][] = new int[n + 1][m + 1];

        // Initialize the first column with 1 because there's one empty subsequence in any string.
        for (int i = 0; i &lt; n + 1; i++) {
            dp[i][0] = 1;
        }

        // Initialize the first row (except dp[0][0]) with 0 because there's no way to form s2 from an empty string.
        for (int i = 1; i &lt; m + 1; i++) {
            dp[0][i] = 0;
        }

        // Fill the dp array using a bottom-up approach
        for (int i = 1; i &lt; n + 1; i++) {
            for (int j = 1; j &lt; m + 1; j++) {
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // If the characters match, we can either include this character in the subsequence
                    // or exclude it. So, we add the counts from both possibilities.
                    dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;
                } else {
                    // If the characters don't match, we can only exclude this character.
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }

        return dp[n][m];
    }

    public static void main(String args[]) {
        String s1 = "babgbag";
        String s2 = "bag";

        System.out.println("The Count of Distinct Subsequences is " +
                subsequenceCounting(s1, s2, s1.length(), s2.length()));
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
prime = int(1e9 + 7)

# Function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, n, m):
    # Initialize a DP table to store the count of distinct subsequences
    dp = [[0 for i in range(m + 1)] for j in range(n + 1)]

    # Base case: There is exactly one subsequence of an empty string s2 in s1
    for i in range(n + 1):
        dp[i][0] = 1

    # Initialize dp[0][i] to 0 for i &gt; 0 since an empty s1 cannot have a non-empty subsequence of s2
    for i in range(1, m + 1):
        dp[0][i] = 0

    # Fill in the DP table using dynamic programming
    for i in range(1, n + 1):
        for j in range(1, m + 1):
            # If the current characters match, we have two choices:
            # 1. Include the current character in both s1 and s2 (dp[i-1][j-1])
            # 2. Skip the current character in s1 (dp[i-1][j])
            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime if s1[i - 1] == s2[j - 1] else dp[i - 1][j]

    # The final value in dp[n][m] is the count of distinct subsequences
    return dp[n][m]

def main():
    s1 = "babgbag"
    s2 = "bag"
    
    # Calculate and print the count of distinct subsequences
    print("The Count of Distinct Subsequences is", subsequenceCounting(s1, s2, len(s1), len(s2)))

if __name__ == "__main__":
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
const prime = 1e9 + 7;

// Function to count the distinct subsequences
function subsequenceCounting(s1, s2, n, m) {
    // Create a 2D array to store dynamic programming values
    const dp = new Array(n + 1).fill(null).map(() =&gt; new Array(m + 1).fill(0));

    // Initialize the first column with 1 because there is exactly one way to form an empty subsequence
    for (let i = 0; i &lt;= n; i++) {
        dp[i][0] = 1;
    }

    // Initialize the first row with 0 because there is no way to form a non-empty subsequence from an empty string
    for (let i = 1; i &lt;= m; i++) {
        dp[0][i] = 0;
    }

    // Fill the dp array using dynamic programming
    for (let i = 1; i &lt;= n; i++) {
        for (let j = 1; j &lt;= m; j++) {
            if (s1[i - 1] === s2[j - 1]) {
                // If the characters match, we can either include the current character or exclude it
                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;
            } else {
                // If the characters do not match, we can only exclude the current character
                dp[i][j] = dp[i - 1][j];
            }
        }
    }

    // The result is stored in the bottom-right cell of the dp array
    return dp[n][m];
}

// Main function
function main() {
    const s1 = "babgbag";
    const s2 = "bag";

    // Call the subsequenceCounting function and print the result
    console.log("The Count of Distinct Subsequences is " + subsequenceCounting(s1, s2, s1.length, s2.length));
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Better Approach Here -->
<strong>Output:</strong> The Count of Distinct Subsequences is 5

</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Better Approach Here -->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are two nested loops</p>
<p><strong>Space Complexity: O(N*M)</strong></p>
<p>Reason: We are using an external array of size â€˜N*Mâ€™. Stack Space is eliminated.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Better Approach Ends from here -->
<!-- Optimal Approach Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
Space Optimization Approach 
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
Algorithm / Intuition
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm of Better Approach Here -->
<p>If we closely look the relation,</p>
<p><strong>dp[i][j] =Â  dp[i-1][j-1] + dp[i-1][j]Â  or dp[i][j] = dp[i-1][j]</strong></p>
<p>We see that to calculate a value of a cell of the dp array, we need only the previous row values (say prev). So, we donâ€™t need to store an entire array. Hence we can space optimize it.</p>
<p>We will be space-optimizing this solution using <strong>only one row.</strong></p>
<h3><strong>Intuition:</strong></h3>
<p>If we clearly see the values required:Â  dp[i-1][j-1] and dp[i-1][j], we can say that if we are at a column j, we will only require the values shown in the grey box from the previous row and other values will be from the cur row itself. So why do we need to store an entire array for it?</p>
<p><img height="280" src="assets/d72d14c804b7a0e995da2ff017a21b4e" width="624"/></p>
<p>If we need only two values from the prev row, there is no need to store an entire row. We can work a bit smarter.</p>
<p>We can use the cur row itself to store the required value in the following way:</p>
<ul><li>We take a single row â€˜prevâ€™.</li><li>We initialize it to the base condition.</li><li>Whenever we want to compute a value of the cell prev[j], we take the already existing value (prev[j] before new computation) and prev[j-1] (if required, in case of character match).</li><li>We perform the above step on all the indexes.</li><li>So we see how we can space optimize using a single row itself.</li></ul>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
Code
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">
#include &lt;bits/stdc++.h&gt;
using namespace std;

const int prime = 1e9 + 7;

// Function to count the number of distinct subsequences of s2 in s1
int subsequenceCounting(string &amp;s1, string &amp;s2, int n, int m) {
    // Create an array to store the count of distinct subsequences for each character in s2
    vector&lt;int&gt; prev(m + 1, 0);

    // Initialize the count for an empty string (base case)
    prev[0] = 1;

    // Iterate through s1 and s2 to calculate the counts
    for (int i = 1; i &lt;= n; i++) {
        for (int j = m; j &gt;= 1; j--) { // Iterate in reverse direction to avoid overwriting values prematurely
            if (s1[i - 1] == s2[j - 1]) {
                // If the characters match, we have two options:
                // 1. Match the current characters and add to the previous count (prev[j-1])
                // 2. Leave the current character in s1 and match s2 with the previous characters (prev[j])
                prev[j] = (prev[j - 1] + prev[j]) % prime;
            }
            // No need for an else statement since we can simply leave the previous count as is
        }
    }

    // The value at prev[m] contains the count of distinct subsequences
    return prev[m];
}

int main() {
    string s1 = "babgbag";
    string s2 = "bag";

    // Call the subsequenceCounting function and print the result
    cout &lt;&lt; "The Count of Distinct Subsequences is " &lt;&lt; subsequenceCounting(s1, s2, s1.size(), s2.size());
    return 0;
}
</code>
</pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code"><code class="language-java" lang="java">
import java.util.*;

class TUF {
    static int prime = (int) (Math.pow(10, 9) + 7);

    // Function to calculate the count of distinct subsequences of s1 equal to s2
    static int subsequenceCounting(String s1, String s2, int n, int m) {
        // Create an array to store the counts of subsequences
        int[] prev = new int[m + 1];

        // Initialize the first element to 1 because there's one empty subsequence in any string.
        prev[0] = 1;

        // Fill the prev array using a bottom-up approach
        for (int i = 1; i &lt; n + 1; i++) {
            for (int j = m; j &gt;= 1; j--) { // Reverse direction for updating

                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // If the characters match, we can either include this character in the subsequence
                    // or exclude it. So, we add the counts from both possibilities.
                    prev[j] = (prev[j - 1] + prev[j]) % prime;
                } else {
                    // If the characters don't match, we can only exclude this character.
                    prev[j] = prev[j]; // This statement is not necessary, as it doesn't change the value.
                }
            }
        }

        return prev[m];
    }

    public static void main(String args[]) {
        String s1 = "babgbag";
        String s2 = "bag";

        System.out.println("The Count of Distinct Subsequences is " +
                subsequenceCounting(s1, s2, s1.length(), s2.length()));
    }
}
</code>
</pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code"><code class="language-python" lang="python">
prime = int(1e9 + 7)

# Function to count distinct subsequences of s1 that match s2
def subsequenceCounting(s1, s2, n, m):
    # Initialize a list to store the previous row of the DP table
    prev = [0 for i in range(m + 1)]
    
    # Initialize the first element of prev to 1, as there's always one way to match an empty s2
    prev[0] = 1

    # Loop through s1 and s2 in reverse direction
    for i in range(1, n + 1):
        for j in range(m, 0, -1):
            # If the current characters match, update prev[j] based on previous values
            if s1[i - 1] == s2[j - 1]:
                prev[j] = (prev[j - 1] + prev[j]) % prime
            # If the characters don't match, keep prev[j] unchanged (omit this statement)
            else:
                prev[j] = prev[j]

    # The final value in prev[m] is the count of distinct subsequences
    return prev[m]

def main():
    s1 = "babgbag"
    s2 = "bag"
    
    # Calculate and print the count of distinct subsequences
    result = subsequenceCounting(s1, s2, len(s1), len(s2))
    print("The Count of Distinct Subsequences is", result)

if __name__ == '__main__':
    main()
</code>
</pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code"><code class="language-javascript" lang="javascript">
const prime = 1e9 + 7;

// Function to count the distinct subsequences
function subsequenceCounting(s1, s2, n, m) {
    // Create an array to store dynamic programming values
    const prev = new Array(m + 1).fill(0);

    // Initialize the first element with 1 because there is exactly one way to form an empty subsequence
    prev[0] = 1;

    for (let i = 1; i &lt;= n; i++) {
        for (let j = m; j &gt;= 1; j--) {
            // Reverse direction of iteration for optimization
            if (s1[i - 1] === s2[j - 1]) {
                // If the characters match, we can either include the current character or exclude it
                prev[j] = (prev[j - 1] + prev[j]) % prime;
            }
            // No need to update for characters that do not match since prev[j] remains the same
        }
    }

    // The result is stored in the last element of the prev array
    return prev[m];
}

// Main function
function main() {
    const s1 = "babgbag";
    const s2 = "bag";

    // Call the subsequenceCounting function and print the result
    console.log("The Count of Distinct Subsequences is " + subsequenceCounting(s1, s2, s1.length, s2.length));
}

// Call the main function to start the program
main();
</code>
</pre>
</div>
<p>
<!-- Insert Output of Optimal Apporach Here -->
<strong>Output:</strong>The Count of Distinct Subsequences is 5


</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
Complexity Analysis
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity of Optimal Approach-->
<p><strong>Time Complexity: O(N*M)</strong></p>
<p>Reason: There are two nested loops.</p>
<p><strong>Space Complexity: O(M)</strong></p>
<p>Reason: We are using an external array of size â€˜M+1â€™ to store only one row.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Optimal Approach Starts from here -->
</div>
<!-- /wp:html -->
<!-- wp:html -->
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
Video Explanation
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" class="lazy-loaded" data-lazy-type="iframe" data-src="https://www.youtube.com/embed/xElxAuBcvsU?si=5Vi-iYlZsGCbYf35" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/nVG7eTiD2bY?feature=oembed" title="Shortest Common Supersequence" width="810"></iframe><noscript>
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="456" loading="lazy" src="https://www.youtube.com/embed/xElxAuBcvsU?si=5Vi-iYlZsGCbYf35" title="Shortest Common Supersequence" width="810"></iframe></noscript>
</div>
</details>
</div>
<!-- /wp:html -->
<!-- wp:html -->
<script>

const codeSections = document.querySelectorAll('.code-section');

// Get last selected language from localStorage or set default value
let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

// Update last selected language for all sections and store in localStorage
lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

// Handle copy button click event
copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

// Set initial state of the tabs
codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<script>
const codeSections = document.querySelectorAll('.code-section');

let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp'; 

codeSections.forEach((section, sectionIndex) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');
const copyBtn = section.querySelector('.copy-btn');

codeTabs.forEach((tab) => {
tab.addEventListener('click', () => {
codeTabs.forEach((t) => {
t.classList.remove('dsa_article_code_active');
});
tab.classList.add('dsa_article_code_active');

const lang = tab.dataset.lang;
const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
codeBlocks.forEach((block) => {
if (block === activeBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});

lastSelectedLanguage = lang;
localStorage.setItem('lastSelectedLanguage', lang);
codeSections.forEach((otherSection, otherIndex) => {
if (otherIndex !== sectionIndex) {
const otherTabs = otherSection.querySelectorAll('.code-tab');
otherTabs.forEach((otherTab) => {
if (otherTab.dataset.lang === lang) {
otherTab.classList.add('dsa_article_code_active');
} else {
otherTab.classList.remove('dsa_article_code_active');
}
});
const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
otherCodeBlocks.forEach((block) => {
if (block === otherActiveBlock) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
}
});
});
});

copyBtn.addEventListener('click', () => {
const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
navigator.clipboard.writeText(activeBlock.innerText);
copyBtn.classList.add('dsa_article_code_active');
setTimeout(() => {
copyBtn.classList.remove('dsa_article_code_active');
}, 1000);
});
});

codeSections.forEach((section) => {
const codeTabs = section.querySelectorAll('.code-tab');
const codeBlocks = section.querySelectorAll('.code-block');

codeTabs.forEach((tab) => {
if (tab.dataset.lang === lastSelectedLanguage) {
tab.classList.add('dsa_article_code_active');
} else {
tab.classList.remove('dsa_article_code_active');
}
});

codeBlocks.forEach((block) => {
if (block.dataset.lang === lastSelectedLanguage) {
block.classList.add('dsa_article_code_active');
} else {
block.classList.remove('dsa_article_code_active');
}
});
});
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
<!-- /wp:html -->
<!-- wp:html -->
<script src="https://takeuforward.org/UXApproachDropDowns/3ApproachJSScript.js"></script>
<!-- /wp:html -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks toÂ <strong><a href="https://www.linkedin.com/in/anshuman-sharma-a1b245194/" rel="noreferrer noopener" target="_blank">Anshuman Sharma</a></strong>Â for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,Â </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (active.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>