<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Vertical Order Traversal of Binary Tree</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            /* line-height: 1.7; */
            color: #333;
            background-color: #fdfdfd;
            margin: 5px;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                margin: 5px;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Vertical Order Traversal of Binary Tree</h1>
</header>
<article>
<p><strong>Problem Statement: </strong> Given a Binary Tree, return the Vertical Order Traversal of it starting from the Leftmost level to the Rightmost level. If there are multiple nodes passing through a vertical line, then they should be printed as they appear in level order traversal of the tree.

 
</p>
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
				<span><strong>Input:</strong>Binary Tree: 1 2 3 4 10 9 11 -1 5 -1 -1 -1 -1 -1 -1 -1 6
				</span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/148ffc0347de5524fbd3fa5e6d9d14df" width="439"/></figure>
				<span><strong>Output:</strong> Vertical Order Traversal: [[4],[2, 5], [1, 10, 9, 6],[3],[11]]</span>
				<span><strong>Explanation: </strong>Vertical Levels from left to right:
				<ol><li>Level -2: [4]</li><li>Level -1: [2]</li><li>Level 0: [1, 10, 9, 6] (Overlapping nodes are added in their level order sequence)</li><li>Level 1: [3]</li><li>Level 2: [11]</li></ol></span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/0351e1326a9b4ca375c94b62c0ac08f1" width="439"/></figure>
				<span><strong>Example 2:</strong></span>
				<span><strong>Input:</strong>Binary Tree: 2 7 5 2 6 -1 9 -1 -1 5 11 4 -1
				</span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/1638c327c3222c593a8499453239107e" width="439"/></figure>
				<span><strong>Output :</strong> [[2],[7, 5],[2, 6], [5, 11, 4],[9]]</span>
				<span><strong>Explanation: </strong>Vertical Levels from left to right:
				<ol><li>Level -2: [2]</li><li>Level -1: [7, 5]</li><li>Level 0: [2, 6]</li><li>Level 1: [5, 11, 4] (Overlapping nodes are added in their level order sequence)</li><li>Level 2: [9]</li></ol></span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/d214f6d557fac11e2f088563791d1a73" width="439"/></figure>
				
            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/vertical-order-traversal_3622711?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
<!--<div class="problem-buttons">
         Add Problem Link inside href 
        <a href="" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp"
                alt="leetcode">
        </a>
    </div>-->
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out
        yourself first. </em></p>
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
                Optimal Approach 
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                        Algorithm / Intuition
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>We can assign a vertical and level to every node. This will help us in categorising nodes based on their position in the binary tree.
                    <strong>Vertical Coordinates (x):</strong> The vertical coordinate, denoted as 'x', represents the vertical column in the tree. It essentially signifies the horizontal position of a node in relation to its parent. Nodes with the same 'x' value are aligned vertically, forming a column.
                    <strong>Level Coordinates (y):</strong> The level coordinate, denoted as 'y', represents the depth or level of a node in the tree. It signifies the vertical position of a node within the hierarchy of levels. As we traverse down the tree, the 'y' value increases, indicating a deeper level.</p>
<p><figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/63b10b6b4d8dd7e005db57b9fbc94087" width="439"/></figure></p>
<p>We create a map that serves as our organisational structure. The map is based on the vertical and level information of each node. The vertical information, represented by 'x', signifies the vertical column, while the level information, denoted as 'y', acts as the key within the nested map. This nested map utilises a multiset to ensure that node values are stored in a unique and sorted order.
                    With our map structure in place, we initiate a level order BFS traversal using a queue. Each element in the queue is a pair containing the current node and its corresponding vertical and level coordinates. Starting with the root node, we enqueue it with initial vertical and level values (0, 0). During traversal, for each dequeued node, we update the map by inserting the node value at its corresponding coordinates and enqueue its left and right children with adjusted vertical and level information.
                    When traversing to the left child, the vertical value decreases by 1 and the level increases by 1, while traversal to the right child leads to an increase in both vertical and level by 1.</p>
<p><figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/18c12b24e6ae0a894be31fca35408a80" width="439"/></figure></p>
<p>After completing the BFS traversal, we prepare the final result vector. We iterate through the map, creating a column vector for each vertical column. This involves gathering node values from the multiset and inserting them into the column vector. These column vectors are then added to the final result vector, resulting in a 2D representation of the vertical order traversal of the binary tree.</p>
<p><figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/a5fc42c9fd5c977bf8b911203ed131ba" width="439"/></figure></p>
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1:</strong> Create an empty map to store the nodes based on their vertical and horizontal levels.The key of the map ‘x’ represents the vertical column, and the nested map uses ‘y’ as the key for the level. Initialise a ‘multiset’ to store node values at a specific vertical and level to ensure unique and sorted order of nodes.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ef223c85c344bc84113b939509570433" width="439"/></figure>
<p><strong>Step 2:</strong> Initialise a queue for level order BFS traversal. Each element in the queue should be a pair containing the current node and its vertical and level order information as x and coordinates. Enqueue the root node into the queue with its initial vertical and level order values as (0, 0)</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/cb98adf151f4f45e09eac5c129f3b170" width="439"/></figure>
<p><strong>Step 3:</strong>  While the queue is not empty, pop the front node of the queue:
                    <ol><li>Get this nodes vertical ie. ‘x’ and level order ‘y’ information.</li><li>Insert this node into the map at its corresponding coordinate.</li><li>Push the left and right child of the node with their updated horizontal distance and level order.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ed3a5cd8a7cc9ef877699a1e14b4405e" width="439"/></figure>
<p>For the left child, decrement the vertical value ‘x’ by 1 to indicate a move towards the left. Increment the level value ‘y’ by 1 to indicate a move down to the next level.
                    For the right child, increment the vertical value ‘x’ by 1 to indicate a move towards the right.
                    Increment the level value ‘y’ by 1 to indicate a move down to the next level.
                	</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/18c12b24e6ae0a894be31fca35408a80" width="439"/></figure>
<p>Enqueue both the left and right children along with their updated vertical and level information into the queue.</p>
<p><strong>Step 4:</strong> After the BFS traversal using the queue is complete, initialise a final result 2D vector ‘ans’.
                    <ol><li>Iterate through the map, creating a column vector for each vertical column. Gather the node values from the multiset and insert them into the column vector.</li><li>Add these column vectors to the final result vector ‘ans’.</li></ol></p>
<!--<figure class="wp-block-image size-full is-resized"><img src="https://static.takeuforward.org/content/boundary-traversal-image7-fsN2b9gx" alt="" class="wp-image-8107" width="439" height="286"/></figure>-->
<p><strong>Step 5:</strong>  Return the 2D vector `ans` representing the vertical order traversal of the binary tree. </p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                        Code
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                            <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

// Node structure for the binary tree
struct Node {
    int data;
    Node* left;
    Node* right;
    // Constructor to initialize
    // the node with a value
    Node(int val) : data(val), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    // Function to perform vertical order traversal
    // and return a 2D vector of node values
    vector&lt;vector&lt;int&gt;&gt; findVertical(Node* root){
        // Map to store nodes based on
        // vertical and level information
        map&lt;int, map&lt;int, multiset&lt;int&gt;&gt;&gt; nodes;
        
        // Queue for BFS traversal, each
        // element is a pair containing node
        // and its vertical and level information
        queue&lt;pair&lt;Node*, pair&lt;int, int&gt;&gt;&gt; todo;
        
        // Push the root node with initial vertical
        // and level values (0, 0)
        todo.push({root, {0, 0}});
        
        // BFS traversal
        while(!todo.empty()){
            // Retrieve the node and its vertical
            // and level information from
            // the front of the queue
            auto p = todo.front();
            todo.pop();
            Node* temp = p.first;
            
            // Extract the vertical and level information
            // x -&gt; vertical
            int x = p.second.first;  
            // y -&gt; level
            int y = p.second.second; 
            
            // Insert the node value into the
            // corresponding vertical and level
            // in the map
            nodes[x][y].insert(temp-&gt;data);
            
            // Process left child
            if(temp-&gt;left){
                todo.push({
                    temp-&gt;left,
                    {
                        // Move left in
                        // terms of vertical
                        x-1, 
                        // Move down in
                        // terms of level
                        y+1  
                    }
                });
            }
            
            // Process right child
            if(temp-&gt;right){
                todo.push({
                    temp-&gt;right, 
                    {
                        // Move right in
                        // terms of vertical
                        x+1, 
                        // Move down in
                        // terms of level
                        y+1  
                    }
                });
            }
        }
        
        // Prepare the final result vector
        // by combining values from the map
        vector&lt;vector&lt;int&gt;&gt; ans;
        for(auto p: nodes){
            vector&lt;int&gt; col;
            for(auto q: p.second){
                // Insert node values
                // into the column vector
                col.insert(col.end(), q.second.begin(), q.second.end());
            }
            // Add the column vector
            // to the final result
            ans.push_back(col);
        }
        return ans;
    }
};

// Helper function to
// print the result
void printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; result) {
    for(auto level: result){
        for(auto node: level){
            cout &lt;&lt; node &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}

int main() {
    // Creating a sample binary tree
    Node* root = new Node(1);
    root-&gt;left = new Node(2);
    root-&gt;left-&gt;left = new Node(4);
    root-&gt;left-&gt;right = new Node(10);
    root-&gt;left-&gt;left-&gt;right = new Node(5);
    root-&gt;left-&gt;left-&gt;right-&gt;right = new Node(6);
    root-&gt;right = new Node(3);
    root-&gt;right-&gt;right = new Node(10);
    root-&gt;right-&gt;left = new Node(9);

    Solution solution;

    // Get the Vertical traversal
    vector&lt;vector&lt;int&gt;&gt; verticalTraversal =
                    solution.findVertical(root);

    // Print the result
    cout &lt;&lt; "Vertical Traversal: ";
    printResult(verticalTraversal);

    return 0;
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                            <code class="language-java" lang="java">
import java.util.*;

// Node class for the binary tree
class Node {
    int data;
    Node left;
    Node right;

    // Constructor to initialize
    // the node with a value
    public Node(int val) {
        data = val;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to perform vertical order traversal
    // and return a 2D ArrayList of node values
    public List&lt;List&lt;Integer&gt;&gt; findVertical(Node root) {
        // Map to store nodes based on
        // vertical and level information
        Map&lt;Integer, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt;&gt; nodes = new TreeMap&lt;&gt;();

        // Queue for BFS traversal, each
        // element is a pair containing node
        // and its vertical and level information
        Queue&lt;Pair&lt;Node, Pair&lt;Integer, Integer&gt;&gt;&gt; todo = new LinkedList&lt;&gt;();

        // Push the root node with initial vertical
        // and level values (0, 0)
        todo.add(new Pair&lt;&gt;(root, new Pair&lt;&gt;(0, 0)));

        // BFS traversal
        while (!todo.isEmpty()) {
            // Retrieve the node and its vertical
            // and level information from
            // the front of the queue
            Pair&lt;Node, Pair&lt;Integer, Integer&gt;&gt; p = todo.poll();
            Node temp = p.getKey();

            // Extract the vertical and level information
            // x -&gt; vertical
            int x = p.getValue().getKey();
            // y -&gt; level
            int y = p.getValue().getValue();

            // Insert the node value into the
            // corresponding vertical and level
            // in the map
            nodes.computeIfAbsent(x, k -&gt; new TreeMap&lt;&gt;())
                 .computeIfAbsent(y, k -&gt; new TreeSet&lt;&gt;())
                 .add(temp.data);

            // Process left child
            if (temp.left != null) {
                todo.add(new Pair&lt;&gt;(temp.left, new Pair&lt;&gt;(x - 1, y + 1)));
            }

            // Process right child
            if (temp.right != null) {
                todo.add(new Pair&lt;&gt;(temp.right, new Pair&lt;&gt;(x + 1, y + 1)));
            }
        }

        // Prepare the final result list
        // by combining values from the map
        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
        for (Map.Entry&lt;Integer, Map&lt;Integer, TreeSet&lt;Integer&gt;&gt;&gt; entry : nodes.entrySet()) {
            List&lt;Integer&gt; col = new ArrayList&lt;&gt;();
            for (TreeSet&lt;Integer&gt; set : entry.getValue().values()) {
                // Insert node values
                // into the column list
                col.addAll(set);
            }
            // Add the column list
            // to the final result
            ans.add(col);
        }
        return ans;
    }

    // Helper function to
    // print the result
    private static void printResult(List&lt;List&lt;Integer&gt;&gt; result) {
        for (List&lt;Integer&gt; level : result) {
            for (int node : level) {
                System.out.print(node + " ");
            }
            System.out.println();
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Creating a sample binary tree
        Node root = new Node(1);
        root.left = new Node(2);
        root.left.left = new Node(4);
        root.left.right = new Node(10);
        root.left.left.right = new Node(5);
        root.left.left.right.right = new Node(6);
        root.right = new Node(3);
        root.right.right = new Node(10);
        root.right.left = new Node(9);

        Solution solution = new Solution();

        // Get the Vertical traversal
        List&lt;List&lt;Integer&gt;&gt; verticalTraversal = solution.findVertical(root);

        // Print the result
        System.out.print("Vertical Traversal: ");
        printResult(verticalTraversal);
    }
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                            <code class="language-python" lang="python">
from collections import deque, defaultdict

# Node structure for the binary tree
class Node:
    def __init__(self, val):
        self.data = val
        self.left = None
        self.right = None

class Solution:
    # Function to perform vertical order traversal
    # and return a 2D list of node values
    def findVertical(self, root):
        # Map to store nodes based on
        # vertical and level information
        nodes = defaultdict(lambda: defaultdict(lambda: set()))

        # Queue for BFS traversal, each
        # element is a pair containing node
        # and its vertical and level information
        todo = deque([(root, (0, 0))])

        # BFS traversal
        while todo:
            # Retrieve the node and its vertical
            # and level information from
            # the front of the queue
            temp, (x, y) = todo.popleft()

            # Insert the node value into the
            # corresponding vertical and level
            # in the map
            nodes[x][y].add(temp.data)

            # Process left child
            if temp.left:
                todo.append((temp.left, (x - 1, y + 1)))

            # Process right child
            if temp.right:
                todo.append((temp.right, (x + 1, y + 1)))

        # Prepare the final result list
        # by combining values from the map
        ans = []
        for x, y_vals in nodes.items():
            col = []
            for y, values in y_vals.items():
                # Insert node values
                # into the column list
                col.extend(sorted(values))
            # Add the column list
            # to the final result
            ans.append(col)

        return ans

# Helper function to
# print the result
def printResult(result):
    for level in result:
        for node in level:
            print(node, end=" ")
        print()
    print()

if __name__ == "__main__":
    # Creating a sample binary tree
    root = Node(1)
    root.left = Node(2)
    root.left.left = Node(4)
    root.left.right = Node(10)
    root.left.left.right = Node(5)
    root.left.left.right.right = Node(6)
    root.right = Node(3)
    root.right.right = Node(10)
    root.right.left = Node(9)

    solution = Solution()

    # Get the Vertical traversal
    verticalTraversal = solution.findVertical(root)

    # Print the result
    print("Vertical Traversal: ")
    printResult(verticalTraversal)
                           </code>
                        </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node structure for the binary tree
class Node {
    constructor(val) {
        this.data = val;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to perform vertical order traversal
    // and return a 2D array of node values
    findVertical(root) {
        // Map to store nodes based on
        // vertical and level information
        const nodes = new Map();
        
        // Queue for BFS traversal, each
        // element is an array containing node
        // and its vertical and level information
        const todo = [];
        
        // Push the root node with initial vertical
        // and level values (0, 0)
        todo.push([root, [0, 0]]);
        
        // BFS traversal
        while (todo.length &gt; 0) {
            // Retrieve the node and its vertical
            // and level information from
            // the front of the queue
            const [temp, [x, y]] = todo.shift();
            
            // Insert the node value into the
            // corresponding vertical and level
            // in the map
            if (!nodes.has(x)) {
                nodes.set(x, new Map());
            }
            if (!nodes.get(x).has(y)) {
                nodes.get(x).set(y, new Set());
            }
            nodes.get(x).get(y).add(temp.data);
            
            // Process left child
            if (temp.left) {
                todo.push([
                    temp.left,
                    [
                        // Move left in
                        // terms of vertical
                        x - 1,
                        // Move down in
                        // terms of level
                        y + 1
                    ]
                ]);
            }
            
            // Process right child
            if (temp.right) {
                todo.push([
                    temp.right,
                    [
                        // Move right in
                        // terms of vertical
                        x + 1,
                        // Move down in
                        // terms of level
                        y + 1
                    ]
                ]);
            }
        }
        
        // Prepare the final result array
        // by combining values from the map
        const ans = [];
        for (const [key, value] of nodes) {
            const col = [];
            for (const [subKey, subValue] of value) {
                // Insert node values
                // into the column array
                col.push(...subValue);
            }
            // Add the column array
            // to the final result
            ans.push(col);
        }
        return ans;
    }
}

// Helper function to
// print the result
function printResult(result) {
    for (const level of result) {
        console.log(level.join(" "));
    }
    console.log("");
}

// Creating a sample binary tree
const root = new Node(1);
root.left = new Node(2);
root.left.left = new Node(4);
root.left.right = new Node(10);
root.left.left.right = new Node(5);
root.left.left.right.right = new Node(6);
root.right = new Node(3);
root.right.right = new Node(10);
root.right.left = new Node(9);

const solution = new Solution();

// Get the Vertical traversal
const verticalTraversal = solution.findVertical(root);

// Print the result
console.log("Vertical Traversal: ");
printResult(verticalTraversal);

                            </code>
                        </pre>
</div>
<p>
<strong>Output</strong> 
                      	Vertical Traversal: 
                      	4
                      	2 5
                      	1 9 10 6
                      	3
                      	10

                    </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                        Complexity Analysis
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity  Here -->
<p><strong>Time Complexity: O(N * log2N * log2N * log2N)</strong> where N represents the number of nodes in the Binary Tree.
                    <ol><li>Postorder Traversal performed using BFS as a time complexity of O(N) as we are visiting each and every node once.</li><li>Multiset Operations to insert overlapping nodes at a specific vertical and horizontal level also takes O(log2N) complexity.</li><li>Map operations involve insertion and retrieval of nodes with their vertical and level as their keys. Since there are two nested maps, the total time complexity becomes O(log2N)*O(log2N).</li></ol></p>
<p><strong>Space Complexity:  O(N + N/2)</strong>  where N represents the number of nodes in the Binary Tree.
					<ol><li>The map for storing nodes based on their vertical and level information occupies an additional space complexity of O(N) as it stores all N nodes of the Binary Tree.</li><li>The queue for breadth first traversal occupies a space proportional to the maximum level of the tree which can be O(N/2) in the worst case of a balanced tree.</li></ol> </p>
</p>
</details>
</div>
</details>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/q_a6lpbKJdw?si=e_LfTzvNCVcp5aan" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>