<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Disjoint Set | Union by Rank | Union by Size | Path Compression: G-46</title>
<link href="assets/34bd07407ad1de576cba1f67651fa31a" rel="stylesheet"/>
<style>
        /* ==========================================================================
           1. CSS Variables (Theme) - Utilitarian Modern
           ========================================================================== */
        :root {
            /* Default to Light Theme */
            --primary-color: #3b82f6; /* Blue 500 */
            --primary-hover: #2563eb; /* Blue 600 */
            
            --bg-body: #f8fafc; /* Slate 50 */
            --bg-surface: #ffffff; /* White */
            --bg-subtle: #f1f5f9; /* Slate 100 */
            
            --border-color: #e2e8f0; /* Slate 200 */
            
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #334155; /* Slate 700 */
            --text-muted: #64748b; /* Slate 500 */
            
            --link-color: #2563eb; /* Blue 600 */
            --link-hover: #3b82f6; /* Blue 500 */

            --code-bg: #f1f5f9; /* Slate 100 */
            --code-text: #0f172a; /* Slate 900 */

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 0 25px -5px rgba(59, 130, 246, 0.25);
            
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
        }

        /* Dark Theme Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f172a; /* Slate 900 */
                --bg-surface: #1e293b; /* Slate 800 */
                --bg-subtle: #334155; /* Slate 700 */
                
                --border-color: #334155;
                
                --text-primary: #f8fafc; /* Slate 50 */
                --text-secondary: #cbd5e1; /* Slate 300 */
                --text-muted: #94a3b8; /* Slate 400 */
                
                --link-color: #60a5fa; /* Blue 400 */
                --link-hover: #93c5fd; /* Blue 300 */

                --code-bg: #020617; /* Slate 950 */
                --code-text: #f8fafc;
            }
        }

        /* ==========================================================================
           2. Base & Reset
           ========================================================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-body);
            margin: 0;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ==========================================================================
           3. Layout
           ========================================================================== */
        .container {
            max-width: 800px; /* Optimal reading width */
            margin: 0 auto;
            padding: 2rem;
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        /* Enhanced hover for desktop only */
        @media (hover: hover) and (pointer: fine) {
            .container:hover {
                transform: translateY(-4px);
                border-color: var(--primary-color);
                box-shadow: var(--shadow-hover);
            }
        }

        /* ==========================================================================
           4. Typography
           ========================================================================== */
        h1 {
            color: var(--text-primary);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.025em;
        }
        
        h2, h3, h4 {
            color: var(--text-secondary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.25em;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* ==========================================================================
           5. Media
           ========================================================================== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            margin: 1.5rem auto;
        }

        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            margin: 1.5rem 0;
            border-radius: var(--radius-md);
            background-color: var(--bg-subtle);
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ==========================================================================
           6. Code Blocks
           ========================================================================== */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            overflow-x: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        code {
            font-family: inherit;
        }

        /* ==========================================================================
           7. Code Tabs
           ========================================================================== */
        .code-section {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .code-tabs {
            display: flex;
            background-color: var(--bg-subtle);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .code-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .code-tab:hover {
            color: var(--text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .copy-btn {
            margin-left: auto;
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .copy-btn svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
        }
        
        .copy-btn:hover svg {
            fill: var(--text-primary);
        }

        .code-content {
            background-color: var(--code-bg);
        }
        
        .code-content pre {
            margin: 0;
            padding: 0;
            border-radius: 0;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ==========================================================================
           8. Accordions / Details
           ========================================================================== */
        details {
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: var(--bg-surface);
            transition: box-shadow 0.2s;
        }
        
        details:hover {
            box-shadow: var(--shadow-sm);
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: 1rem;
            background-color: var(--bg-subtle);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: #475569; /* Slate 600 */
        }
        
        /* Arrow icon rotation */
        summary .arrow-svg {
            transition: transform 0.3s ease;
            width: 20px;
            height: 20px;
            fill: var(--text-muted);
            flex-shrink: 0;
            transform-origin: center;
        }
        
        /* Only rotate the arrow of the *active* details element */
        details[open] > summary .arrow-svg {
            transform: rotate(90deg);
            fill: var(--primary-color);
        }

        .common-drops,
        .atricle_example_content,
        details > :not(summary) {
            padding: 0 0.5rem;
            background-color: var(--bg-surface);
        }

        /* Nested details */
        .secondary-details {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        .secondary-summary {
            background-color: rgba(51, 65, 85, 0.3); /* Semi-transparent slate-700 */
            font-size: 0.95rem;
        }
        
        .secondary-summary:hover {
            background-color: var(--bg-subtle);
        }
        
        .opacity-75 {
            opacity: 0.75;
        }

        /* ==========================================================================
           9. Practice & Disclaimer
           ========================================================================== */
        .practice, .new-disclaimer {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: var(--bg-subtle);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .problem-buttons a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        
        .problem-buttons a:hover {
            background-color: var(--primary-hover);
            text-decoration: none;
        }

        /* ==========================================================================
           10. Utilities
           ========================================================================== */
        .problem-buttons img,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article,
        .has-text-align-center {
            display: none;
        }
        
        .arrow-svg {
            display: inline-block; /* Ensure arrows are visible */
        }

        /* ==========================================================================
           11. Responsive (Full Page Mobile)
           ========================================================================== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border: none;
                border-radius: 0;
                box-shadow: none;
                padding: 0.5rem;
                max-width: 100%;
            }

            h1 {
                font-size: 1.5rem;
                text-align: left;
            }

            .code-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 2px; /* Space for scrollbar */
            }
            
            .code-tab {
                flex-shrink: 0;
            }

            .code-content pre {
                padding: 0.2rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Disjoint Set | Union by Rank | Union by Size | Path Compression: G-46</h1>
</header>
<article>
<!-- wp:paragraph -->
<p>In this article, we will discuss the <strong><em>Disjoint Set</em></strong> data structure which is a very important topic in the entire graph series. Let’s first understand <strong><em>why we need a Disjoint Set data structure using the below question:</em></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Question: </strong>Given two components of an undirected graph</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7031,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7031" src="assets/db6ac4690d7b6f7359b0f2512b87c6c9.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>The question is whether node 1 and node 5 are in the same component or not.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Approach:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now, in order to solve this question we can use either the <a href="https://takeuforward.org/data-structure/depth-first-search-dfs/" rel="noopener" target="_blank" title="">DFS</a> or <a href="https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/" rel="noopener" target="_blank" title="">BFS</a> traversal technique like if we traverse the components of the graph we can find that node 1 and node 5 are not in the same component. This is actually the <strong><em>brute force</em></strong> approach whose time complexity is <strong>O(N+E)</strong><em>(N = no. of nodes, E = no. of edges).</em> But <strong><em>using a Disjoint Set data structure we can solve this same problem in constant time</em></strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The disjoint Set data structure is generally used for <strong><em>dynamic graphs</em></strong>. </p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Dynamic graph:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>A dynamic graph generally refers to a graph that keeps on changing its configuration. Let’s deep dive into it using an example:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Let’s consider the edge information for the given graph as: {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}, {3,7}}. Now if we start adding the edges one by one, in each step the structure of the graph will change. So, after each step, if we perform the same operation on the graph while updating the edges, the result might be different. In this case, the graph will be considered a dynamic graph.</li><li>For example, after adding the first 4 edges if we look at the graph, we will find that node 4 and node 1 belong to different components but after adding all 6 edges if we search for the same we will figure out that node 4 and node 1 belong to the same component.</li></ul>
<!-- /wp:list -->
<!-- wp:image {"id":7032,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7032" src="assets/6d2a561259e161d4a52c6b66778d32b0.png"/></figure>
<!-- /wp:image -->
<!-- wp:list -->
<ul><li>So, <strong><em>after any step, if we try to figure out whether two arbitrary nodes u and v belong to the same component or not, Disjoint Set will be able to answer this query in constant time.</em></strong></li></ul>
<!-- /wp:list -->
<!-- wp:heading {"level":3} -->
<h3>Functionalities of Disjoint Set data structure:</h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>The disjoint set data structure generally provides two types of functionalities:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Finding the parent for a particular node (<strong><em>findPar()</em></strong><em>)</em></li><li>Union (in broad terms this method basically adds an edge between two nodes)<ul><li>Union by rank</li><li>Union by size</li></ul></li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>First, we will be discussing Union by rank and then Union by size.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Union by rank:</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>Before discussing Union by rank we need to discuss some terminologies:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Rank:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The rank of a node generally refers to the distance (the number of nodes including the leaf node) between the furthest leaf node and the current node. Basically rank includes all the nodes beneath the current node.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7033,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7033" src="assets/ea6ef0a84dbe2149d9b3e2945cd51a73.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Ultimate parent:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The parent of a node generally refers to the node right above that particular node. But the ultimate parent refers to the topmost node or the root node.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7034,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7034" src="assets/39f0b6bbcfea39e0d0f8757095ddfe38.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Now let’s discuss the implementation of the union by rank function. In order to implement Union by rank, we basically need two arrays of size N(no. of nodes). One is the <strong><em>rank </em></strong>and the other one is the <strong><em>parent</em></strong>. The rank array basically stores the rank of each node and the parent array stores the ultimate parent for each node.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Algorithm:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Initial configuration:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>rank array: </strong>This array is initialized with zero.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>parent array: </strong>The array is initialized with the value of nodes i.e. parent[i] = i.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>Firstly, the Union function requires two nodes(<strong><em>let’s say u and v</em></strong>) as arguments. Then we will find the ultimate parent (using the findPar() function that is discussed later) of u and v. Let’s consider the ultimate parent of u is <strong><em>pu </em></strong>and the ultimate parent of v is <strong><em>pv</em></strong>.</li><li>After that, we will find the rank of <strong><em>pu</em></strong> and <strong><em>pv</em></strong>.</li><li>Finally, we will connect the ultimate parent with a smaller rank to the other ultimate parent with a larger rank. But if the ranks are equal, we can connect any parent to the other parent and we will increase the rank by one for the parent node to whom we have connected the other one.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>Let’s understand it further using the below example. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Given the edges of a graph are: {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}}</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7035,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7035" src="assets/25dba6e0c494f32385690482b158a6f5.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>After applying the union by rank function to every edge the graph and the arrays will look like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Observation 1:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p><strong> </strong>If we carefully observe, we are only concerned about the ultimate parent but not the immediate parent.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Let’s see <strong><em>why we need to find the ultimate parents</em></strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>After union by rank operations, if we are asked (refer to the above picture) if node 5 and node 7 belong to the same component or not, the answer must be yes. If we carefully look at their immediate parents, they are not the same but if we consider their ultimate parents they are the same i.e. node 4. So, we can determine the answer by considering the ultimate parent. That is why we need to find the ultimate parent.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>So, here comes the <strong>findPar() function</strong> which will help us to find the ultimate parent for a particular node.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>findPar() function:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>This function actually takes a single node as an argument and finds the ultimate parent for each node.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Observation 2:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>Now, if we try to find the ultimate parent(typically using recursion) of each query separately, it will end up taking O(logN) time complexity for each case. But we want the operation to be done in a constant time. This is where the <strong><em>path compression technique </em></strong>comes in.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Using the <strong><em>path compression technique</em></strong> we can reduce the time complexity nearly to constant time. It is discussed later on why the time complexity actually reduces.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><em>What is path compression?</em></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Basically, connecting each node in a particular path to its ultimate parent refers to path compression. Let’s understand it using the following illustration:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7038,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7038" src="assets/04769cffb9dfdd314ad5c312eb6cfc5a.png"/></figure>
<!-- /wp:image -->
<!-- wp:heading {"level":3} -->
<h3><strong><em>How the time complexity reduces:</em></strong></h3>
<!-- /wp:heading -->
<!-- wp:list -->
<ul><li>Before path compression, if we had tried to find the ultimate parent for node 4, we had to traverse all the way back to node 1 which is basically the height of size logN. But after path compression, we can easily access the ultimate parent with a single step. Thus the traversal reduces and as a result the time complexity also reduces.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>Though using the path compression technique it seems like the rank of the node is also changing, we cannot be sure about it. So, we will not make any changes to the rank array while applying path compression. The following example depicts an example:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7037,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7037" src="assets/65f22e778ab0187b4003cf51713a8429.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>We cannot change the ranks while applying path compression.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Overall, findPar() method helps to reduce the time complexity of the <strong><em>union by the rank </em></strong>method as it can find the ultimate parent within constant time. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Algorithm:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>This process is done using the backtracking method.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li><strong>Base case: </strong>If the node and the parent of the node become the same, it will return the node.</li><li>We will call the findPar() function for a node until it hits the base case and while backtracking we will update the parent of the current node with the returned value.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>The actual time complexity of union by rank and findPar() is O(4) which is very small and close to 1. So, we can consider 4 as a constant. Now, this 4 term has a long mathematical derivation which is not required for an interview.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code of Union by rank and findPar():</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
class DisjointSet {
    vector&lt;int&gt; rank, parent;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] &lt; rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] &lt; rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }
};
int main() {
    DisjointSet ds(7);
    ds.unionByRank(1, 2);
    ds.unionByRank(2, 3);
    ds.unionByRank(4, 5);
    ds.unionByRank(6, 7);
    ds.unionByRank(5, 6);
    // if 3 and 7 same or not
    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout &lt;&lt; "Same\n";
    }
    else cout &lt;&lt; "Not same\n";

    ds.unionByRank(3, 7);

    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout &lt;&lt; "Same\n";
    }
    else cout &lt;&lt; "Not same\n";
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Not same<br/>Same</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:  </strong>The actual time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.io.*;
import java.util.*;
class DisjointSet {
    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();
    public DisjointSet(int n) {
        for (int i = 0; i &lt;= n; i++) {
            rank.add(0);
            parent.add(i);
        }
    }

    public int findUPar(int node) {
        if (node == parent.get(node)) {
            return node;
        }
        int ulp = findUPar(parent.get(node));
        parent.set(node, ulp);
        return parent.get(node);
    }

    public void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {
            parent.set(ulp_u, ulp_v);
        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {
            parent.set(ulp_v, ulp_u);
        } else {
            parent.set(ulp_v, ulp_u);
            int rankU = rank.get(ulp_u);
            rank.set(ulp_u, rankU + 1);
        }
    }

}

class Main {
    public static void main (String[] args) {
        DisjointSet ds = new DisjointSet(7);
        ds.unionByRank(1, 2);
        ds.unionByRank(2, 3);
        ds.unionByRank(4, 5);
        ds.unionByRank(6, 7);
        ds.unionByRank(5, 6);

        // if 3 and 7 same or not
        if (ds.findUPar(3) == ds.findUPar(7)) {
            System.out.println("Same");
        } else
            System.out.println("Not Same");

        ds.unionByRank(3, 7);
        if (ds.findUPar(3) == ds.findUPar(7)) {
            System.out.println("Same");
        } else
            System.out.println("Not Same");
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Not same<br/>Same</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:  </strong>The actual time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Follow-up question:</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p><strong><em>In the union by rank method, why do we need to connect the smaller rank to the larger rank?</em></strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Let’s understand it using the following example:</li></ul>
<!-- /wp:list -->
<!-- wp:image {"id":7039,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7039" src="assets/8221a83dddef65f327dcc7193d4c386b.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>In this case, the traversal time to find the ultimate parent for nodes 3, 4, 5, 6, 7, and 8 increases and so the path compression time also increases. But if we do the following</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7040,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7040" src="assets/ec3f4ee09b2a6d5b30a684f5ce35491b.png"/></figure>
<!-- /wp:image -->
<!-- wp:list -->
<ul><li>the traversal time to find the ultimate parent for only nodes 1 and 2 increases. So the path compression time becomes relatively lesser than in the previous case. So, we can conclude that we should always connect a smaller rank to a larger one with the goal of<ul><li><strong><em>shrinking the height of the graph.</em></strong></li><li><strong><em>reducing the time complexity as much as we can.</em></strong></li></ul></li></ul>
<!-- /wp:list -->
<!-- wp:heading {"level":5} -->
<h5><strong>Observation 3:</strong></h5>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>Until now, we have learned union by rank, the findPar() function, and the path compression technique. Now, if we again carefully observe, after applying path compression the rank of the graphs becomes distorted. So, rather than storing the rank, we can just store the size of the components for comparing which component is greater or smaller.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>So, here comes the concept of <strong><em>Union by size</em></strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Union by size:</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>This is as same as the Union by rank method except this method uses the size to compare the components while connecting. That is why we need a <strong><em>‘size’ </em></strong>array of size N(no. of nodes) instead of a <strong><em>rank</em></strong> array. The size array will be storing the size for each particular node i.e. size[i] will be the size of the component starting from node i.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em>Typically, the size of a node refers to the number of nodes that are connected to it.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Algorithm:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Initial configuration:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>size array: </strong>This array is initialized with one.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>parent array: </strong>The array is initialized with the value of nodes i.e. parent[i] = i.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>Firstly, the Union function requires two nodes(<strong><em>let’s say u and v</em></strong>) as arguments. Then we will find the ultimate parent (using the findPar() function discussed earlier) of u and v. Let’s consider the ultimate parent of u is <strong><em>pu </em></strong>and the ultimate parent of v is <strong><em>pv</em></strong>.<br/></li><li>After that, we will find the size of <strong><em>pu</em></strong> and <strong><em>pv</em></strong> i.e. size[pu] and size[pv].<br/></li><li>Finally, we will connect the ultimate parent with a smaller size to the other ultimate parent with a larger size. But if the size of the two is equal, we can connect any parent to the other parent.<br/>While connecting in both cases we will increase the size of the parent node to whom we have connected by the size of the other parent node which is actually connected.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>Let’s understand it further using the below example. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Given the edges of a graph are {{1,2}, {2,3}, {4,5}, {6,7}, {5,6}, {3,7}}</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7041,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7041" src="assets/b178e4e0b86ce0a3cec3b4eb37784b1a.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>After applying the union by size function to every edge the graph and the arrays will look like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7042,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7042" src="assets/3e5f914a340f3230e8ee320abdd48ce8.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>It seems much more intuitive than union by rank as the rank gets distorted after path compression.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>The findPar() function remains the exact same as we have discussed earlier.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Disjoint Set data structure implementation:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;
class DisjointSet {
    vector&lt;int&gt; rank, parent, size;
public:
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i &lt;= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] &lt; rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] &lt; rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] &lt; size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};
int main() {
    DisjointSet ds(7);
    ds.unionBySize(1, 2);
    ds.unionBySize(2, 3);
    ds.unionBySize(4, 5);
    ds.unionBySize(6, 7);
    ds.unionBySize(5, 6);
    // if 3 and 7 same or not
    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout &lt;&lt; "Same\n";
    }
    else cout &lt;&lt; "Not same\n";

    ds.unionBySize(3, 7);

    if (ds.findUPar(3) == ds.findUPar(7)) {
        cout &lt;&lt; "Same\n";
    }
    else cout &lt;&lt; "Not same\n";
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong><br/>Not Same<br/>Same</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:  </strong>The time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.io.*;
import java.util.*;
class DisjointSet {
    List&lt;Integer&gt; rank = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; parent = new ArrayList&lt;&gt;();
    List&lt;Integer&gt; size = new ArrayList&lt;&gt;();
    public DisjointSet(int n) {
        for (int i = 0; i &lt;= n; i++) {
            rank.add(0);
            parent.add(i);
            size.add(1);
        }
    }

    public int findUPar(int node) {
        if (node == parent.get(node)) {
            return node;
        }
        int ulp = findUPar(parent.get(node));
        parent.set(node, ulp);
        return parent.get(node);
    }

    public void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank.get(ulp_u) &lt; rank.get(ulp_v)) {
            parent.set(ulp_u, ulp_v);
        } else if (rank.get(ulp_v) &lt; rank.get(ulp_u)) {
            parent.set(ulp_v, ulp_u);
        } else {
            parent.set(ulp_v, ulp_u);
            int rankU = rank.get(ulp_u);
            rank.set(ulp_u, rankU + 1);
        }
    }

    public void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size.get(ulp_u) &lt; size.get(ulp_v)) {
            parent.set(ulp_u, ulp_v);
            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u));
        } else {
            parent.set(ulp_v, ulp_u);
            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v));
        }
    }
}

class Main {
    public static void main (String[] args) {
        DisjointSet ds = new DisjointSet(7);
        ds.unionByRank(1, 2);
        ds.unionByRank(2, 3);
        ds.unionByRank(4, 5);
        ds.unionByRank(6, 7);
        ds.unionByRank(5, 6);

        // if 3 and 7 same or not
        if (ds.findUPar(3) == ds.findUPar(7)) {
            System.out.println("Same");
        } else
            System.out.println("Not Same");

        ds.unionByRank(3, 7);
        if (ds.findUPar(3) == ds.findUPar(7)) {
            System.out.println("Same");
        } else
            System.out.println("Not Same");
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: </strong><br/>Not Same<br/>Same</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity:  </strong>The time complexity is O(4) which is very small and close to 1. So, we can consider 4 as a constant.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noreferrer noopener" target="_blank"><strong>KRITIDIPTA GHOSH</strong></a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>