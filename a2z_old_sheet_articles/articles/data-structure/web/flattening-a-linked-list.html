<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Flattening a Linked List</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* Practice */
        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: 20px auto;
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Flattening a Linked List</h1>
</header>
<article>
<p><strong>Problem Statement: </strong>Given a linked list containing ‘N’ head nodes where every node in the linked list contains two pointers:
<ol><li>‘Next’ points to the next node in the list</li><li>‘Child’ pointer to a linked list where the current node is the head</li></ol></p>
<p>
Each of these child linked lists is in sorted order and connected by a 'child' pointer.
Your task is to flatten this linked list such that all nodes appear in a single layer or level in a 'sorted order'.

</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>

                <span><strong>Input:</strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/fea194f1c07b967e01261073652bc56f" width="439"/></figure>
               
                <span><strong>Output:</strong>1 2 3 4 5 6 7 8 9 10 11 12</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/84d1bbb0b9cbe9b9b4194d4372c00748" width="439"/></figure>
                <span><strong>Explanation: </strong>Flatten the linked list into a single level sorted order and traverse the nodes in such a manner that the child linked lists are merged into the main list in the sorted order.</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/237a2e2f9b0644a551fb407f9fed2048" width="439"/></figure>
                <br/>
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong></span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/13b53d5369993c28ee70a1d80b048e92" width="439"/></figure>                
                
                <span><strong>Output: </strong>2 4 5 10 12 13 16 17 20</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/57f27153c3c8f2e72d151ff907d8c4a7" width="439"/></figure>
                <span><strong>Explanation: </strong> </span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/a4a607dc806b1efba1367b3cfd0663a5" width="439"/></figure>                            

            </pre>
</div>
</details>
</div>
<!-- This is Practice Section
<div class="practice">
    <span><strong>Practice: </strong></span>
    <div class="problem-buttons">

         
        <a href="https://www.codingninjas.com/studio/problems/power-of-numbers_8157729?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga" alt="code-studio">
        </a>
    </div>
    
</div>-->
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>To transform the given linked list into a single level sorted list ensuring that the nodes are arranged in an ascending order, we initialise an array to temporarily hold the extracted nodes during the traversal.</p>
<p>We iterate over the array by first going over the top-level next pointers of the linked list then accessing each node within its child pointers adding all to the array. Then the array is sorted to arrange all values sequentially and a new linked list from that array is created and returned. </p>
<h4>Algorithm </h4>
<p><strong>Step 1:</strong>Initialise an empty array to store the data extracted during the traversal.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ee617c2e93c67c6861302eb00b8729ab" width="439"/></figure>
<p><strong>Step 2: </strong> Start traversing through the top-level ‘next’ pointers of the linked list and for each node accessed by the ‘next’ pointer, traverse its ‘child’ nodes.
                        <ol><li>Iterate all the nodes until reaching the end of the child pointer list appending each node’s value to the array. Move to the next primary node and repeat the process of traversing the child nodes.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/b2c4fb519c126f9ba9aa41a1ba892d27" width="439"/></figure>
<p><strong>Step 3: </strong>
                        Sort the array to arrange its collected node data in ascending order.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/649552f34af87531a40f082a31905c97" width="439"/></figure>
<p><strong>Step 4: </strong> Create a new linked list from the sorted array and return the flattened linked list.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

class Node {
public:
    int data;
    Node *next;
    Node *child;

    // Constructors to initialize the
    // data, next, and child pointers
    Node() : data(0), next(nullptr), child(nullptr) {};
    Node(int x) : data(x), next(nullptr), child(nullptr) {}
    Node(int x, Node *nextNode, Node *childNode) :
                    data(x), next(nextNode), child(childNode) {}
};

// Function to convert a vector to a linked list
Node* convertArrToLinkedList(vector&lt;int&gt;&amp; arr){
    // Create a dummy node to serve as
    // the head of the linked list
    Node* dummyNode = new Node(-1);
    Node* temp = dummyNode;

    // Iterate through the vector and
    // create nodes with vector elements
    for(int i = 0; i &lt; arr.size(); i++){
        // Create a new node
        // with the vector element
        temp-&gt;child = new Node(arr[i]); 
        // Move the temporary pointer
        // to the newly created node
        temp = temp-&gt;child; 
    }
    // Return the linked list starting
    // from the next of the dummy node
    return dummyNode-&gt;child; 
}

// Function to flatten a
// linked list with child pointers
Node* flattenLinkedList(Node* head) {
    vector&lt;int&gt; arr;

    // Traverse through the linked list
    while (head != nullptr) {
        // Traverse through the child
        // nodes of each head node
        Node* t2 = head;
        while (t2 != nullptr) {
            // Store each node's data in the array
            arr.push_back(t2-&gt;data);
            // Move to the next child node
            t2 = t2-&gt;child;
        }
        // Move to the next head node
        head = head-&gt;next;
    }

    // Sort the array containing
    // node values in ascending order
    sort(arr.begin(), arr.end());

    // Convert the sorted array
    // back to a linked list
    return convertArrToLinkedList(arr);
}

// Print the linked list by
// traversing through child pointers
void printLinkedList(Node* head) {
    while (head != nullptr) {
        cout &lt;&lt; head-&gt;data &lt;&lt; " ";
        head = head-&gt;child;
    }
    cout &lt;&lt; endl;
}

// Print the linked list
// in a grid-like structure
void printOriginalLinkedList(Node* head, int depth) {
    while (head != nullptr) {
        cout &lt;&lt; head-&gt;data;

        // If child exists, recursively
        // print it with indentation
        if (head-&gt;child) {
            cout &lt;&lt; " -&gt; ";
            printOriginalLinkedList(head-&gt;child, depth + 1);
        }

        // Add vertical bars
        // for each level in the grid
        if (head-&gt;next) {
            cout &lt;&lt; endl;
            for (int i = 0; i &lt; depth; ++i) {
                cout &lt;&lt; "| ";
            }
        }
        head = head-&gt;next;
    }
}

int main() {
    // Create a linked list with child pointers
    Node* head = new Node(5);
    head-&gt;child = new Node(14);
    
    head-&gt;next = new Node(10);
    head-&gt;next-&gt;child = new Node(4);
    
    head-&gt;next-&gt;next = new Node(12);
    head-&gt;next-&gt;next-&gt;child = new Node(20);
    head-&gt;next-&gt;next-&gt;child-&gt;child = new Node(13);
    
    head-&gt;next-&gt;next-&gt;next = new Node(7);
    head-&gt;next-&gt;next-&gt;next-&gt;child = new Node(17);

    // Print the original
    // linked list structure
    cout &lt;&lt; "Original linked list:" &lt;&lt; endl;
    printOriginalLinkedList(head, 0);

    // Flatten the linked list
    // and print the flattened list
    Node* flattened = flattenLinkedList(head);
    cout &lt;&lt; "\nFlattened linked list: ";
    printLinkedList(flattened);

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.ArrayList;
import java.util.Collections;

class Node {
    int data;
    Node next;
    Node child;

    // Constructors to initialize the
    // data, next, and child pointers
    Node() {
        data = 0;
        next = null;
        child = null;
    }

    Node(int x) {
        data = x;
        next = null;
        child = null;
    }

    Node(int x, Node nextNode, Node childNode) {
        data = x;
        next = nextNode;
        child = childNode;
    }
}

public class FlattenLinkedList {

    // Function to convert an ArrayList to a linked list
    static Node convertArrToLinkedList(ArrayList&lt;Integer&gt; arr) {
        // Create a dummy node to serve as
        // the head of the linked list
        Node dummyNode = new Node(-1);
        Node temp = dummyNode;

        // Iterate through the ArrayList and
        // create nodes with elements
        for (int i = 0; i &lt; arr.size(); i++) {
            // Create a new node with the element
            temp.child = new Node(arr.get(i));
            // Move the temporary pointer
            // to the newly created node
            temp = temp.child;
        }
        // Return the linked list starting
        // from the next of the dummy node
        return dummyNode.child;
    }

    // Function to flatten a linked list with child pointers
    static Node flattenLinkedList(Node head) {
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();

        // Traverse through the linked list
        while (head != null) {
            // Traverse through the child
            // nodes of each head node
            Node t2 = head;
            while (t2 != null) {
                // Store each node's data in the ArrayList
                arr.add(t2.data);
                // Move to the next child node
                t2 = t2.child;
            }
            // Move to the next head node
            head = head.next;
        }

        // Sort the ArrayList containing
        // node values in ascending order
        Collections.sort(arr);

        // Convert the sorted ArrayList
        // back to a linked list
        return convertArrToLinkedList(arr);
    }

    // Print the linked list by
    // traversing through child pointers
    static void printLinkedList(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.child;
        }
        System.out.println();
    }

    // Print the linked list
    // in a grid-like structure
    static void printOriginalLinkedList(Node head, int depth) {
        while (head != null) {
            System.out.print(head.data);

            // If child exists, recursively
            // print it with indentation
            if (head.child != null) {
                System.out.print(" -&gt; ");
                printOriginalLinkedList(head.child, depth + 1);
            }

            // Add vertical bars
            // for each level in the grid
            if (head.next != null) {
                System.out.println();
                for (int i = 0; i &lt; depth; ++i) {
                    System.out.print("| ");
                }
            }
            head = head.next;
        }
    }

    public static void main(String[] args) {
        // Create a linked list with child pointers
        Node head = new Node(5);
        head.child = new Node(14);

        head.next = new Node(10);
        head.next.child = new Node(4);

        head.next.next = new Node(12);
        head.next.next.child = new Node(20);
        head.next.next.child.child = new Node(13);

        head.next.next.next = new Node(7);
        head.next.next.next.child = new Node(17);

        // Print the original
        // linked list structure
        System.out.println("Original linked list:");
        printOriginalLinkedList(head, 0);

        // Flatten the linked list
        // and print the flattened list
        Node flattened = flattenLinkedList(head);
        System.out.println("\nFlattened linked list: ");
        printLinkedList(flattened);
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
class Node:
    def __init__(self, x=None, nextNode=None, childNode=None):
        self.data = x
        self.next = nextNode
        self.child = childNode

# Function to convert a list to a linked list
def convertArrToLinkedList(arr):
    # Create a dummy node to serve as
    # the head of the linked list
    dummyNode = Node(-1)
    temp = dummyNode

    # Iterate through the list and
    # create nodes with list elements
    for val in arr:
        # Create a new node with the list element
        temp.child = Node(val)
        # Move the temporary pointer
        # to the newly created node
        temp = temp.child

    # Return the linked list starting
    # from the next of the dummy node
    return dummyNode.child

# Function to flatten a linked list with child pointers
def flattenLinkedList(head):
    arr = []

    # Traverse through the linked list
    while head:
        # Traverse through the child
        # nodes of each head node
        t2 = head
        while t2:
            # Store each node's data in the list
            arr.append(t2.data)
            # Move to the next child node
            t2 = t2.child
        # Move to the next head node
        head = head.next

    # Sort the list containing
    # node values in ascending order
    arr.sort()

    # Convert the sorted list
    # back to a linked list
    return convertArrToLinkedList(arr)

# Print the linked list by
# traversing through child pointers
def printLinkedList(head):
    while head:
        print(head.data, end=" ")
        head = head.child
    print()

# Print the linked list
# in a grid-like structure
def printOriginalLinkedList(head, depth=0):
    while head:
        print(head.data, end="")

        # If child exists, recursively
        # print it with indentation
        if head.child:
            print(" -&gt; ", end="")
            printOriginalLinkedList(head.child, depth + 1)

        # Add vertical bars
        # for each level in the grid
        if head.next:
            print()
            print("| " * depth, end="")

        head = head.next

# Create a linked list with child pointers
head = Node(5)
head.child = Node(14)

head.next = Node(10)
head.next.child = Node(4)

head.next.next = Node(12)
head.next.next.child = Node(20)
head.next.next.child.child = Node(13)

head.next.next.next = Node(7)
head.next.next.next.child = Node(17)

# Print the original
# linked list structure
print("Original linked list:")
printOriginalLinkedList(head)

# Flatten the linked list
# and print the flattened list
flattened = flattenLinkedList(head)
print("\nFlattened linked list: ")
printLinkedList(flattened)
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
class Node {
    constructor(x = null, nextNode = null, childNode = null) {
        this.data = x;
        this.next = nextNode;
        this.child = childNode;
    }
}

// Function to convert an array to a linked list
function convertArrToLinkedList(arr) {
    // Create a dummy node to serve as
    // the head of the linked list
    let dummyNode = new Node(-1);
    let temp = dummyNode;

    // Iterate through the array and
    // create nodes with array elements
    for (let val of arr) {
        // Create a new node with the array element
        temp.child = new Node(val);
        // Move the temporary pointer
        // to the newly created node
        temp = temp.child;
    }

    // Return the linked list starting
    // from the next of the dummy node
    return dummyNode.child;
}

// Function to flatten a linked list with child pointers
function flattenLinkedList(head) {
    let arr = [];

    // Traverse through the linked list
    while (head) {
        // Traverse through the child
        // nodes of each head node
        let t2 = head;
        while (t2) {
            // Store each node's data in the array
            arr.push(t2.data);
            // Move to the next child node
            t2 = t2.child;
        }
        // Move to the next head node
        head = head.next;
    }

    // Sort the array containing
    // node values in ascending order
    arr.sort((a, b) =&gt; a - b);

    // Convert the sorted array
    // back to a linked list
    return convertArrToLinkedList(arr);
}

// Print the linked list by
// traversing through child pointers
function printLinkedList(head) {
    while (head) {
        console.log(head.data + " ");
        head = head.child;
    }
    console.log();
}

// Print the linked list
// in a grid-like structure
function printOriginalLinkedList(head, depth = 0) {
    while (head) {
        console.log(head.data);

        // If child exists, recursively
        // print it with indentation
        if (head.child) {
            process.stdout.write(" -&gt; ");
            printOriginalLinkedList(head.child, depth + 1);
        }

        // Add vertical bars
        // for each level in the grid
        if (head.next) {
            console.log("| ".repeat(depth));
        }
        head = head.next;
    }
}

// Create a linked list with child pointers
let head = new Node(5);
head.child = new Node(14);

head.next = new Node(10);
head.next.child = new Node(4);

head.next.next = new Node(12);
head.next.next.child = new Node(20);
head.next.next.child.child = new Node(13);

head.next.next.next = new Node(7);
head.next.next.next.child = new Node(17);

// Print the original
// linked list structure
console.log("Original linked list:");
printOriginalLinkedList(head);

// Flatten the linked list
// and print the flattened list
let flattened = flattenLinkedList(head);
console.log("\nFlattened linked list: ");
printLinkedList(flattened);

                            </code>
                        </pre>
</div>
<p><strong>Output: </strong>Original linked list:</p>
<p>5 -&gt; 14</p>
<p>10 -&gt; 4</p>
<p>12 -&gt; 20 -&gt; 13</p>
<p>7 -&gt; 17</p>
<p>Flattened linked list: 5 7 10 4 12 14 17 20 13 </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity:  O(N*M) + O(N*M log(N*M)) + O(N*M)</strong>where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.
                        <ol><li>O(N*M) as we traverse through all the elements, iterating through ‘N’ nodes along the next pointer and ‘M’ nodes along the child pointer.</li><li>O(N*M log(N*M)) as we sort the array containing N*M (total) elements.</li><li>O(N*M) as we reconstruct the linked list from the sorted array by iterating over the N*M elements of the array.</li></ol></p>
<p><strong>Space Complexity : O(N*M) + O(N*M)</strong>where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointer.
                        <ol><li>O(N*M) for storing all the elements in an additional array for sorting.</li><li>O(N*M) to reconstruct the linked list from the array after sorting</li></ol></p>
</p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>The time and space complexity of the previous approach can be optimised as we have not yet leveraged the given property that the child linked lists are sorted. We can eliminate the additional space and time complexity generated by sorting by using these sorted vertical linked lists.</p>
<p>Instead of collecting all node values into an array and then sorting them, we can merge these pre-sorted lists directly during the traversal, eliminating the need for additional sorting steps. This merge operation can be performed efficiently in place without allocating extra space for the combined linked list.</p>
<p>Read more about <a href="https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/"> Merging Sorted Linked Lists</a>. The base case ensures the termination of the recursion when there's either no list or only a single node remaining. The recursive function then handles the merging of the remaining lists after recursive flattening, creating a sorted flattened linked list.</p>
<p><strong>Algorithm</strong></p>
<p><strong>Base Case:</strong>
<ol><li>If the head is null, indicating the end of the list, it is already flattened or there are no further nodes. Return the head as it is.</li>
<li>Similarly, if there's no next node, meaning there's only one node left in the list, return the head as it is since it's already flattened.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/b7d415fe72d8d25842e7f2ec89988f19" width="439"/></figure>
<p><strong>Recursive Function:</strong>
                        The core of the algorithm lies in implementing a recursive function responsible for flattening the linked list. The function operates based on the principle that:
                        <ol><li>If the base conditions are not met, the function invokes itself recursively. This recursion continues until it reaches the base case, gradually flattening the linked list and merging the resultant with the previous node.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/b7b0b54fc8d3dce92e34a36f4c768233" width="439"/></figure>
<p><strong>Return:</strong>Following the recursion, the function returns the merged head of the new flattened linked list. This head marks the new head of the merged list starting from the end, which will now be merged with the present head.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/08c8afe8f34ff1ddc11b88d4bbceaeb8" width="439"/></figure>
<p><strong>Step 1: Establish Base Case Conditions</strong>
                        Check if the base case conditions are met, return the head if it is null or has no next pointer to head as there’s no further flattening or merging required.</p>
<p><strong>Step 2: Recursively Merge the List:</strong><ol><li>Initiate the recursive flattening process by calling `flattenLinkedList` on the next node (`head -&gt; next`).</li><li>The result of this recursive call is the head of the flattened and merged linked list.</li></ol></p>
<p><strong>Step 3: Merge Operations:</strong><ol><li>Inside the recursive call, call the merge function which takes care of the merging of these two lists based on their data values.</li><li>Read more about <a href="https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/">merging two linked lists</a> here.</li><li>The merged list is updated in the head, which is then returned as the result of the flattening process.</li></ol></p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
using namespace std;

class Node {
public:
    int data;
    Node *next;
    Node *child;

    // Constructors to initialize the
    // data, next, and child pointers
    Node() : data(0), next(nullptr), child(nullptr) {};
    Node(int x) : data(x), next(nullptr), child(nullptr) {}
    Node(int x, Node *nextNode, Node *childNode) : data(x), next(nextNode), child(childNode) {}
};

// Merges two linked lists in a particular
// order based on the data value
Node* merge(Node* list1, Node* list2){
    // Create a dummy node as a
    // placeholder for the result
    Node* dummyNode = new Node(-1);
    Node* res = dummyNode;

    // Merge the lists based on data values
    while(list1 != NULL &amp;&amp; list2 != NULL){
        if(list1-&gt;data &lt; list2-&gt;data){
            res-&gt;child = list1;
            res = list1;
            list1 = list1-&gt;child;
        }
        else{
            res-&gt;child = list2;
            res = list2;
            list2 = list2-&gt;child;
        }
        res-&gt;next = NULL;
    }

    // Connect the remaining
    // elements if any
    if(list1){
        res-&gt;child = list1;
    } else {
        res-&gt;child = list2;
    }

    // Break the last node's
    // link to prevent cycles
    if(dummyNode-&gt;child){
        dummyNode-&gt;child-&gt;next = NULL;
    }

    return dummyNode-&gt;child;
}

// Flattens a linked list with child pointers
Node* flattenLinkedList(Node* head){
    // If head is null or there 
    // is no next node, return head
    if(head == NULL || head-&gt;next == NULL){
        return head;
    }

    // Recursively flatten the
    // rest of the linked list
    Node* mergedHead = flattenLinkedList(head-&gt;next);
    head = merge(head, mergedHead);
    return head;
}

// Print the linked list by
// traversing through child pointers
void printLinkedList(Node* head) {
    while (head != nullptr) {
        cout &lt;&lt; head-&gt;data &lt;&lt; " ";
        head = head-&gt;child;
    }
    cout &lt;&lt; endl;
}

// Print the linked list
// in a grid-like structure
void printOriginalLinkedList(Node* head, int depth) {
    while (head != nullptr) {
        cout &lt;&lt; head-&gt;data;

        // If child exists, recursively
        // print it with indentation
        if (head-&gt;child) {
            cout &lt;&lt; " -&gt; ";
            printOriginalLinkedList(head-&gt;child, depth + 1);
        }

        // Add vertical bars
        // for each level in the grid
        if (head-&gt;next) {
            cout &lt;&lt; endl;
            for (int i = 0; i &lt; depth; ++i) {
                cout &lt;&lt; "| ";
            }
        }
        head = head-&gt;next;
    }
}

int main() {
    // Create a linked list with child pointers
    Node* head = new Node(5);
    head-&gt;child = new Node(14);
    
    head-&gt;next = new Node(10);
    head-&gt;next-&gt;child = new Node(4);
    
    head-&gt;next-&gt;next = new Node(12);
    head-&gt;next-&gt;next-&gt;child = new Node(20);
    head-&gt;next-&gt;next-&gt;child-&gt;child = new Node(13);
    
    head-&gt;next-&gt;next-&gt;next = new Node(7);
    head-&gt;next-&gt;next-&gt;next-&gt;child = new Node(17);

    // Print the original
    // linked list structure
    cout &lt;&lt; "Original linked list:" &lt;&lt; endl;
    printOriginalLinkedList(head, 0);

    // Flatten the linked list
    // and print the flattened list
    Node* flattened = flattenLinkedList(head);
    cout &lt;&lt; "\nFlattened linked list: ";
    printLinkedList(flattened);

    return 0;
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
class Node {
    int data;
    Node next;
    Node child;

    // Constructors to initialize the
    // data, next, and child pointers
    Node() {
        this.data = 0;
        this.next = null;
        this.child = null;
    }

    Node(int x) {
        this.data = x;
        this.next = null;
        this.child = null;
    }

    Node(int x, Node nextNode, Node childNode) {
        this.data = x;
        this.next = nextNode;
        this.child = childNode;
    }
}

public class FlattenLinkedList {
    // Merges two linked lists in a particular
    // order based on the data value
    public static Node merge(Node list1, Node list2) {
        // Create a dummy node as a
        // placeholder for the result
        Node dummyNode = new Node(-1);
        Node res = dummyNode;

        // Merge the lists based on data values
        while (list1 != null &amp;&amp; list2 != null) {
            if (list1.data &lt; list2.data) {
                res.child = list1;
                res = list1;
                list1 = list1.child;
            } else {
                res.child = list2;
                res = list2;
                list2 = list2.child;
            }
            res.next = null;
        }

        // Connect the remaining
        // elements if any
        if (list1 != null) {
            res.child = list1;
        } else {
            res.child = list2;
        }

        // Break the last node's
        // link to prevent cycles
        if (dummyNode.child != null) {
            dummyNode.child.next = null;
        }

        return dummyNode.child;
    }

    // Flattens a linked list with child pointers
    public static Node flattenLinkedList(Node head) {
        // If head is null or there
        // is no next node, return head
        if (head == null || head.next == null) {
            return head;
        }

        // Recursively flatten the
        // rest of the linked list
        Node mergedHead = flattenLinkedList(head.next);
        head = merge(head, mergedHead);
        return head;
    }

    // Print the linked list by
    // traversing through child pointers
    public static void printLinkedList(Node head) {
        while (head != null) {
            System.out.print(head.data + " ");
            head = head.child;
        }
        System.out.println();
    }

    // Print the linked list
    // in a grid-like structure
    public static void printOriginalLinkedList(Node head, int depth) {
        while (head != null) {
            System.out.print(head.data);

            // If child exists, recursively
            // print it with indentation
            if (head.child != null) {
                System.out.print(" -&gt; ");
                printOriginalLinkedList(head.child, depth + 1);
            }

            // Add vertical bars
            // for each level in the grid
            if (head.next != null) {
                System.out.println();
                for (int i = 0; i &lt; depth; ++i) {
                    System.out.print("| ");
                }
            }
            head = head.next;
        }
    }

    public static void main(String[] args) {
        // Create a linked list with child pointers
        Node head = new Node(5);
        head.child = new Node(14);

        head.next = new Node(10);
        head.next.child = new Node(4);

        head.next.next = new Node(12);
        head.next.next.child = new Node(20);
        head.next.next.child.child = new Node(13);

        head.next.next.next = new Node(7);
        head.next.next.next.child = new Node(17);

        // Print the original
        // linked list structure
        System.out.println("Original linked list:");
        printOriginalLinkedList(head, 0);

        // Flatten the linked list
        // and print the flattened list
        Node flattened = flattenLinkedList(head);
        System.out.print("\nFlattened linked list: ");
        printLinkedList(flattened);
    }
}


                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
class Node:
    def __init__(self, x=0, nextNode=None, childNode=None):
        self.data = x
        self.next = nextNode
        self.child = childNode

# Merges two linked lists in a particular
# order based on the data value
def merge(list1, list2):
    # Create a dummy node as a
    # placeholder for the result
    dummyNode = Node(-1)
    res = dummyNode

    # Merge the lists based on data values
    while list1 and list2:
        if list1.data &lt; list2.data:
            res.child = list1
            res = list1
            list1 = list1.child
        else:
            res.child = list2
            res = list2
            list2 = list2.child
        res.next = None

    # Connect the remaining
    # elements if any
    if list1:
        res.child = list1
    else:
        res.child = list2

    # Break the last node's
    # link to prevent cycles
    if dummyNode.child:
        dummyNode.child.next = None

    return dummyNode.child

# Flattens a linked list with child pointers
def flattenLinkedList(head):
    # If head is null or there 
    # is no next node, return head
    if not head or not head.next:
        return head

    # Recursively flatten the
    # rest of the linked list
    mergedHead = flattenLinkedList(head.next)
    head = merge(head, mergedHead)
    return head

# Print the linked list by
# traversing through child pointers
def printLinkedList(head):
    while head:
        print(head.data, end=" ")
        head = head.child
    print()

# Print the linked list
# in a grid-like structure
def printOriginalLinkedList(head, depth):
    while head:
        print(head.data, end="")

        # If child exists, recursively
        # print it with indentation
        if head.child:
            print(" -&gt; ", end="")
            printOriginalLinkedList(head.child, depth + 1)

        # Add vertical bars
        # for each level in the grid
        if head.next:
            print()
            print("| " * depth, end="")
        head = head.next

# Create a linked list with child pointers
head = Node(5)
head.child = Node(14)
head.next = Node(10)
head.next.child = Node(4)
head.next.next = Node(12)
head.next.next.child = Node(20)
head.next.next.child.child = Node(13)
head.next.next.next = Node(7)
head.next.next.next.child = Node(17)

# Print the original
# linked list structure
print("Original linked list:")
printOriginalLinkedList(head, 0)

# Flatten the linked list
# and print the flattened list
flattened = flattenLinkedList(head)
print("\nFlattened linked list: ", end="")
printLinkedList(flattened)

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
class Node {
    // Constructors to initialize the
    // data, next, and child pointers
    constructor() {
        this.data = 0;
        this.next = null;
        this.child = null;
    }

    constructor(x) {
        this.data = x;
        this.next = null;
        this.child = null;
    }

    constructor(x, nextNode, childNode) {
        this.data = x;
        this.next = nextNode;
        this.child = childNode;
    }
}

// Merges two linked lists in a
// particular order based on the data value
function merge(list1, list2) {
    // Create a dummy node as
    // a placeholder for the result
    let dummyNode = new Node(-1);
    let res = dummyNode;

    // Merge the lists based on data values
    while (list1 !== null &amp;&amp; list2 !== null) {
        if (list1.data &lt; list2.data) {
            res.child = list1;
            res = list1;
            list1 = list1.child;
        } else {
            res.child = list2;
            res = list2;
            list2 = list2.child;
        }
        res.next = null;
    }

    // Connect the remaining
    // elements if any
    if (list1) {
        res.child = list1;
    } else {
        res.child = list2;
    }

    // Break the last node's
    // link to prevent cycles
    if (dummyNode.child) {
        dummyNode.child.next = null;
    }

    return dummyNode.child;
}

// Flattens a linked list
// with child pointers
function flattenLinkedList(head) {
    // If head is null or there
    // is no next node, return head
    if (head === null || head.next === null) {
        return head;
    }

    // Recursively flatten the
    // rest of the linked list
    let mergedHead = flattenLinkedList(head.next);
    head = merge(head, mergedHead);
    return head;
}

// Print the linked list by
// traversing through child pointers
function printLinkedList(head) {
    while (head !== null) {
        console.log(head.data + " ");
        head = head.child;
    }
    console.log();
}

// Print the linked list
// in a grid-like structure
function printOriginalLinkedList(head, depth) {
    while (head !== null) {
        console.log(head.data);

        // If child exists, recursively
        // print it with indentation
        if (head.child) {
            console.log(" -&gt; ");
            printOriginalLinkedList(head.child, depth + 1);
        }

        // Add vertical bars for
        // each level in the grid
        if (head.next) {
            console.log();
            for (let i = 0; i &lt; depth; ++i) {
                console.log("| ");
            }
        }
        head = head.next;
    }
}

// Create a linked list
// with child pointers
let head = new Node(5);
head.child = new Node(14);
head.next = new Node(10);
head.next.child = new Node(4);
head.next.next = new Node(12);
head.next.next.child = new Node(20);
head.next.next.child.child = new Node(13);
head.next.next.next = new Node(7);
head.next.next.next.child = new Node(17);

// Print the original linked list structure
console.log("Original linked list:");
printOriginalLinkedList(head, 0);

// Flatten the linked list
// and print the flattened list
let flattened = flattenLinkedList(head);
console.log("\nFlattened linked list: ");
printLinkedList(flattened);

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Original linked list:</p>
<p>5 -&gt; 14</p>
<p>10 -&gt; 4</p>
<p>12 -&gt; 20 -&gt; 13</p>
<p>7 -&gt; 17</p>
<p>Flattened linked list: 5 7 10 4 12 14 17 20 13</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O( N*(2M) ) ~ O(2 N*M)</strong>where N is the length of the linked list along the next pointer and M is the length of the linked list along the child pointers.
                        <ol><li>The merge operation in each recursive call takes time complexity proportional to the length of the linked lists being merged as they have to iterate over the entire lists. Since the vertical depth of the linked lists is assume to be M, the time complexity for a single merge operation is proportional to O(2*M).</li><li>This operation operation is performed N number of times (to each and every node along the next pointer list) hence the resultant time complexity becomes: O(N* 2M).</li></ol></p>
<p><strong>Space Complexity : O(1)</strong> as this algorithm uses no external space or additional data structures to store values. But a recursive stack uses O(N) space to build the recursive calls for each node along the next pointer list.</p>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ykelywHJWLg?si=d1iCOH9d7HhC7_qx" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (active.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>