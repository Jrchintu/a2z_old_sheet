<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Construct A Binary Tree from Inorder and Preorder Traversal</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1;
            /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs);
            /* 5px */
            padding: var(--spacing-sm);
            /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.25rem;
            margin-bottom: 0.5rem;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5rem;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm);
            /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9rem;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1rem;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1rem;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm);
            /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1rem;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg);
            /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm);
            /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto;
                /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm);
                /* 10px */
            }

            h1 {
                font-size: 2rem;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Construct A Binary Tree from Inorder and Preorder Traversal</h1>
</header>
<article>
<p><strong>Problem Statement: </strong> Given the Preorder and Inorder traversal of a Binary Tree, construct the Unique Binary Tree represented by them.
</p>
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
				<span><strong>Input:</strong>Inorder: [40, 20, 50, 10, 60, 30], Preorder: [10, 20, 40, 50, 30, 60]

				</span>
				
				<span><strong>Output:</strong></span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/1b98309a682a7e82a41fe5b483c0e5b8" width="439"/></figure>
				<span><strong>Explanation: </strong>The unique Binary Tree hence created has inorder traversal: [40, 20, 50, 10, 60, 30] and preorder traversal: [10, 20, 40, 50, 30, 60].</span>
				
				
				<span><strong>Example 2:</strong></span>
				<span><strong>Input:</strong>Inorder: [9, 3, 15, 20, 7], Preorder: [3, 9, 20, 15, 7]
				</span>
				
				<span><strong>Output :</strong></span>
				<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/9c8414e635ef212991151fa12574d4ad" width="439"/></figure>
				<span><strong>Explanation: </strong> The unique Binary Tree hence created has inorder traversal:[9, 3, 15, 20, 7]and preorder traversal: [3, 9, 20, 15, 7]. </span>				
            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/construct-binary-tree-from-inorder-and-preorder-traversal_920539?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
<!--<div class="problem-buttons">
         Add Problem Link inside href 
        <a href="" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp"
                alt="leetcode">
        </a>
    </div>-->
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Donâ€™t jump directly to the solution, try it out
        yourself first. </em></p>
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
                Optimal Approach 
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                        Algorithm / Intuition
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->
<p>Before we dive into the algorithm, it's essential to grasp the significance of inorder and preorder traversals. Inorder traversal allows us to identify a node and its left and right subtrees, while preorder traversal ensures we always encounter the root node first. Leveraging these properties, we can uniquely construct a binary tree.
                    The core of our approach lies in a recursive algorithm that creates one node at a time. We locate this root node in the inorder traversal, which splits the array into the left and right subtrees.</p>
<p><figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/bd7a7ddbbe42c4dd52a3f07ffa79b83a" width="439"/></figure></p>
<p>The inorder array keeps getting divided into left and subtrees hence to avoid unnecessary array duplication, we use variables (inStart, inEnd) and (preStart, preEnd) on the inorder and preorder array respectively.
                    These variables effectively define the boundaries of the current subtree within the original inorder and preorder traversals.
                    Everytime we encounter the root of a subtree via preorder traversal, we locate its position in the inorder array to get the left and right subtrees.
                    So to save complexity on the linear look up, we employ a hashmap to store the index of each element in the inorder traversal. This transforms the search operation into a constant-time lookup.</p>
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1:</strong>Create an empty map to store the indices of elements in the inorder traversal. Iterate through each element in the inorder traversal and store its index in the map (inMap) using the element as the key and its index as the value.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/b7da890c788723fd6b8a2e0daae61c22" width="439"/></figure>
<p><strong>Step 2: </strong>Create a recursive helper function `buildTree` with the following parameters:
                    <ol><li>Preorder vector</li><li>Start index of preorder (preStart), initially set to 0</li><li>End index of preorder (preEnd), initially set to preorder.size() - 1.</li><li>Inorder vector</li><li>Start index of inorder (inStart), initially set to 0.</li><li>End index of inorder (inEnd), initially set to inorder.size() - 1.</li><li>Map for efficient root index lookup in the inorder traversal.</li></ol></p>
<p><strong>Step 3: Base Case: </strong>
                    Check if preStart is greater than preEnd or inStart is greater than inEnd. If true, return NULL, indicating an empty subtree/node.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ed8ab6fe48c01ecb7cf7f306fecd51fe" width="439"/></figure>
<p><strong>Step 4: </strong>
                    The root node for the current subtree is the first element in the preorder traversal (preorder[preStart]).
                	Find the index of this root node in the inorder traversal using the map (inMap[rootValue]). This is the rootIndex. </p>
<p><strong>Step 5: </strong>
                    Hence, the left subtree ranges from inStart to rootIndex. Subtracting these indexes gives us the leftSubtreeSize.</p>
<p><strong>Step 6: </strong>
                    TMake two recursive calls to buildTree to build the left and right subtrees:
                    For the left subtree:
                    <ol><li>Update preStart to preStart + 1 (moving to the next element in preorder)</li><li>Update preEnd to preStart + leftSubtreeSize (end of left subtree in preorder)</li><li>Update inEnd to rootIndex - 1 (end of left subtree in inorder)</li></ol>
                    For the right subtree:
                    <ol><li>Update preStart to preStart + leftSubtreeSize + 1 (moving to the next element after the left subtree)</li><li>Update preEnd to the original preEnd (end of right subtree in preorder)</li><li>Update inStart to rootIndex + 1 (start of right subtree in inorder)</li></ol> </p>
<p><strong>Step 7: </strong>
                    Return the root node constructed for the current subtree. The function returns the root of the entire binary tree constructed from the preorder and inorder traversals. </p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                        Code
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                            <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;

using namespace std;

// TreeNode structure
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
public:
    // Function to build a binary tree
    // from preorder and inorder traversals
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder){
        // Create a map to store indices
        // of elements in the inorder traversal
        map&lt;int, int&gt; inMap;
        
        // Populate the map with indices
        // of elements in the inorder traversal
        for(int i = 0; i &lt; inorder.size(); i++){
            inMap[inorder[i]] = i;
        }
        
        // Call the private helper function
        // to recursively build the tree
        TreeNode* root = buildTree(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1, inMap);
        
        return root;
    }

private:
    // Recursive helper function to build the tree
    TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, int preStart, int preEnd, 
            vector&lt;int&gt;&amp; inorder, int inStart, int inEnd, map&lt;int, int&gt;&amp; inMap){
                // Base case: If the start indices 
                // exceed the end indices, return NULL
                if(preStart &gt; preEnd || inStart &gt; inEnd){
                    return NULL;
                }
                
                // Create a new TreeNode with value
                // at the current preorder index
                TreeNode* root = new TreeNode(preorder[preStart]);
                
                // Find the index of the current root
                // value in the inorder traversal
                int inRoot = inMap[root-&gt;val];
                
                // Calculate the number of
                // elements in the left subtree
                int numsLeft = inRoot - inStart;
                
                // Recursively build the left subtree
                root-&gt;left = buildTree(preorder, preStart + 1, preStart + numsLeft, 
                                inorder, inStart, inRoot - 1, inMap);
                
                // Recursively build the right subtree
                root-&gt;right = buildTree(preorder, preStart + numsLeft + 1, preEnd, 
                                inorder, inRoot + 1, inEnd, inMap);
                
                // Return the current root node
                return root;
            }
};

// Function to print the
// inorder traversal of a tree
void printInorder(TreeNode* root){
    if(!root){
        return;
    }
    printInorder(root-&gt;left);
    cout &lt;&lt; root-&gt;val &lt;&lt; " ";
    printInorder(root-&gt;right);
}

// Function to print the 
// given vector
void printVector(vector&lt;int&gt;&amp;vec){
    for(int i = 0; i &lt; vec.size(); i++){
        cout &lt;&lt; vec[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}


int main() {
    vector&lt;int&gt; inorder = {9, 3, 15, 20, 7};
    vector&lt;int&gt; preorder = {3, 9, 20, 15, 7};
    
    cout &lt;&lt; "Inorder Vector: ";
    printVector(inorder);
    
    cout &lt;&lt; "Preorder Vector: ";
    printVector(preorder);
    
    Solution sol;

    TreeNode* root = sol.buildTree(preorder, inorder);
    
    cout &lt;&lt; "Inorder of Unique Binary Tree Created: "&lt;&lt; endl;
    printInorder(root);
    cout &lt;&lt; endl;


    return 0;
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                            <code class="language-java" lang="java">
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to build a binary tree
    // from preorder and inorder traversals
    public TreeNode buildTree(Vector&lt;Integer&gt; preorder, Vector&lt;Integer&gt; inorder) {
        // Create a map to store indices
        // of elements in the inorder traversal
        Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;();

        // Populate the map with indices
        // of elements in the inorder traversal
        for (int i = 0; i &lt; inorder.size(); i++) {
            inMap.put(inorder.get(i), i);
        }

        // Call the private helper function
        // to recursively build the tree
        TreeNode root = buildTree(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, inMap);

        return root;
    }

    // Recursive helper function to build the tree
    private TreeNode buildTree(Vector&lt;Integer&gt; preorder, int preStart, int preEnd,
            Vector&lt;Integer&gt; inorder, int inStart, int inEnd, Map&lt;Integer, Integer&gt; inMap) {
        // Base case: If the start indices
        // exceed the end indices, return null
        if (preStart &gt; preEnd || inStart &gt; inEnd) {
            return null;
        }

        // Create a new TreeNode with value
        // at the current preorder index
        TreeNode root = new TreeNode(preorder.get(preStart));

        // Find the index of the current root
        // value in the inorder traversal
        int inRoot = inMap.get(root.val);

        // Calculate the number of
        // elements in the left subtree
        int numsLeft = inRoot - inStart;

        // Recursively build the left subtree
        root.left = buildTree(preorder, preStart + 1, preStart + numsLeft,
                inorder, inStart, inRoot - 1, inMap);

        // Recursively build the right subtree
        root.right = buildTree(preorder, preStart + numsLeft + 1, preEnd,
                inorder, inRoot + 1, inEnd, inMap);

        // Return the current root node
        return root;
    }

    // Function to print the
    // inorder traversal of a tree
    private void printInorder(TreeNode root) {
        if (root != null) {
            printInorder(root.left);
            System.out.print(root.val + " ");
            printInorder(root.right);
        }
    }

    // Function to print the
    // given vector
    private void printVector(Vector&lt;Integer&gt; vec) {
        for (int i = 0; i &lt; vec.size(); i++) {
            System.out.print(vec.get(i) + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Vector&lt;Integer&gt; inorder = new Vector&lt;&gt;(java.util.Arrays.asList(9, 3, 15, 20, 7));
        Vector&lt;Integer&gt; preorder = new Vector&lt;&gt;(java.util.Arrays.asList(3, 9, 20, 15, 7));

        System.out.print("Inorder Vector: ");
        new Solution().printVector(inorder);

        System.out.print("Preorder Vector: ");
        new Solution().printVector(preorder);

        Solution sol = new Solution();
        TreeNode root = sol.buildTree(preorder, inorder);

        System.out.println("Inorder of Unique Binary Tree Created:");
        sol.printInorder(root);
        System.out.println();
    }
}
                            </code>
                        </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                            <code class="language-python" lang="python">
from typing import List

# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        # Create a map to store indices of elements in the inorder traversal
        inMap = {val: idx for idx, val in enumerate(inorder)}
        
        # Call the private helper function to recursively build the tree
        root = self._buildTree(preorder, 0, len(preorder)-1, inorder, 0, len(inorder)-1, inMap)
        
        return root

    def _buildTree(self, preorder, preStart, preEnd, inorder, inStart, inEnd, inMap):
        # Base case: If the start indices exceed the end indices, return None
        if preStart &gt; preEnd or inStart &gt; inEnd:
            return None

        # Create a new TreeNode with value at the current preorder index
        root = TreeNode(preorder[preStart])

        # Find the index of the current root value in the inorder traversal
        inRoot = inMap[root.val]

        # Calculate the number of elements in the left subtree
        numsLeft = inRoot - inStart

        # Recursively build the left subtree
        root.left = self._buildTree(preorder, preStart + 1, preStart + numsLeft,
                                    inorder, inStart, inRoot - 1, inMap)

        # Recursively build the right subtree
        root.right = self._buildTree(preorder, preStart + numsLeft + 1, preEnd,
                                     inorder, inRoot + 1, inEnd, inMap)

        # Return the current root node
        return root

# Function to print the inorder traversal of a tree
def printInorder(root):
    if not root:
        return
    printInorder(root.left)
    print(root.val, end=" ")
    printInorder(root.right)

# Function to print the given list
def printList(lst):
    for val in lst:
        print(val, end=" ")
    print()

# Main function
if __name__ == "__main__":
    inorder = [9, 3, 15, 20, 7]
    preorder = [3, 9, 20, 15, 7]
    
    print("Inorder List: ", end="")
    printList(inorder)
    
    print("Preorder List: ", end="")
    printList(preorder)
    
    sol = Solution()

    root = sol.buildTree(preorder, inorder)
    
    print("Inorder of Unique Binary Tree Created:")
    printInorder(root)
    print()
                           </code>
                        </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// TreeNode structure
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to build a binary tree
    // from preorder and inorder traversals
    buildTree(preorder, inorder) {
        // Create a map to store indices
        // of elements in the inorder traversal
        const inMap = new Map();

        // Populate the map with indices
        // of elements in the inorder traversal
        inorder.forEach((value, index) =&gt; {
            inMap.set(value, index);
        });

        // Call the private helper function
        // to recursively build the tree
        const root = this.buildTreeHelper(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1, inMap);

        return root;
    }

    // Recursive helper function to build the tree
    buildTreeHelper(preorder, preStart, preEnd, inorder, inStart, inEnd, inMap) {
        // Base case: If the start indices 
        // exceed the end indices, return null
        if (preStart &gt; preEnd || inStart &gt; inEnd) {
            return null;
        }

        // Create a new TreeNode with value
        // at the current preorder index
        const root = new TreeNode(preorder[preStart]);

        // Find the index of the current root
        // value in the inorder traversal
        const inRoot = inMap.get(root.val);

        // Calculate the number of
        // elements in the left subtree
        const numsLeft = inRoot - inStart;

        // Recursively build the left subtree
        root.left = this.buildTreeHelper(preorder, preStart + 1, preStart + numsLeft, inorder, inStart, inRoot - 1, inMap);

        // Recursively build the right subtree
        root.right = this.buildTreeHelper(preorder, preStart + numsLeft + 1, preEnd, inorder, inRoot + 1, inEnd, inMap);

        // Return the current root node
        return root;
    }
}

// Function to print the
// inorder traversal of a tree
function printInorder(root) {
    if (!root) {
        return;
    }
    printInorder(root.left);
    console.log(root.val + " ");
    printInorder(root.right);
}

// Function to print the 
// given array
function printArray(arr) {
    arr.forEach((value) =&gt; {
        console.log(value + " ");
    });
    console.log();
}

// Main function
function main() {
    const inorder = [9, 3, 15, 20, 7];
    const preorder = [3, 9, 20, 15, 7];

    console.log("Inorder Array: ");
    printArray(inorder);

    console.log("Preorder Array: ");
    printArray(preorder);

    const sol = new Solution();

    const root = sol.buildTree(preorder, inorder);

    console.log("Inorder of Unique Binary Tree Created: ");
    printInorder(root);
    console.log();
}

// Call the main function
main();

                            </code>
                        </pre>
</div>
<p>
<strong>Output</strong> 
                      	Inorder Vector: 9 3 15 20 7, Preorder Vector: 3 9 20 15 7 ,Inorder of Unique Binary Tree Created: 9 3 15 20 7 
                    </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                        Complexity Analysis
                    </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<!-- Insert Time and Space Complexity  Here -->
<p><strong>Time Complexity: O(N)</strong>   where N is the number of nodes in the Binary Tree. This is because each node of the Binary Tree is visited once.</p>
<p><strong>Space Complexity: O(N)</strong>    where N is the number of nodes in the Binary Tree. The inorder hashmap to store the inorder array for fast lookup takes up space proportional to the input nodes.
					An auxiliary stack space ~ O(H) where H is the height of the Binary Tree is used. This is the stack space used to build the tree recursively. In the case of a skewed tree, the height of the tree will be H ~ N hence the worst case auxiliary space is O(N).</p>
</p>
</details>
</div>
</details>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<!-- Insert iframe embed Link of Youtube Video-->
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/aZNaLrVebKQ?si=WDGyqV0gpU7YfmvE" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>