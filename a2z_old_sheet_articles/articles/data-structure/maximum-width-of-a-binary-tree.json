{
    "dislikes": 12,
    "video": "",
    "publishedOn": "Sun Mar 24 2024 22:09:27 GMT+0530 (India Standard Time)",
    "slug": "maximum-width-of-a-binary-tree",
    "aid": "1495",
    "title": "Maximum Width of a Binary Tree",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/maximum-width-of-bt",
    "topics": [
        {
            "topic-id": "binary-tree",
            "topic-title": "Binary Tree"
        },
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "recursion",
            "topic-title": "Recursion"
        }
    ],
    "content": "<p><strong>Problem Statement: </strong> Given a Binary Tree, return its maximum width.\nThe maximum width of a Binary Tree is the maximum diameter among all its levels. The width or diameter of a level is the number of nodes between the leftmost and rightmost nodes.\n</p>\n\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 3 5 6 -1 9\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image1-G6fRojB1\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output:</strong> Maximum Width: 4</span>\n\t\t\t\t<span><strong>Explanation: </strong>Level 3 is the widest level of the Binary Tree and whose end-to-end width is 4 comprising of nodes: {5, 6, null, 9}.</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image2-19cwHJ7A\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Example 2:</strong></span>\n\t\t\t\t<span><strong>Input:</strong>Binary Tree: 1 2 3 5\n\t\t\t\t</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image3-OKdFA41j\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\t\t\t\t<span><strong>Output :</strong> Maximum Width: 2</span>\n\t\t\t\t<span><strong>Explanation: </strong>Level 2 is the widest level of the Binary Tree and whose end-to-end width is comprised of nodes: {2, 3}.</span>\n\t\t\t\t<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image4-sgej8Jgg\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\n\t\t\t\t\n            </pre>\n        </div>\n    </details>\n</div>\n\n<!-- This is Practice Section-->\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n        <!-- Add Problem Link inside href -->\n        <a href=\"https://www.codingninjas.com/studio/problems/maximum-width-in-binary-tree_763671?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\"\n                alt=\"code-studio\">\n        </a>\n    </div>\n    <!--<div class=\"problem-buttons\">\n         Add Problem Link inside href \n        <a href=\"\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://cdn.iconscout.com/icon/free/png-256/free-leetcode-3521542-2944960.png?f=webp\"\n                alt=\"leetcode\">\n        </a>\n    </div>-->\n</div>\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out\n        yourself first. </em></p>\n\n\n<div id=\"brute-force-approach\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Optimal Approach \n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                </path>\n            </svg>\n        </summary>\n        <div class=\"common-drops\">\n            <details class=\"secondary-details\" open=\"\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Algorithm / Intuition\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"approach-algorithm\">\n                    <!-- Insert Algorithm / Intuition of Brute Force Apporach Here -->\n                    <p>To determine the maximum width of a tree, an effective strategy would be to assign and identify indexes for the leftmost and rightmost nodes at each level. Using these indexes, we can calculate the width for each level by subtracting the index of the leftmost node from that of the rightmost node.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image5-HkC08iI9\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    <p>Start by assigning an index to the root node as 0. For each level, the left child gets an index equal to 2 * parent index, and the right child gets an index equal to 2 * parent index + 1. \n                    Using a level order traversal, we use the leftmost and rightmost nodes at each level and using their indices, get the width at that level. Keep track of the maximum width encountered during the traversal. Whenever a wider level is found, update the maximum width.</p>\n                    <p><figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image6-fTMhqbX8\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure></p>\n                    \n                    <p><strong>Algorithm:</strong></p>\n                    <p><strong>Step 1:</strong>Initialize a variable `ans` to store the maximum width. If the root is null, return 0 as the width of an empty tree is zero.</p>\n                    \n                    <p><strong>Step 2:</strong> Create a queue to perform level-order traversal and each element of this queue would be a pair containing a node and its vertical index. Push the root node and its position (initially 0) into the queue.</p>\n                   \n\n                    <p><strong>Step 3: </strong>\n                    While the queue is not empty, perform the following steps:\n                    <ol><li>Get the number of nodes at the current level (size).</li><li>Get the position of the front node in the current level which is the leftmost minimum index at that level.</li><li>Initialize variables first and last to store the first and last positions of nodes in the current level.</li></ol></p>\n                                                                           \n                    <p><strong>Step 4: Backtracking: </strong>\n                    For each node in the current level:\n                    <ol><li>Calculate the current position relative to the minimum position in the level.</li><li>Get the current node (node) from the front of the queue.</li><li>If this is the first node in the level, update the first variable.</li><li>If this is the last node in the level, update the last variable.</li><li>Enqueue the left child of the current node with index: 2 x current index - 1.</li><li>Enqueue the right child of the current node with index: 2 x current index + 1.</li></ol></p>\n                    <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/maximum-width-image7-GXWM5BMQ\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                    <p><strong>Step 5:</strong> Update the maximum width (ans) by calculating the difference between the first and last positions, and adding 1.</p>\n                    <p><strong>Step 6:</strong> Repeat the level-order traversal until all levels are processed. The final value of `ans` represents the maximum width of the binary tree, return it.</p>\n                    \n                </div>\n            </details>\n            <details class=\"code-section secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Code\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <div class=\"code-tabs\">\n                    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                    <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                    <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                        xmlns=\"http://www.w3.org/2000/svg\">\n                        <path\n                            d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                        </path>\n                    </svg>\n                </div>\n                <div class=\"code-content\">\n                    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\n\nusing namespace std;\n\n// TreeNode structure\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\n\n\nclass Solution {\npublic:\n    // Function widthOfBinaryTree to find the \n    // maximum width of the Binary Tree\n    int widthOfBinaryTree(TreeNode* root) {\n        // If the root is null,\n        // the width is zero\n        if (!root) {\n            return 0;\n        }\n\n        // Initialize a variable 'ans'\n        // to store the maximum width\n        int ans = 0;\n\n        // Create a queue to perform level-order\n        // traversal, where each element is a pair\n        // of TreeNode* and its position in the level\n        queue&lt;pair&lt;TreeNode*, int&gt;&gt; q;\n        // Push the root node and its\n        // position (0) into the queue\n        q.push({root, 0});\n\n        // Perform level-order traversal\n        while (!q.empty()) {\n            // Get the number of\n            // nodes at the current level\n            int size = q.size();\n            // Get the position of the front\n            // node in the current level\n            int mmin = q.front().second;\n            \n            // Store the first and last positions \n            // of nodes in the current level\n            int first, last;\n\n            // Process each node\n            // in the current level\n            for (int i = 0; i &lt; size; i++) {\n                // Calculate current position relative\n                // to the minimum position in the level\n                int cur_id = q.front().second - mmin;\n                // Get the current node\n                TreeNode* node = q.front().first;\n                // Pop the front node from the queue\n                q.pop();\n\n                // If this is the first node in the level, \n                // update the 'first' variable\n                if (i == 0) {\n                    first = cur_id;\n                }\n\n                // If this is the last node in the level,\n                // update the 'last' variable\n                if (i == size - 1) {\n                    last = cur_id;\n                }\n\n                // Enqueue the left child of the \n                // current node with its position\n                if (node-&gt;left) {\n                    q.push({node-&gt;left, cur_id * 2 + 1});\n                }\n\n                // Enqueue the right child of the\n                // current node with its position\n                if (node-&gt;right) {\n                    q.push({node-&gt;right, cur_id * 2 + 2});\n                }\n            }\n\n            // Update the maximum width by calculating\n            // the difference between the first and last\n            // positions, and adding 1\n            ans = max(ans, last - first + 1);\n        }\n\n        // Return the maximum\n        // width of the binary tree\n        return ans;\n    }\n};\n\n\nint main() {\n    TreeNode* root = new TreeNode(3);\n    root-&gt;left = new TreeNode(5);\n    root-&gt;right = new TreeNode(1);\n    root-&gt;left-&gt;left = new TreeNode(6);\n    root-&gt;left-&gt;right = new TreeNode(2);\n    root-&gt;right-&gt;left = new TreeNode(0);\n    root-&gt;right-&gt;right = new TreeNode(8);\n    root-&gt;left-&gt;right-&gt;left = new TreeNode(7);\n    root-&gt;left-&gt;right-&gt;right = new TreeNode(4);\n\n    Solution sol;\n\n    int maxWidth = sol.widthOfBinaryTree(root);\n\n    cout &lt;&lt; &quot;Maximum width of the binary tree is: &quot;\n                        &lt;&lt; maxWidth &lt;&lt; endl;\n\n    return 0;\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block \" data-lang=\"java\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"java\" class=\"language-java\">\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n// TreeNode structure\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) {\n        val = x;\n        left = null;\n        right = null;\n    }\n}\n\npublic class Solution {\n    // Function widthOfBinaryTree to find the\n    // maximum width of the Binary Tree\n    public int widthOfBinaryTree(TreeNode root) {\n        // If the root is null,\n        // the width is zero\n        if (root == null) {\n            return 0;\n        }\n\n        // Initialize a variable 'ans'\n        // to store the maximum width\n        int ans = 0;\n\n        // Create a queue to perform level-order\n        // traversal, where each element is a pair\n        // of TreeNode and its position in the level\n        Queue&lt;Pair&lt;TreeNode, Integer&gt;&gt; q = new LinkedList&lt;&gt;();\n        // Push the root node and its\n        // position (0) into the queue\n        q.add(new Pair&lt;&gt;(root, 0));\n\n        // Perform level-order traversal\n        while (!q.isEmpty()) {\n            // Get the number of\n            // nodes at the current level\n            int size = q.size();\n            // Get the position of the front\n            // node in the current level\n            int mmin = q.peek().getValue();\n\n            // Store the first and last positions\n            // of nodes in the current level\n            int first, last;\n\n            // Process each node\n            // in the current level\n            for (int i = 0; i &lt; size; i++) {\n                // Calculate current position relative\n                // to the minimum position in the level\n                int cur_id = q.peek().getValue() - mmin;\n                // Get the current node\n                TreeNode node = q.peek().getKey();\n                // Poll the front node from the queue\n                q.poll();\n\n                // If this is the first node in the level,\n                // update the 'first' variable\n                if (i == 0) {\n                    first = cur_id;\n                }\n\n                // If this is the last node in the level,\n                // update the 'last' variable\n                if (i == size - 1) {\n                    last = cur_id;\n                }\n\n                // Enqueue the left child of the\n                // current node with its position\n                if (node.left != null) {\n                    q.add(new Pair&lt;&gt;(node.left, cur_id * 2 + 1));\n                }\n\n                // Enqueue the right child of the\n                // current node with its position\n                if (node.right != null) {\n                    q.add(new Pair&lt;&gt;(node.right, cur_id * 2 + 2));\n                }\n            }\n\n            // Update the maximum width by calculating\n            // the difference between the first and last\n            // positions, and adding 1\n            ans = Math.max(ans, last - first + 1);\n        }\n\n        // Return the maximum\n        // width of the binary tree\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(1);\n        root.left.left = new TreeNode(6);\n        root.left.right = new TreeNode(2);\n        root.right.left = new TreeNode(0);\n        root.right.right = new TreeNode(8);\n        root.left.right.left = new TreeNode(7);\n        root.left.right.right = new TreeNode(4);\n\n        Solution sol = new Solution();\n\n        int maxWidth = sol.widthOfBinaryTree(root);\n\n        System.out.println(&quot;Maximum width of the binary tree is: &quot; + maxWidth);\n    }\n}\n                            </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"python\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"python\" class=\"language-python\">\nfrom queue import Queue\nfrom typing import Optional, Tuple\n\n\n# TreeNode structure\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nclass Solution:\n    def widthOfBinaryTree(self, root: Optional[TreeNode]) -&gt; int:\n        # If the root is null,\n        # the width is zero\n        if not root:\n            return 0\n\n        # Initialize a variable 'ans'\n        # to store the maximum width\n        ans = 0\n\n        # Create a queue to perform level-order\n        # traversal, where each element is a tuple\n        # of TreeNode and its position in the level\n        q = Queue()\n        # Push the root node and its\n        # position (0) into the queue\n        q.put((root, 0))\n\n        # Perform level-order traversal\n        while not q.empty():\n            # Get the number of\n            # nodes at the current level\n            size = q.qsize()\n            # Get the position of the front\n            # node in the current level\n            mmin = q.queue[0][1]\n\n            # Store the first and last positions\n            # of nodes in the current level\n            first, last = None, None\n\n            # Process each node\n            # in the current level\n            for i in range(size):\n                # Calculate current position relative\n                # to the minimum position in the level\n                cur_id = q.queue[i][1] - mmin\n                # Get the current node\n                node = q.queue[i][0]\n\n                # If this is the first node in the level,\n                # update the 'first' variable\n                if i == 0:\n                    first = cur_id\n\n                # If this is the last node in the level,\n                # update the 'last' variable\n                if i == size - 1:\n                    last = cur_id\n\n                # Enqueue the left child of the\n                # current node with its position\n                if node.left:\n                    q.put((node.left, cur_id * 2 + 1))\n\n                # Enqueue the right child of the\n                # current node with its position\n                if node.right:\n                    q.put((node.right, cur_id * 2 + 2))\n\n            # Update the maximum width by calculating\n            # the difference between the first and last\n            # positions, and adding 1\n            ans = max(ans, last - first + 1)\n\n        # Return the maximum\n        # width of the binary tree\n        return ans\n\n\ndef main():\n    root = TreeNode(3)\n    root.left = TreeNode(5)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(8)\n    root.left.right.left = TreeNode(7)\n    root.left.right.right = TreeNode(4)\n\n    sol = Solution()\n\n    maxWidth = sol.widthOfBinaryTree(root)\n\n    print(f&quot;Maximum width of the binary tree is: {maxWidth}&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    main()\n                           </code>\n                        </pre>\n                    </div>\n                    <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// TreeNode structure\nclass TreeNode {\n    constructor(x) {\n        this.val = x;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass Solution {\n    // Function widthOfBinaryTree to find the \n    // maximum width of the Binary Tree\n    widthOfBinaryTree(root) {\n        // If the root is null,\n        // the width is zero\n        if (!root) {\n            return 0;\n        }\n\n        // Initialize a variable 'ans'\n        // to store the maximum width\n        let ans = 0;\n\n        // Create a queue to perform level-order\n        // traversal, where each element is a pair\n        // of TreeNode and its position in the level\n        let q = [{ node: root, position: 0 }];\n\n        // Perform level-order traversal\n        while (q.length &gt; 0) {\n            // Get the number of\n            // nodes at the current level\n            let size = q.length;\n            // Get the position of the front\n            // node in the current level\n            let mmin = q[0].position;\n\n            // Store the first and last positions \n            // of nodes in the current level\n            let first, last;\n\n            // Process each node\n            // in the current level\n            for (let i = 0; i &lt; size; i++) {\n                // Calculate current position relative\n                // to the minimum position in the level\n                let cur_id = q[0].position - mmin;\n                // Get the current node\n                let node = q[0].node;\n                // Dequeue the front node from the queue\n                q.shift();\n\n                // If this is the first node in the level, \n                // update the 'first' variable\n                if (i === 0) {\n                    first = cur_id;\n                }\n\n                // If this is the last node in the level,\n                // update the 'last' variable\n                if (i === size - 1) {\n                    last = cur_id;\n                }\n\n                // Enqueue the left child of the \n                // current node with its position\n                if (node.left) {\n                    q.push({ node: node.left, position: cur_id * 2 + 1 });\n                }\n\n                // Enqueue the right child of the\n                // current node with its position\n                if (node.right) {\n                    q.push({ node: node.right, position: cur_id * 2 + 2 });\n                }\n            }\n\n            // Update the maximum width by calculating\n            // the difference between the first and last\n            // positions, and adding 1\n            ans = Math.max(ans, last - first + 1);\n        }\n\n        // Return the maximum\n        // width of the binary tree\n        return ans;\n    }\n}\n\n// Sample usage\nlet root = new TreeNode(3);\nroot.left = new TreeNode(5);\nroot.right = new TreeNode(1);\nroot.left.left = new TreeNode(6);\nroot.left.right = new TreeNode(2);\nroot.right.left = new TreeNode(0);\nroot.right.right = new TreeNode(8);\nroot.left.right.left = new TreeNode(7);\nroot.left.right.right = new TreeNode(4);\n\nlet sol = new Solution();\nlet maxWidth = sol.widthOfBinaryTree(root);\n\nconsole.log(&quot;Maximum width of the binary tree is: &quot; + maxWidth);\n\n                            </code>\n                        </pre>\n                    </div>\n                    <p>\n                       <strong>Output</strong> \n                      \tMaximum width of the binary tree is: 4\n                    </p>\n                </div>\n            </details>\n            <details class=\"secondary-details\">\n                <summary class=\"secondary-summary\">\n                    <span>\n                        Complexity Analysis\n                    </span>\n                    <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                        <path\n                            d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                        </path>\n                    </svg>\n                </summary>\n                <p>\n                    <!-- Insert Time and Space Complexity  Here -->\n                    <p><strong>Time Complexity: O(N)</strong>  where N is the number of nodes in the binary tree. Each node of the binary tree is enqueued and dequeued exactly once, hence all nodes need to be processed and visited. Processing each node takes constant time operations which contributes to the overall linear time complexity.</p>\n\n\t\t\t\t\t<p><strong>Space Complexity: O(N)</strong>   where N is the number of nodes in the binary tree. In the worst case, the queue has to hold all the nodes of the last level of the binary tree, the last level could at most hold N/2 nodes hence the space complexity of the queue is proportional to O(N).</p>\n\n                </p>\n            </details>\n        </div>\n    </details>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n            <!-- Insert iframe embed Link of Youtube Video-->\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/ZbybYvcVLks?si=5ss8abZ8bBP3lS4q\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n        </div>\n    </details>\n</div>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>",
    "category_tag": "data-structure",
    "likes": 89,
    "preview": "Problem Statement: Given a Binary Tree, return its maximum width. The maximum width of a Binary Tree is the maximum diameter among all its levels. The width or diameter of a level is the number of..."
}