{
    "dislikes": 5,
    "video": "ACzkVtewUYA",
    "publishedOn": "Sun Mar 24 2024 22:11:36 GMT+0530 (India Standard Time)",
    "slug": "number-of-provinces",
    "aid": "2117",
    "title": "Number of Provinces",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/number-of-provinces",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement: </strong>Given an undirected graph with V vertices. We say two vertices u and v belong to a single province if there is a path from u to v or v to u. Your task is to find the number of provinces.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Pre-req:</strong> Connected Components, Graph traversal techniques</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Input:</strong>\n<strong><img width=\"386\" height=\"113\" src=\"https://lh4.googleusercontent.com/Vwi5EtntYRGiFEYNhOgiQvlBxmD7RklrbgeseG7kjf1sYVDmcdTtr3HtklVbhdvvmNeQomW7wcbnOgVnYtcWcYoMeld67HC_-HCg5weQktMUY3gFN5koWPhoXONLtSerDkJBK6F7BegkK-CN1iwGSNM\"></strong>\n<strong>Output: </strong>3</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>A province is a group of directly or indirectly connected cities and no other cities outside of the group. Considering the above example, we can go from 1 to 2 as well as to 3, from every other node in a province we can go to each other. As we cannot go from 2 to 4 so it is not a province. We know about both the traversals, Breadth First Search (BFS) and Depth First Search (DFS). We can use any of the traversals to solve this problem because a traversal algorithm visits all the nodes in a graph. In any traversal technique, we have one starting node and it traverses all the nodes in the graph. Suppose there is an \u2018N\u2019 number of provinces so we need to call the traversal algorithm \u2018N\u2018 times, i.e., there will be \u2018N\u2019 starting nodes. So, we just need to figure out the number of starting nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>The algorithm steps are as follows:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>We need a visited array initialized to 0, representing the nodes that are not visited.</li><li>Run the for loop looping from 0 to N, and call the DFS for the first unvisited node.&nbsp;</li><li>DFS function call will make sure that it starts the DFS call from that unvisited node, and visits all the nodes that are in that province, and at the same time, it will also mark them as visited.&nbsp;</li><li>Since the nodes traveled in a traversal will be marked as visited, they will no further be called for any further DFS traversal.&nbsp;</li><li>Keep repeating these steps, for every node that you find unvisited, and visit the entire province.&nbsp;</li><li>Add a counter variable to count the number of times the DFS function is called, as in this way we can count the total number of starting nodes, which will give us the number of provinces.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p><img width=\"596.5000000000001\" height=\"220\" src=\"https://lh4.googleusercontent.com/jQjg6Vzx6W1we4GWxsZJ1_sgV7odSLLEnZx-cgb7wDwNkDUUTqo5Nh_ntd3aZ8dGEtpg-A6QQ1BgfCbNaA7GCQx-w0dQD-vVOcdFw1TX7p2lO7Fpjgz-Hs7-Fi1CPRS1qmhQtDdu-G11H8PBzMsD9pk\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"602\" height=\"483\" src=\"https://lh6.googleusercontent.com/U-cUtfolQyssIPc7MUp-_6myMN5ZeCvSJ0Tvo0iLKeYm1qQvbTb5j3-rIQcn_Klk8KrglrOfPYuctDU9JMeeCN_fTJ1hYPk9L6YAeqb2hkowwQcY9ILgrt4V3WmIfBei7WhUt2H1Ouc9fCZZd87ptkU\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution {\n  private: \n    // dfs traversal function \n    void dfs(int node, vector&lt;int&gt; adjLs[], int vis[]) {\n        // mark the more as visited\n        vis[node] = 1; \n        for(auto it: adjLs[node]) {\n            if(!vis[it]) {\n                dfs(it, adjLs, vis); \n            }\n        }\n    }\n  public:\n    int numProvinces(vector&lt;vector&lt;int&gt;&gt; adj, int V) {\n        vector&lt;int&gt; adjLs[V]; \n        \n        // to change adjacency matrix to list \n        for(int i = 0;i&lt;V;i++) {\n            for(int j = 0;j&lt;V;j++) {\n                // self nodes are not considered\n                if(adj[i][j] == 1 &amp;&amp; i != j) {\n                    adjLs[i].push_back(j); \n                    adjLs[j].push_back(i); \n                }\n            }\n        }\n        int vis[V] = {0}; \n        int cnt = 0; \n        for(int i = 0;i&lt;V;i++) {\n            // if the node is not visited\n            if(!vis[i]) {\n                // counter to count the number of provinces \n                cnt++;\n               dfs(i, adjLs, vis); \n            }\n        }\n        return cnt; \n        \n    }\n};\n\nint main() {\n    \n    vector&lt;vector&lt;int&gt;&gt; adj\n    {\n        {1, 0, 1},\n        {0, 1, 0},\n        {1, 0, 1}\n    };\n\n        \n    Solution ob;\n    cout &lt;&lt; ob.numProvinces(adj,3) &lt;&lt; endl;\n        \n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> 2</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N) + O(V+2E), Where O(N) is for outer loop and inner loop runs in total a single DFS over entire graph, and we know DFS takes a time of O(V+2E).&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N) + O(N),Space for recursion stack space and visited array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass Solution {\n    // dfs traversal function \n    private static void dfs(int node, \n       ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjLs , \n       int vis[]) {\n        vis[node] = 1; \n        for(Integer it: adjLs.get(node)) {\n            if(vis[it] == 0) {\n                dfs(it, adjLs, vis); \n            }\n        }\n    }\n    static int numProvinces(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj, int V) {\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjLs = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); \n        for(int i = 0;i&lt;V;i++) {\n            adjLs.add(new ArrayList&lt;Integer&gt;()); \n        }\n        \n        // to change adjacency matrix to list \n        for(int i = 0;i&lt;V;i++) {\n            for(int j = 0;j&lt;V;j++) {\n                // self nodes are not considered \n                if(adj.get(i).get(j) == 1 &amp;&amp; i != j) {\n                    adjLs.get(i).add(j); \n                    adjLs.get(j).add(i); \n                }\n            }\n        }\n        int vis[] = new int[V]; \n        int cnt = 0; \n        for(int i = 0;i&lt;V;i++) {\n            if(vis[i] == 0) {\n               cnt++;\n               dfs(i, adjLs, vis); \n            }\n        }\n        return cnt; \n    }\n    public static void main(String[] args)\n    {\n\n        // adjacency matrix \n        ArrayList&lt;ArrayList&lt;Integer&gt; &gt; adj = new ArrayList&lt;ArrayList&lt;Integer&gt; &gt;();\n\n        adj.add(new ArrayList&lt;Integer&gt;());\n        adj.get(0).add(0, 1);\n        adj.get(0).add(1, 0);\n        adj.get(0).add(2, 1);\n        adj.add(new ArrayList&lt;Integer&gt;());\n        adj.get(1).add(0, 0);\n        adj.get(1).add(1, 1);\n        adj.get(1).add(2, 0);\n        adj.add(new ArrayList&lt;Integer&gt;());\n        adj.get(2).add(0, 1);\n        adj.get(2).add(1, 0);\n        adj.get(2).add(2, 1);\n                \n        Solution ob = new Solution();\n        System.out.println(ob.numProvinces(adj,3));\n    }\n};\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong> 2</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N) + O(V+2E), Where O(N) is for outer loop and inner loop runs in total a single DFS over entire graph, and we know DFS takes a time of O(V+2E).&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity: </strong>O(N) + O(N),Space for recursion stack space and visited array.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/vanshika-singh-ba6b15157\" target=\"_blank\" rel=\"noreferrer noopener\">Vanshika Singh Gour</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->",
    "category_tag": "data-structure",
    "likes": 138,
    "preview": "Problem Statement: Given an undirected graph with V vertices. We say two vertices u and v belong to a single province if there is a path from u to v or v to u. Your task is to find the number of pr..."
}