{
    "dislikes": 3,
    "video": "",
    "publishedOn": "Tue May 14 2024 21:05:48 GMT+0530 (India Standard Time)",
    "slug": "sort-a-linked-list",
    "aid": "2388",
    "tuf_plus": "",
    "title": "Sort a Linked List",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "linked-list",
            "topic-title": "Linked List"
        },
        {
            "topic-id": "sorting",
            "topic-title": "Sorting"
        }
    ],
    "category_tag": "linked-list",
    "likes": 114,
    "preview": "Problem Statement: Given a linked list, sort its nodes based on the data value in them. Return the head of the sorted linked list. Examples Example 1: Input:Linked List: 3 4 2 1 5 Output:Sorted Lis...",
    "content": "<p><strong>Problem Statement: </strong>Given a linked list, sort its nodes based on the data value in them. Return the head of the sorted linked list.\n</p>\n\n\n<!-- This is Examples Drop-Down -->\n<div id=\"article_examples\">\n    <details class=\"article_example_details\">\n        <summary class=\"article_example_summary\">\n            <span><strong>\n                    Examples\n                </strong>\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"atricle_example_content\">\n            <pre class=\"wp-block-preformatted\">\n                <span><strong>Example 1:</strong></span>\n\n                <span><strong>Input:</strong>Linked List: 3 4 2 1 5</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image1-SVzQwFC2\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n               \n                <span><strong>Output:</strong>Sorted List: 1 2 3 4 5</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image2-4MNr_86P\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Explanation: </strong> The input linked list when sorted from [3, 4, 2, 1, 5] results in a linked list with values: [1, 2, 3, 4, 5].</span>\n                \n                <br>\n                <span><strong>Example 2:</strong></span>\n                <span><strong>Input:</strong>List: 40 20 60 10 50 30</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image3-Xk537-Jx\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                \n                \n                <span><strong>Output: </strong>Sorted List: 10 20 30 40 50 60</span>\n                <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image4-6AI-3g6r\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                <span><strong>Explanation: </strong> The input linked list when sorted from [40, 20, 60, 10, 50, 30] results in a linked list with values: [10, 20, 30, 40, 50, 60].</span>\n                \n            </pre>\n        </div>\n    </details>\n</div>\n\n\n<!-- This is Practice Section\n<div class=\"practice\">\n    <span><strong>Practice: </strong></span>\n    <div class=\"problem-buttons\">\n\n         \n        <a href=\"https://www.codingninjas.com/studio/problems/power-of-numbers_8157729?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf\" target=\"_blank\" rel=\"noopener\">\n            <span>Solve Problem</span>\n            <img src=\"https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga\" alt=\"code-studio\">\n        </a>\n    </div>\n    \n</div>-->\n\n\n<p class=\"new-disclaimer\"><strong><em>Disclaimer</em></strong>: <em>Don\u2019t jump directly to the solution, try it out yourself first. </em></p>\n\n\n<!-- This is Approaches Drop-Down -->\n<div class=\"dsa_article_dropdown_approachs \">\n\n    <!-- Approach - 1 Starts from here -->\n    <div id=\"brute-force-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    <!-- Change Name Here -->\n                   Brute Force Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        \n                        <p>A naive solution could be converting the linked list into an array, sorting the array, and then creating a new linked list from the sorted array's values. </p>\n\n                        <h4>Algorithm </h4>\n                        <p><strong>Step 1:</strong>Create an empty array to store the node values. Iterate the linked list using a temp pointer to the head and push the value of temp node into the array. Move temp to the next node.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image5-eaug51Kz\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 2: </strong> Sort the array containing node values in ascending order.</p> \n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image6-aizWoxNO\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p><strong>Step 3: </strong>\n                        Convert the sorted array back to a linked list reassigning the values from the sorted array and overwriting them sequentially according to their order in the array.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image7-fEnGRR_x\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n\n                        \n                        \n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt; \n\nusing namespace std;\n\n// Node class represents a\n// node in a linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;\n    \n    // Pointer to the next node in the list\n    Node* next;\n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node* next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to nullptr\n    Node(int data1) {\n        data = data1;\n        next = nullptr;\n    }\n};\n\n\n\n// Function to sort a linked list\n// using Brute Force approach\nNode* sortLL(Node* head){\n    // Create a vector to\n    // store node values\n    vector&lt;int&gt; arr;\n    \n    // Temporary pointer to\n    // traverse the linked list\n    Node* temp = head;\n    \n    // Traverse the linked list and\n    // store node values in the vector\n    while(temp!=NULL){\n        arr.push_back(temp-&gt;data);\n        temp = temp-&gt;next;\n    }\n    \n    // Sort the array\n    // containing node values\n    sort(arr.begin(), arr.end());\n    \n    // Reassign sorted values to\n    // the linked list nodes\n    temp = head;\n    for(int i = 0; i &lt; arr.size(); i++){\n        // Update the node's data\n        // with the sorted values\n        temp-&gt;data = arr[i]; \n        // Move to the next node\n        temp = temp-&gt;next; \n    }\n    \n    // Return the head of the\n    // sorted linked list\n    return head; \n}\n\n// Function to print the linked list\nvoid printLinkedList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        // Print the data of the current node\n        cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;; \n        // Move to the next node\n        temp = temp-&gt;next; \n    }\n    cout &lt;&lt; endl;\n}\n\n\nint main() {\n    // Linked List: 3 2 5 4 1\n    Node* head = new Node(3);\n    head-&gt;next = new Node(2);\n    head-&gt;next-&gt;next = new Node(5);\n    head-&gt;next-&gt;next-&gt;next = new Node(4);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);\n\n    cout &lt;&lt; &quot;Original Linked List: &quot;;\n    printLinkedList(head);\n\n    // Sort the linked list\n    head = sortLL(head);\n\n    cout &lt;&lt; &quot;Sorted Linked List: &quot;;\n    printLinkedList(head);\n\n    return 0;\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\nimport java.util.*;\n\n// Node class represents a\n// node in a linked list\nclass Node {\n    // Data stored in the node\n    int data;\n    \n    // Pointer to the next node in the list\n    Node next;\n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to null\n    Node(int data1) {\n        data = data1;\n        next = null;\n    }\n}\n\n// Class to perform operations on Linked List\npublic class Main {\n\n    // Function to sort a linked list\n    // using Brute Force approach\n    public static Node sortLL(Node head){\n        // Create a list to\n        // store node values\n        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();\n        \n        // Temporary pointer to\n        // traverse the linked list\n        Node temp = head;\n        \n        // Traverse the linked list and\n        // store node values in the list\n        while(temp != null){\n            arr.add(temp.data);\n            temp = temp.next;\n        }\n        \n        // Sort the list\n        // containing node values\n        Collections.sort(arr);\n        \n        // Reassign sorted values to\n        // the linked list nodes\n        temp = head;\n        for(int i = 0; i &lt; arr.size(); i++){\n            // Update the node's data\n            // with the sorted values\n            temp.data = arr.get(i); \n            // Move to the next node\n            temp = temp.next; \n        }\n        \n        // Return the head of the\n        // sorted linked list\n        return head; \n    }\n\n    // Function to print the linked list\n    public static void printLinkedList(Node head) {\n        Node temp = head;\n        while (temp != null) {\n            // Print the data of the current node\n            System.out.print(temp.data + &quot; &quot;); \n            // Move to the next node\n            temp = temp.next; \n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        // Linked List: 3 2 5 4 1\n        Node head = new Node(3);\n        head.next = new Node(2);\n        head.next.next = new Node(5);\n        head.next.next.next = new Node(4);\n        head.next.next.next.next = new Node(1);\n\n        System.out.print(&quot;Original Linked List: &quot;);\n        printLinkedList(head);\n\n        // Sort the linked list\n        head = sortLL(head);\n\n        System.out.print(&quot;Sorted Linked List: &quot;);\n        printLinkedList(head);\n    }\n}\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n# Node class represents a\n# node in a linked list\nclass Node:\n    def __init__(self, data, next_node=None):\n        # Data stored in the node\n        self.data = data\n        # Pointer to the next node in the list\n        self.next = next_node\n\n\n# Function to sort a linked list\n# using Brute Force approach\ndef sort_LL(head):\n    # Create a list to\n    # store node values\n    arr = []\n    \n    # Temporary pointer to\n    # traverse the linked list\n    temp = head\n    \n    # Traverse the linked list and\n    # store node values in the list\n    while temp is not None:\n        arr.append(temp.data)\n        temp = temp.next\n    \n    # Sort the list\n    # containing node values\n    arr.sort()\n    \n    # Reassign sorted values to\n    # the linked list nodes\n    temp = head\n    for i in range(len(arr)):\n        # Update the node's data\n        # with the sorted values\n        temp.data = arr[i]\n        # Move to the next node\n        temp = temp.next\n    \n    # Return the head of the\n    # sorted linked list\n    return head\n\n\n# Function to print the linked list\ndef print_linked_list(head):\n    temp = head\n    while temp is not None:\n        # Print the data of the current node\n        print(temp.data, end=&quot; &quot;)\n        # Move to the next node\n        temp = temp.next\n    print()\n\n\n# Linked List: 3 2 5 4 1\nhead = Node(3)\nhead.next = Node(2)\nhead.next.next = Node(5)\nhead.next.next.next = Node(4)\nhead.next.next.next.next = Node(1)\n\nprint(&quot;Original Linked List: &quot;, end=&quot;&quot;)\nprint_linked_list(head)\n\n# Sort the linked list\nhead = sort_LL(head)\n\nprint(&quot;Sorted Linked List: &quot;, end=&quot;&quot;)\nprint_linked_list(head)\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n// Node class represents a\n// node in a linked list\nclass Node {\n    constructor(data, next = null) {\n        // Data stored in the node\n        this.data = data;\n        // Pointer to the next node in the list\n        this.next = next;\n    }\n}\n\n// Function to sort a linked list\n// using Brute Force approach\nfunction sortLL(head) {\n    // Create an array to\n    // store node values\n    let arr = [];\n    \n    // Temporary pointer to\n    // traverse the linked list\n    let temp = head;\n    \n    // Traverse the linked list and\n    // store node values in the array\n    while (temp !== null) {\n        arr.push(temp.data);\n        temp = temp.next;\n    }\n    \n    // Sort the array\n    // containing node values\n    arr.sort((a, b) =&gt; a - b);\n    \n    // Reassign sorted values to\n    // the linked list nodes\n    temp = head;\n    for (let i = 0; i &lt; arr.length; i++) {\n        // Update the node's data\n        // with the sorted values\n        temp.data = arr[i]; \n        // Move to the next node\n        temp = temp.next; \n    }\n    \n    // Return the head of the\n    // sorted linked list\n    return head; \n}\n\n// Function to print the linked list\nfunction printLinkedList(head) {\n    let temp = head;\n    while (temp !== null) {\n        // Print the data of the current node\n        console.log(temp.data + &quot; &quot;); \n        // Move to the next node\n        temp = temp.next; \n    }\n    console.log();\n}\n\n// Linked List: 3 2 5 4 1\nlet head = new Node(3);\nhead.next = new Node(2);\nhead.next.next = new Node(5);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(1);\n\nconsole.log(&quot;Original Linked List: &quot;);\nprintLinkedList(head);\n\n// Sort the linked list\nhead = sortLL(head);\n\nconsole.log(&quot;Sorted Linked List: &quot;);\nprintLinkedList(head);\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p><strong>Output: </strong>Original Linked List: 3 2 5 4 1 </p>\n                        <p>Sorted Linked List: 1 2 3 4 5</p>\n\n\n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N) + O(N log N) + O(N)</strong>where N is the number of nodes in the linked list.\n                        <ol><li>O(N) to traverse the linked list and store its data values in an additional array.</li><li>O(N log N) to sort the array containing the node values.</li><li>O(N) to traverse the sorted array and convert it into a new linked list.</li></ol></p>\n\n                        <p><strong>Space Complexity : O(N)</strong>where N is the number of nodes in the linked list as we have to store the values of all nodes in the linked list in an additional array to sort them.</p>\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n    <!-- Approach - 1 Ends here -->\n\n\n    <!-- Approach - 2 Starts from here -->\n\n    <div id=\"optimal-approach\">\n        <details>\n            <summary class=\"main-summary\">\n                <span>\n                    Optimal Approach \n                </span>\n                <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                    <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                    </path>\n                </svg>\n            </summary>\n            <div class=\"common-drops\">\n                <details class=\"secondary-details\" open=\"\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Algorithm / Intuition\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"approach-algorithm\">\n                        \n                        <p>Instead of using an external array to store node values, we can employ a sorting algorithm without using any extra space. An in-place sorting algorithm like Merge Sort or Quick Sort adapted for linked lists can achieve this.</p>\n                        <p>Read more about Merge Sort here!<a href=\"https://takeuforward.org/data-structure/merge-sort-algorithm/\">Merge Sort Algorithm</a>. A modified version of merge sort can operate directly on the linked list without using any additional space. This algorithm would divide the linked list into halves recursively until single nodes remain. These sorted halves of the linked list are merged back together in a sorted order.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image8-A2KNvjix\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>\n                        <p>This approach employs the divide-and-conquer strategy:\n                        <ol><li>Divides the linked list into smaller parts until they become trivial to sort (single node or empty list).</li><li>Merges and sorts the divided parts while combining them back together.</li></ol></p>\n                        <p><strong>Algorithm</strong></p>\n                        \n                        <p><strong>Step 1: Base Case</strong>\n                        If the linked list contains zero or one element, it is already sorted. Return the head node.</p>\n                                                                     \n                        <p><strong>Step 2: Split the List</strong>Find the middle of the linked list using a slow and a fast pointer. Read more about this approach here!<a href=\"https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/\">Middle Element in Linked List</a>. Split the linked list into two halves at the middle node. The two halves will be left and right.</p>\n                        <figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image9-8ZmHhigk\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>                              \n                        <p><strong>Step 3: Recursion</strong>Recursively apply merge sort to both halves obtained in the previous step. This step continues dividing the linked list until there's only one node in each half.</p>\n\n                        <p><strong>Step 4: Merge Sorted Lists</strong>Merge the sorted halves obtained from the recursive calls into a single sorted linked list. Compare the nodes from both halves and rearrange them to form a single sorted list. Update the head pointer to the beginning of the newly sorted list.</p>           \n                        <!--<figure class=\"wp-block-image size-full is-resized\"><img src=\"https://static.takeuforward.org/content/sort-a-linkedlist-image9-8ZmHhigk\" alt=\"\" class=\"wp-image-8107\" width=\"439\" height=\"286\"/></figure>-->\n                        <p><strong>Step 5: Return</strong>Once the merging is complete, return the head of the sorted linked list.</p>\n                    </div>\n                </details>\n                <details class=\"code-section secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Code\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <div class=\"code-tabs\">\n                        <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n                        <button class=\"code-tab\" data-lang=\"java\">Java</button>\n                        <button class=\"code-tab\" data-lang=\"python\">Python</button>\n                        <button class=\"code-tab\" data-lang=\"javascript\">JavaScript</button>\n                        <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\"\n                            xmlns=\"http://www.w3.org/2000/svg\">\n                            <path\n                                d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n                            </path>\n                        </svg>\n                    </div>\n                    <div class=\"code-content\">\n                        <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"cpp\" class=\"language-cpp\">\n#include &lt;iostream&gt;\n#include &lt;bits/stdc++.h&gt; \n\nusing namespace std;\n\n// Node class represents a\n// node in a linked list\nclass Node {\npublic:\n    // Data stored in the node\n    int data;\n    \n    // Pointer to the next node in the list\n    Node* next;\n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node* next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to nullptr\n    Node(int data1) {\n        data = data1;\n        next = nullptr;\n    }\n};\n\n// Function to merge two sorted linked lists\nNode* mergeTwoSortedLinkedLists(Node* list1, Node* list2) {\n    // Create a dummy node to serve\n    // as the head of the merged list\n    Node* dummyNode = new Node(-1);\n    Node* temp = dummyNode;\n\n    // Traverse both lists simultaneously\n    while (list1 != nullptr &amp;&amp; list2 != nullptr) {\n        // Compare elements of both lists and\n        // link the smaller node to the merged list\n        if (list1-&gt;data &lt;= list2-&gt;data) {\n            temp-&gt;next = list1;\n            list1 = list1-&gt;next;\n        } else {\n            temp-&gt;next = list2;\n            list2 = list2-&gt;next;\n        }\n        // Move the temporary pointer\n        // to the next node\n        temp = temp-&gt;next; \n    }\n\n    // If any list still has remaining\n    // elements, append them to the merged list\n    if (list1 != nullptr) {\n        temp-&gt;next = list1;\n    } else {\n        temp-&gt;next = list2;\n    }\n    // Return the merged list starting \n    // from the next of the dummy node\n    return dummyNode-&gt;next;\n}\n\n// Function to find the middle of a linked list\nNode* findMiddle(Node* head){\n    // If the list is empty or has only one node\n    // the middle is the head itself\n    if (head == nullptr || head-&gt;next == nullptr) {\n        return head;\n    }\n\n    // Initializing slow and fast pointers\n    Node* slow = head;\n    Node* fast = head-&gt;next;\n\n    // Move the fast pointer twice as fast as the slow pointer\n    // When the fast pointer reaches the end, the slow pointer\n    // will be at the middle\n    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next-&gt;next;\n    }\n\n    return slow;\n}\n\n// Function to perform merge sort on a linked list\nNode* sortLL(Node* head){\n    // Base case: if the list is empty or has only one node\n    // it is already sorted, so return the head\n    if (head == nullptr || head-&gt;next == nullptr) {\n        return head;\n    }\n    \n    // Find the middle of the list using the findMiddle function\n    Node* middle = findMiddle(head);\n    \n    // Divide the list into two halves\n    Node* right = middle-&gt;next;\n    middle-&gt;next = nullptr;\n    Node* left = head;\n    \n    // Recursively sort the left and right halves\n    left = sortLL(left);\n    right = sortLL(right);\n    \n    // Merge the sorted halves using the mergeTwoSortedLinkedLists function\n    return mergeTwoSortedLinkedLists(left, right);\n}\n\n// Function to print the linked list\nvoid printLinkedList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        // Print the data of the current node\n        cout &lt;&lt; temp-&gt;data &lt;&lt; &quot; &quot;; \n        // Move to the next node\n        temp = temp-&gt;next; \n    }\n    cout &lt;&lt; endl;\n}\n\n\nint main() {\n    // Linked List: 3 2 5 4 1\n    Node* head = new Node(3);\n    head-&gt;next = new Node(2);\n    head-&gt;next-&gt;next = new Node(5);\n    head-&gt;next-&gt;next-&gt;next = new Node(4);\n    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);\n\n    cout &lt;&lt; &quot;Original Linked List: &quot;;\n    printLinkedList(head);\n\n    // Sort the linked list\n    head = sortLL(head);\n\n    cout &lt;&lt; &quot;Sorted Linked List: &quot;;\n    printLinkedList(head);\n\n    return 0;\n}\n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block \" data-lang=\"java\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"java\" class=\"language-java\">\n// Node class represents a\n// node in a linked list\nclass Node {\n    // Data stored in the node\n    int data;\n    \n    // Pointer to the next node in the list\n    Node next;\n\n    // Constructor with both data and\n    // next node as parameters\n    Node(int data1, Node next1) {\n        data = data1;\n        next = next1;\n    }\n\n    // Constructor with only data as a\n    // parameter, sets next to null\n    Node(int data1) {\n        data = data1;\n        next = null;\n    }\n}\n\n// Function to merge two sorted linked lists\nNode mergeTwoSortedLinkedLists(Node list1, Node list2) {\n    // Create a dummy node to serve\n    // as the head of the merged list\n    Node dummyNode = new Node(-1);\n    Node temp = dummyNode;\n\n    // Traverse both lists simultaneously\n    while (list1 != null &amp;&amp; list2 != null) {\n        // Compare elements of both lists and\n        // link the smaller node to the merged list\n        if (list1.data &lt;= list2.data) {\n            temp.next = list1;\n            list1 = list1.next;\n        } else {\n            temp.next = list2;\n            list2 = list2.next;\n        }\n        // Move the temporary pointer\n        // to the next node\n        temp = temp.next; \n    }\n\n    // If any list still has remaining\n    // elements, append them to the merged list\n    if (list1 != null) {\n        temp.next = list1;\n    } else {\n        temp.next = list2;\n    }\n    // Return the merged list starting \n    // from the next of the dummy node\n    return dummyNode.next;\n}\n\n// Function to find the middle of a linked list\nNode findMiddle(Node head){\n    // If the list is empty or has only one node\n    // the middle is the head itself\n    if (head == null || head.next == null) {\n        return head;\n    }\n\n    // Initializing slow and fast pointers\n    Node slow = head;\n    Node fast = head.next;\n\n    // Move the fast pointer twice\n    // as fast as the slow pointer\n    while (fast != null &amp;&amp; fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    // When the fast pointer reaches the end,\n    // the slow pointer will be at the middle\n    return slow;\n}\n\n// Function to perform merge sort on a linked list\nNode sortLL(Node head){\n    // Base case: if the list is empty or\n    // has only one node, it is already\n    // sorted, so return the head\n    if (head == null || head.next == null) {\n        return head;\n    }\n    \n    // Find the middle of the list\n    // using the findMiddle function\n    Node middle = findMiddle(head);\n    \n    // Divide the list into two halves\n    Node right = middle.next;\n    middle.next = null;\n    Node left = head;\n    \n    // Recursively sort the left and right halves\n    left = sortLL(left);\n    right = sortLL(right);\n    \n    // Merge the sorted halves using the\n    // mergeTwoSortedLinkedLists function\n    return mergeTwoSortedLinkedLists(left, right);\n}\n\n// Function to print the linked list\nvoid printLinkedList(Node head) {\n    Node temp = head;\n    while (temp != null) {\n        // Print the data of the current node\n        System.out.print(temp.data + &quot; &quot;); \n        // Move to the next node\n        temp = temp.next; \n    }\n    System.out.println();\n}\n\npublic static void main(String[] args) {\n    // Linked List: 3 2 5 4 1\n    Node head = new Node(3);\n    head.next = new Node(2);\n    head.next.next = new Node(5);\n    head.next.next.next = new Node(4);\n    head.next.next.next.next = new Node(1);\n\n    System.out.print(&quot;Original Linked List: &quot;);\n    printLinkedList(head);\n\n    // Sort the linked list\n    head = sortLL(head);\n\n    System.out.print(&quot;Sorted Linked List: &quot;);\n    printLinkedList(head);\n}\n\n                                </code>\n                            </pre>\n                        </div>\n                        <div class=\"code-block\" data-lang=\"python\">\n                            <pre class=\"wp-block-code\">\n                                <code lang=\"python\" class=\"language-python\">\n                     \n# Node class represents a\n# node in a linked list\nclass Node:\n    def __init__(self, data1, next1=None):\n        # Data stored in the node\n        self.data = data1\n        \n        # Pointer to the next node in the list\n        self.next = next1\n\n# Function to merge two sorted linked lists\ndef mergeTwoSortedLinkedLists(list1, list2):\n    # Create a dummy node to serve\n    # as the head of the merged list\n    dummyNode = Node(-1)\n    temp = dummyNode\n\n    # Traverse both lists simultaneously\n    while list1 is not None and list2 is not None:\n        # Compare elements of both lists and\n        # link the smaller node to the merged list\n        if list1.data &lt;= list2.data:\n            temp.next = list1\n            list1 = list1.next\n        else:\n            temp.next = list2\n            list2 = list2.next\n        # Move the temporary pointer\n        # to the next node\n        temp = temp.next \n\n    # If any list still has remaining\n    # elements, append them to the merged list\n    if list1 is not None:\n        temp.next = list1\n    else:\n        temp.next = list2\n    \n    # Return the merged list starting \n    # from the next of the dummy node\n    return dummyNode.next\n\n# Function to find the middle of a linked list\ndef findMiddle(head):\n    # If the list is empty or has only one node\n    # the middle is the head itself\n    if head is None or head.next is None:\n        return head\n\n    # Initializing slow and fast pointers\n    slow = head\n    fast = head.next\n\n    # Move the fast pointer twice as\n    # fast as the slow pointer\n\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        \n    # When the fast pointer reaches the end,\n    # the slow pointer will be at the middle\n\n    return slow\n\n# Function to perform merge sort on a linked list\ndef sortLL(head):\n    # Base case: if the list is empty\n    # or has only one node it is already \n    # sorted, so return the head\n    if head is None or head.next is None:\n        return head\n\n    # Find the middle of the list\n    # using the findMiddle function\n    middle = findMiddle(head)\n\n    # Divide the list into two halves\n    right = middle.next\n    middle.next = None\n    left = head\n\n    # Recursively sort the left and right halves\n    left = sortLL(left)\n    right = sortLL(right)\n\n    # Merge the sorted halves using\n    # the mergeTwoSortedLinkedLists function\n    return mergeTwoSortedLinkedLists(left, right)\n\n# Function to print the linked list\ndef printLinkedList(head):\n    temp = head\n    while temp is not None:\n        # Print the data of the current node\n        print(temp.data, end=&quot; &quot;)\n        # Move to the next node\n        temp = temp.next\n    print()\n\n# Linked List: 3 2 5 4 1\nhead = Node(3)\nhead.next = Node(2)\nhead.next.next = Node(5)\nhead.next.next.next = Node(4)\nhead.next.next.next.next = Node(1)\n\nprint(&quot;Original Linked List: &quot;, end=&quot;&quot;)\nprintLinkedList(head)\n\n# Sort the linked list\nhead = sortLL(head)\n\nprint(&quot;Sorted Linked List: &quot;, end=&quot;&quot;)\nprintLinkedList(head)\n\n                                </code>\n                            </pre>\n                        </div>\n                         <div class=\"code-block\" data-lang=\"javascript\">\n                        <pre class=\"wp-block-code\">\n                            <code lang=\"javascript\" class=\"language-javascript\">\n // Node class represents a node in a linked list\nclass Node {\n    constructor(data, nextNode = null) {\n        this.data = data;\n        this.next = nextNode;\n    }\n}\n\n// Function to merge two sorted linked lists\nfunction mergeTwoSortedLinkedLists(list1, list2) {\n    // Create a dummy node to serve\n    // as the head of the merged list\n    let dummyNode = new Node(-1);\n    let temp = dummyNode;\n\n    // Traverse both lists simultaneously\n    while (list1 !== null &amp;&amp; list2 !== null) {\n        // Compare elements of both lists and\n        // link the smaller node to the merged list\n        if (list1.data &lt;= list2.data) {\n            temp.next = list1;\n            list1 = list1.next;\n        } else {\n            temp.next = list2;\n            list2 = list2.next;\n        }\n        // Move the temporary pointer to the next node\n        temp = temp.next;\n    }\n\n    // If any list still has remaining elements,\n    // append them to the merged list\n    if (list1 !== null) {\n        temp.next = list1;\n    } else {\n        temp.next = list2;\n    }\n    // Return the merged list starting\n    // from the next of the dummy node\n    return dummyNode.next;\n}\n\n// Function to find the middle of a linked list\nfunction findMiddle(head) {\n    // If the list is empty or has only one node,\n    // the middle is the head itself\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    // Initializing slow and fast pointers\n    let slow = head;\n    let fast = head.next;\n\n    // Move the fast pointer twice\n    // as fast as the slow pointer\n    \n    while (fast !== null &amp;&amp; fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    \n    // When the fast pointer reaches the end,\n    // the slow pointer will be at the middle\n    return slow;\n}\n\n// Function to perform merge sort on a linked list\nfunction sortLL(head) {\n    // Base case: if the list is empty or has only\n    // one node, it is already sorted, so return the head\n    if (head === null || head.next === null) {\n        return head;\n    }\n\n    // Find the middle of the list\n    // using the findMiddle function\n    let middle = findMiddle(head);\n\n    // Divide the list into two halves\n    let right = middle.next;\n    middle.next = null;\n    let left = head;\n\n    // Recursively sort the left and right halves\n    left = sortLL(left);\n    right = sortLL(right);\n\n    // Merge the sorted halves using\n    // the mergeTwoSortedLinkedLists function\n    return mergeTwoSortedLinkedLists(left, right);\n}\n\n// Function to print the linked list\nfunction printLinkedList(head) {\n    let temp = head;\n    while (temp !== null) {\n        // Print the data of the current node\n        console.log(temp.data + &quot; &quot;);\n        // Move to the next node\n        temp = temp.next;\n    }\n    console.log(&quot;\\n&quot;);\n}\n\n// Creating and sorting the linked list in JavaScript\nlet head = new Node(3);\nhead.next = new Node(2);\nhead.next.next = new Node(5);\nhead.next.next.next = new Node(4);\nhead.next.next.next.next = new Node(1);\n\nconsole.log(&quot;Original Linked List: &quot;);\nprintLinkedList(head);\n\n// Sort the linked list\nhead = sortLL(head);\n\nconsole.log(&quot;Sorted Linked List: &quot;);\nprintLinkedList(head);\n\n                            </code>\n                        </pre>\n                        </div>\n                        <p>\n                             <strong>Output: </strong>Original Linked List: 3 2 5 4 1 </p>\n                             <p>Sorted Linked List: 1 2 3 4 5 \n</p>\n\n                                               \n                    </div>\n                </details>\n                <details class=\"secondary-details\">\n                    <summary class=\"secondary-summary\">\n                        <span>\n                            Complexity Analysis\n                        </span>\n                        <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                            <path\n                                d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\">\n                            </path>\n                        </svg>\n                    </summary>\n                    <p>\n                        <p><strong>Time Complexity: O(N log N)</strong>where N is the number of nodes in the linked list. Finding the middle node of the linked list requires traversing it linearly taking O(N) time complexity and to reach the individual nodes of the list, it has to be split log N times (continuously halve the list until we have individual elements).</p>\n                        <p><strong>Space Complexity : O(1)</strong> as no additional data structures or space is allocated for storage during the merging process. However, space proportional to O(log N) stack space is required for the recursive calls. THe maximum recursion depth of log N height is occupied on the call stack.\n</p>\n\n\n                    </p>\n                </details>\n            </div>\n        </details>\n    </div>\n</div>\n\n<!-- This is Video Explination Drop-Down -->\n<div class=\"dsa_article_youtube_video\" id=\"dsa_article_video_explanation\">\n    <details>\n        <summary class=\"main-summary\">\n            <span>\n                Video Explanation\n            </span>\n            <svg class=\"arrow-svg opacity-75\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 20 20\">\n                <path d=\"M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z\"></path>\n            </svg>\n        </summary>\n        <div class=\"yt-video-wrapper\">\n          <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/8ocB7a_c-Cc?si=0Oe5J6V6egH6bHxH\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\n        </div>\n    </details>\n</div>\n\n<script src=\"https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js\"></script>\n\n<blockquote class=\"wp-block-quote\">\n    Special thanks to <strong><a href=\"https://www.linkedin.com/in/gauri-tomar-005048268\">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\"> please check out this article</a></strong>\n</blockquote>\n\n\n<script>\n\n    const codeSections = document.querySelectorAll('.code-section');\n\n    // Get last selected language from localStorage or set default value\n    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';\n\n    codeSections.forEach((section, sectionIndex) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n        const copyBtn = section.querySelector('.copy-btn');\n\n        codeTabs.forEach((tab) => {\n            tab.addEventListener('click', () => {\n                codeTabs.forEach((t) => {\n                    t.classList.remove('dsa_article_code_active');\n                });\n                tab.classList.add('dsa_article_code_active');\n\n                const lang = tab.dataset.lang;\n                const activeBlock = section.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                codeBlocks.forEach((block) => {\n                    if (block === activeBlock) {\n                        block.classList.add('dsa_article_code_active');\n                    } else {\n                        block.classList.remove('dsa_article_code_active');\n                    }\n                });\n\n                // Update last selected language for all sections and store in localStorage\n                lastSelectedLanguage = lang;\n                localStorage.setItem('lastSelectedLanguage', lang);\n                codeSections.forEach((otherSection, otherIndex) => {\n                    if (otherIndex !== sectionIndex) {\n                        const otherTabs = otherSection.querySelectorAll('.code-tab');\n                        otherTabs.forEach((otherTab) => {\n                            if (otherTab.dataset.lang === lang) {\n                                otherTab.classList.add('dsa_article_code_active');\n                            } else {\n                                otherTab.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang=\"${lang}\"]`);\n                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');\n                        otherCodeBlocks.forEach((block) => {\n                            if (block === otherActiveBlock) {\n                                block.classList.add('dsa_article_code_active');\n                            } else {\n                                block.classList.remove('dsa_article_code_active');\n                            }\n                        });\n                    }\n                });\n            });\n        });\n\n        // Handle copy button click event\n        copyBtn.addEventListener('click', () => {\n            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');\n            navigator.clipboard.writeText(activeBlock.innerText);\n            copyBtn.classList.add('dsa_article_code_active');\n            setTimeout(() => {\n                copyBtn.classList.remove('dsa_article_code_active');\n            }, 1000);\n        });\n    });\n\n    // Set initial state of the tabs\n    codeSections.forEach((section) => {\n        const codeTabs = section.querySelectorAll('.code-tab');\n        const codeBlocks = section.querySelectorAll('.code-block');\n\n        codeTabs.forEach((tab) => {\n            if (tab.dataset.lang === lastSelectedLanguage) {\n                tab.classList.add('dsa_article_code_active');\n            } else {\n                tab.classList.remove('dsa_article_code_active');\n            }\n        });\n\n        codeBlocks.forEach((block) => {\n            if (block.dataset.lang === lastSelectedLanguage) {\n                block.classList.add('dsa_article_code_active');\n            } else {\n                block.classList.remove('dsa_article_code_active');\n            }\n        });\n    });\n</script>\n<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css\">\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js\"></script>\n<script src=\"index.js\"></script>\n<script>hljs.highlightAll();</script>"
}