<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Article Documentation</title>
<style>
        /* Define CSS Variables for colors and spacing for better maintenance */
        :root {
            /* Color Palette (UI/UX Unchanged) */
            --color-text-primary: #333;
            --color-text-secondary: #2c3e50;
            --color-link-primary: #3498db;
            --color-link-hover: #2980b9;
            --color-bg-body: #fdfdfd;
            --color-bg-container: #fff;
            --color-bg-light: #f9f9f9;
            --color-bg-lighter-hover: #f1f1f1; /* Used for summary hover */
            --color-border-light: #e7e7e7;
            --color-border-header: #ecf0f1;

            /* Code Block Colors */
            --color-code-bg: #2d2d2d;
            --color-code-text: #f8f8f2;

            /* Standardized Spacing */
            --spacing-xs: 5px;
            --spacing-sm: 10px;
            --spacing-md: 15px;
            --spacing-lg: 20px;
        }

        /* ---------------------------------- */
        /* 1. Base Structure & Global Styles */
        /* ---------------------------------- */

        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: var(--color-text-primary);
            background-color: var(--color-bg-body);
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: var(--spacing-xs); /* 5px */
            padding: var(--spacing-sm); /* 10px */
            background-color: var(--color-bg-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* ---------------------------------- */
        /* 2. Typography & Links */
        /* ---------------------------------- */

        /* Main article title */
        h1 {
            color: var(--color-text-secondary);
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid var(--color-border-header);
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Improve styling for links */
        a {
            color: var(--color-link-primary);
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: var(--color-link-hover);
            text-decoration: underline;
        }

        /* ---------------------------------- */
        /* 3. Media Elements (Images & Video) */
        /* ---------------------------------- */

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            margin: 1em auto;
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness (16:9) */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            margin: 1.5em auto;
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Adjustments for video inside a details block */
        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* ---------------------------------- */
        /* 4. Code Blocks */
        /* ---------------------------------- */

        /* Basic code block styling */
        pre {
            background-color: var(--color-code-bg);
            color: var(--color-code-text);
            padding: var(--spacing-sm); /* 10px */
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Ensure the highlighted code block fills the <pre> area */
        pre code.hljs {
            display: block;
            background: none;
            padding: 0;
            margin: 0;
        }

        /* ---------------------------------- */
        /* 5. Code Section Tabs Styling */
        /* ---------------------------------- */

        .code-tabs {
            display: flex;
            border-bottom: 1px solid var(--color-border-light);
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: var(--color-bg-light);
            color: var(--color-text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--color-text-secondary);
            border-bottom: 3px solid var(--color-link-primary);
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: var(--spacing-sm); /* 10px */
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: var(--color-text-primary);
        }

        .copy-btn.dsa_article_code_active path {
            fill: var(--color-link-primary);
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ---------------------------------- */
        /* 6. Accordion/Dropdown Styling */
        /* ---------------------------------- */

        details {
            margin-bottom: 1em;
            border: 1px solid var(--color-border-light);
            border-radius: 6px;
            overflow: hidden;
            padding: 0;
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: var(--spacing-md) var(--spacing-lg); /* 15px 20px */
            background-color: var(--color-bg-light);
            font-weight: 500;
            color: var(--color-text-secondary);
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px; /* Kept original value */
            background-color: var(--color-bg-container);
            border-top: 1px solid var(--color-border-light);
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: var(--spacing-sm); /* 10px */
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: var(--color-bg-lighter-hover);
        }

        /* ---------------------------------- */
        /* 7. Practice and Disclaimer */
        /* ---------------------------------- */

        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* ---------------------------------- */
        /* 8. Utility: Hiding Specific Elements */
        /* ---------------------------------- */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* ---------------------------------- */
        /* 9. Responsive Adjustments */
        /* ---------------------------------- */

        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: var(--spacing-lg) auto; /* 20px auto */
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: var(--spacing-sm); /* 10px */
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Article Documentation</h1>
</header>
<article>
<p><strong>Problem Statement: </strong>Given a linked list, sort its nodes based on the data value in them. Return the head of the sorted linked list.
</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>

                <span><strong>Input:</strong>Linked List: 3 4 2 1 5</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ccd3686e05efc66c0f007257e1ad1b18" width="439"/></figure>
               
                <span><strong>Output:</strong>Sorted List: 1 2 3 4 5</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/61505beb6948b04edb5fdb2bdfd47bd8" width="439"/></figure>
                <span><strong>Explanation: </strong> The input linked list when sorted from [3, 4, 2, 1, 5] results in a linked list with values: [1, 2, 3, 4, 5].</span>
                
                <br/>
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong>List: 40 20 60 10 50 30</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/178a9a23726dbbb0a15dccef2c14c4cd" width="439"/></figure>                
                
                <span><strong>Output: </strong>Sorted List: 10 20 30 40 50 60</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/233a464ec622865503e44d1dfa518cdb" width="439"/></figure>
                <span><strong>Explanation: </strong> The input linked list when sorted from [40, 20, 60, 10, 50, 30] results in a linked list with values: [10, 20, 30, 40, 50, 60].</span>
                
            </pre>
</div>
</details>
</div>
<!-- This is Practice Section
<div class="practice">
    <span><strong>Practice: </strong></span>
    <div class="problem-buttons">

         
        <a href="https://www.codingninjas.com/studio/problems/power-of-numbers_8157729?utm_source=striver&utm_medium=website&utm_campaign=a_zcoursetuf" target="_blank" rel="noopener">
            <span>Solve Problem</span>
            <img src="https://takeuforward-content-images.s3.ap-south-1.amazonaws.com/content/Group-11-5-pFOq-8ga" alt="code-studio">
        </a>
    </div>
    
</div>-->
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Donâ€™t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>A naive solution could be converting the linked list into an array, sorting the array, and then creating a new linked list from the sorted array's values. </p>
<h4>Algorithm </h4>
<p><strong>Step 1:</strong>Create an empty array to store the node values. Iterate the linked list using a temp pointer to the head and push the value of temp node into the array. Move temp to the next node.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/3c8422513447711d10e7f8fdbda27b61" width="439"/></figure>
<p><strong>Step 2: </strong> Sort the array containing node values in ascending order.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/d25244c1d28be5324109ea25e1f1453c" width="439"/></figure>
<p><strong>Step 3: </strong>
                        Convert the sorted array back to a linked list reassigning the values from the sorted array and overwriting them sequentially according to their order in the array.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/4948b20229dc162c7fb471e619cf0677" width="439"/></figure>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt; 

using namespace std;

// Node class represents a
// node in a linked list
class Node {
public:
    // Data stored in the node
    int data;
    
    // Pointer to the next node in the list
    Node* next;

    // Constructor with both data and
    // next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a
    // parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};



// Function to sort a linked list
// using Brute Force approach
Node* sortLL(Node* head){
    // Create a vector to
    // store node values
    vector&lt;int&gt; arr;
    
    // Temporary pointer to
    // traverse the linked list
    Node* temp = head;
    
    // Traverse the linked list and
    // store node values in the vector
    while(temp!=NULL){
        arr.push_back(temp-&gt;data);
        temp = temp-&gt;next;
    }
    
    // Sort the array
    // containing node values
    sort(arr.begin(), arr.end());
    
    // Reassign sorted values to
    // the linked list nodes
    temp = head;
    for(int i = 0; i &lt; arr.size(); i++){
        // Update the node's data
        // with the sorted values
        temp-&gt;data = arr[i]; 
        // Move to the next node
        temp = temp-&gt;next; 
    }
    
    // Return the head of the
    // sorted linked list
    return head; 
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        // Print the data of the current node
        cout &lt;&lt; temp-&gt;data &lt;&lt; " "; 
        // Move to the next node
        temp = temp-&gt;next; 
    }
    cout &lt;&lt; endl;
}


int main() {
    // Linked List: 3 2 5 4 1
    Node* head = new Node(3);
    head-&gt;next = new Node(2);
    head-&gt;next-&gt;next = new Node(5);
    head-&gt;next-&gt;next-&gt;next = new Node(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);

    cout &lt;&lt; "Original Linked List: ";
    printLinkedList(head);

    // Sort the linked list
    head = sortLL(head);

    cout &lt;&lt; "Sorted Linked List: ";
    printLinkedList(head);

    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.*;

// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;
    
    // Pointer to the next node in the list
    Node next;

    // Constructor with both data and
    // next node as parameters
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a
    // parameter, sets next to null
    Node(int data1) {
        data = data1;
        next = null;
    }
}

// Class to perform operations on Linked List
public class Main {

    // Function to sort a linked list
    // using Brute Force approach
    public static Node sortLL(Node head){
        // Create a list to
        // store node values
        List&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
        
        // Temporary pointer to
        // traverse the linked list
        Node temp = head;
        
        // Traverse the linked list and
        // store node values in the list
        while(temp != null){
            arr.add(temp.data);
            temp = temp.next;
        }
        
        // Sort the list
        // containing node values
        Collections.sort(arr);
        
        // Reassign sorted values to
        // the linked list nodes
        temp = head;
        for(int i = 0; i &lt; arr.size(); i++){
            // Update the node's data
            // with the sorted values
            temp.data = arr.get(i); 
            // Move to the next node
            temp = temp.next; 
        }
        
        // Return the head of the
        // sorted linked list
        return head; 
    }

    // Function to print the linked list
    public static void printLinkedList(Node head) {
        Node temp = head;
        while (temp != null) {
            // Print the data of the current node
            System.out.print(temp.data + " "); 
            // Move to the next node
            temp = temp.next; 
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Linked List: 3 2 5 4 1
        Node head = new Node(3);
        head.next = new Node(2);
        head.next.next = new Node(5);
        head.next.next.next = new Node(4);
        head.next.next.next.next = new Node(1);

        System.out.print("Original Linked List: ");
        printLinkedList(head);

        // Sort the linked list
        head = sortLL(head);

        System.out.print("Sorted Linked List: ");
        printLinkedList(head);
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
# Node class represents a
# node in a linked list
class Node:
    def __init__(self, data, next_node=None):
        # Data stored in the node
        self.data = data
        # Pointer to the next node in the list
        self.next = next_node


# Function to sort a linked list
# using Brute Force approach
def sort_LL(head):
    # Create a list to
    # store node values
    arr = []
    
    # Temporary pointer to
    # traverse the linked list
    temp = head
    
    # Traverse the linked list and
    # store node values in the list
    while temp is not None:
        arr.append(temp.data)
        temp = temp.next
    
    # Sort the list
    # containing node values
    arr.sort()
    
    # Reassign sorted values to
    # the linked list nodes
    temp = head
    for i in range(len(arr)):
        # Update the node's data
        # with the sorted values
        temp.data = arr[i]
        # Move to the next node
        temp = temp.next
    
    # Return the head of the
    # sorted linked list
    return head


# Function to print the linked list
def print_linked_list(head):
    temp = head
    while temp is not None:
        # Print the data of the current node
        print(temp.data, end=" ")
        # Move to the next node
        temp = temp.next
    print()


# Linked List: 3 2 5 4 1
head = Node(3)
head.next = Node(2)
head.next.next = Node(5)
head.next.next.next = Node(4)
head.next.next.next.next = Node(1)

print("Original Linked List: ", end="")
print_linked_list(head)

# Sort the linked list
head = sort_LL(head)

print("Sorted Linked List: ", end="")
print_linked_list(head)
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// Node class represents a
// node in a linked list
class Node {
    constructor(data, next = null) {
        // Data stored in the node
        this.data = data;
        // Pointer to the next node in the list
        this.next = next;
    }
}

// Function to sort a linked list
// using Brute Force approach
function sortLL(head) {
    // Create an array to
    // store node values
    let arr = [];
    
    // Temporary pointer to
    // traverse the linked list
    let temp = head;
    
    // Traverse the linked list and
    // store node values in the array
    while (temp !== null) {
        arr.push(temp.data);
        temp = temp.next;
    }
    
    // Sort the array
    // containing node values
    arr.sort((a, b) =&gt; a - b);
    
    // Reassign sorted values to
    // the linked list nodes
    temp = head;
    for (let i = 0; i &lt; arr.length; i++) {
        // Update the node's data
        // with the sorted values
        temp.data = arr[i]; 
        // Move to the next node
        temp = temp.next; 
    }
    
    // Return the head of the
    // sorted linked list
    return head; 
}

// Function to print the linked list
function printLinkedList(head) {
    let temp = head;
    while (temp !== null) {
        // Print the data of the current node
        console.log(temp.data + " "); 
        // Move to the next node
        temp = temp.next; 
    }
    console.log();
}

// Linked List: 3 2 5 4 1
let head = new Node(3);
head.next = new Node(2);
head.next.next = new Node(5);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(1);

console.log("Original Linked List: ");
printLinkedList(head);

// Sort the linked list
head = sortLL(head);

console.log("Sorted Linked List: ");
printLinkedList(head);

                            </code>
                        </pre>
</div>
<p><strong>Output: </strong>Original Linked List: 3 2 5 4 1 </p>
<p>Sorted Linked List: 1 2 3 4 5</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(N) + O(N log N) + O(N)</strong>where N is the number of nodes in the linked list.
                        <ol><li>O(N) to traverse the linked list and store its data values in an additional array.</li><li>O(N log N) to sort the array containing the node values.</li><li>O(N) to traverse the sorted array and convert it into a new linked list.</li></ol></p>
<p><strong>Space Complexity : O(N)</strong>where N is the number of nodes in the linked list as we have to store the values of all nodes in the linked list in an additional array to sort them.</p>
</p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>Instead of using an external array to store node values, we can employ a sorting algorithm without using any extra space. An in-place sorting algorithm like Merge Sort or Quick Sort adapted for linked lists can achieve this.</p>
<p>Read more about Merge Sort here!<a href="https://takeuforward.org/data-structure/merge-sort-algorithm/">Merge Sort Algorithm</a>. A modified version of merge sort can operate directly on the linked list without using any additional space. This algorithm would divide the linked list into halves recursively until single nodes remain. These sorted halves of the linked list are merged back together in a sorted order.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/881227607331faa99ae1cfdeca1e333f" width="439"/></figure>
<p>This approach employs the divide-and-conquer strategy:
                        <ol><li>Divides the linked list into smaller parts until they become trivial to sort (single node or empty list).</li><li>Merges and sorts the divided parts while combining them back together.</li></ol></p>
<p><strong>Algorithm</strong></p>
<p><strong>Step 1: Base Case</strong>
                        If the linked list contains zero or one element, it is already sorted. Return the head node.</p>
<p><strong>Step 2: Split the List</strong>Find the middle of the linked list using a slow and a fast pointer. Read more about this approach here!<a href="https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/">Middle Element in Linked List</a>. Split the linked list into two halves at the middle node. The two halves will be left and right.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/deabd269f5de7a5eb644756a17916bbe" width="439"/></figure>
<p><strong>Step 3: Recursion</strong>Recursively apply merge sort to both halves obtained in the previous step. This step continues dividing the linked list until there's only one node in each half.</p>
<p><strong>Step 4: Merge Sorted Lists</strong>Merge the sorted halves obtained from the recursive calls into a single sorted linked list. Compare the nodes from both halves and rearrange them to form a single sorted list. Update the head pointer to the beginning of the newly sorted list.</p>
<!--<figure class="wp-block-image size-full is-resized"><img src="https://static.takeuforward.org/content/sort-a-linkedlist-image9-8ZmHhigk" alt="" class="wp-image-8107" width="439" height="286"/></figure>-->
<p><strong>Step 5: Return</strong>Once the merging is complete, return the head of the sorted linked list.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;bits/stdc++.h&gt; 

using namespace std;

// Node class represents a
// node in a linked list
class Node {
public:
    // Data stored in the node
    int data;
    
    // Pointer to the next node in the list
    Node* next;

    // Constructor with both data and
    // next node as parameters
    Node(int data1, Node* next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a
    // parameter, sets next to nullptr
    Node(int data1) {
        data = data1;
        next = nullptr;
    }
};

// Function to merge two sorted linked lists
Node* mergeTwoSortedLinkedLists(Node* list1, Node* list2) {
    // Create a dummy node to serve
    // as the head of the merged list
    Node* dummyNode = new Node(-1);
    Node* temp = dummyNode;

    // Traverse both lists simultaneously
    while (list1 != nullptr &amp;&amp; list2 != nullptr) {
        // Compare elements of both lists and
        // link the smaller node to the merged list
        if (list1-&gt;data &lt;= list2-&gt;data) {
            temp-&gt;next = list1;
            list1 = list1-&gt;next;
        } else {
            temp-&gt;next = list2;
            list2 = list2-&gt;next;
        }
        // Move the temporary pointer
        // to the next node
        temp = temp-&gt;next; 
    }

    // If any list still has remaining
    // elements, append them to the merged list
    if (list1 != nullptr) {
        temp-&gt;next = list1;
    } else {
        temp-&gt;next = list2;
    }
    // Return the merged list starting 
    // from the next of the dummy node
    return dummyNode-&gt;next;
}

// Function to find the middle of a linked list
Node* findMiddle(Node* head){
    // If the list is empty or has only one node
    // the middle is the head itself
    if (head == nullptr || head-&gt;next == nullptr) {
        return head;
    }

    // Initializing slow and fast pointers
    Node* slow = head;
    Node* fast = head-&gt;next;

    // Move the fast pointer twice as fast as the slow pointer
    // When the fast pointer reaches the end, the slow pointer
    // will be at the middle
    while (fast != nullptr &amp;&amp; fast-&gt;next != nullptr) {
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }

    return slow;
}

// Function to perform merge sort on a linked list
Node* sortLL(Node* head){
    // Base case: if the list is empty or has only one node
    // it is already sorted, so return the head
    if (head == nullptr || head-&gt;next == nullptr) {
        return head;
    }
    
    // Find the middle of the list using the findMiddle function
    Node* middle = findMiddle(head);
    
    // Divide the list into two halves
    Node* right = middle-&gt;next;
    middle-&gt;next = nullptr;
    Node* left = head;
    
    // Recursively sort the left and right halves
    left = sortLL(left);
    right = sortLL(right);
    
    // Merge the sorted halves using the mergeTwoSortedLinkedLists function
    return mergeTwoSortedLinkedLists(left, right);
}

// Function to print the linked list
void printLinkedList(Node* head) {
    Node* temp = head;
    while (temp != nullptr) {
        // Print the data of the current node
        cout &lt;&lt; temp-&gt;data &lt;&lt; " "; 
        // Move to the next node
        temp = temp-&gt;next; 
    }
    cout &lt;&lt; endl;
}


int main() {
    // Linked List: 3 2 5 4 1
    Node* head = new Node(3);
    head-&gt;next = new Node(2);
    head-&gt;next-&gt;next = new Node(5);
    head-&gt;next-&gt;next-&gt;next = new Node(4);
    head-&gt;next-&gt;next-&gt;next-&gt;next = new Node(1);

    cout &lt;&lt; "Original Linked List: ";
    printLinkedList(head);

    // Sort the linked list
    head = sortLL(head);

    cout &lt;&lt; "Sorted Linked List: ";
    printLinkedList(head);

    return 0;
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
// Node class represents a
// node in a linked list
class Node {
    // Data stored in the node
    int data;
    
    // Pointer to the next node in the list
    Node next;

    // Constructor with both data and
    // next node as parameters
    Node(int data1, Node next1) {
        data = data1;
        next = next1;
    }

    // Constructor with only data as a
    // parameter, sets next to null
    Node(int data1) {
        data = data1;
        next = null;
    }
}

// Function to merge two sorted linked lists
Node mergeTwoSortedLinkedLists(Node list1, Node list2) {
    // Create a dummy node to serve
    // as the head of the merged list
    Node dummyNode = new Node(-1);
    Node temp = dummyNode;

    // Traverse both lists simultaneously
    while (list1 != null &amp;&amp; list2 != null) {
        // Compare elements of both lists and
        // link the smaller node to the merged list
        if (list1.data &lt;= list2.data) {
            temp.next = list1;
            list1 = list1.next;
        } else {
            temp.next = list2;
            list2 = list2.next;
        }
        // Move the temporary pointer
        // to the next node
        temp = temp.next; 
    }

    // If any list still has remaining
    // elements, append them to the merged list
    if (list1 != null) {
        temp.next = list1;
    } else {
        temp.next = list2;
    }
    // Return the merged list starting 
    // from the next of the dummy node
    return dummyNode.next;
}

// Function to find the middle of a linked list
Node findMiddle(Node head){
    // If the list is empty or has only one node
    // the middle is the head itself
    if (head == null || head.next == null) {
        return head;
    }

    // Initializing slow and fast pointers
    Node slow = head;
    Node fast = head.next;

    // Move the fast pointer twice
    // as fast as the slow pointer
    while (fast != null &amp;&amp; fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // When the fast pointer reaches the end,
    // the slow pointer will be at the middle
    return slow;
}

// Function to perform merge sort on a linked list
Node sortLL(Node head){
    // Base case: if the list is empty or
    // has only one node, it is already
    // sorted, so return the head
    if (head == null || head.next == null) {
        return head;
    }
    
    // Find the middle of the list
    // using the findMiddle function
    Node middle = findMiddle(head);
    
    // Divide the list into two halves
    Node right = middle.next;
    middle.next = null;
    Node left = head;
    
    // Recursively sort the left and right halves
    left = sortLL(left);
    right = sortLL(right);
    
    // Merge the sorted halves using the
    // mergeTwoSortedLinkedLists function
    return mergeTwoSortedLinkedLists(left, right);
}

// Function to print the linked list
void printLinkedList(Node head) {
    Node temp = head;
    while (temp != null) {
        // Print the data of the current node
        System.out.print(temp.data + " "); 
        // Move to the next node
        temp = temp.next; 
    }
    System.out.println();
}

public static void main(String[] args) {
    // Linked List: 3 2 5 4 1
    Node head = new Node(3);
    head.next = new Node(2);
    head.next.next = new Node(5);
    head.next.next.next = new Node(4);
    head.next.next.next.next = new Node(1);

    System.out.print("Original Linked List: ");
    printLinkedList(head);

    // Sort the linked list
    head = sortLL(head);

    System.out.print("Sorted Linked List: ");
    printLinkedList(head);
}

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
# Node class represents a
# node in a linked list
class Node:
    def __init__(self, data1, next1=None):
        # Data stored in the node
        self.data = data1
        
        # Pointer to the next node in the list
        self.next = next1

# Function to merge two sorted linked lists
def mergeTwoSortedLinkedLists(list1, list2):
    # Create a dummy node to serve
    # as the head of the merged list
    dummyNode = Node(-1)
    temp = dummyNode

    # Traverse both lists simultaneously
    while list1 is not None and list2 is not None:
        # Compare elements of both lists and
        # link the smaller node to the merged list
        if list1.data &lt;= list2.data:
            temp.next = list1
            list1 = list1.next
        else:
            temp.next = list2
            list2 = list2.next
        # Move the temporary pointer
        # to the next node
        temp = temp.next 

    # If any list still has remaining
    # elements, append them to the merged list
    if list1 is not None:
        temp.next = list1
    else:
        temp.next = list2
    
    # Return the merged list starting 
    # from the next of the dummy node
    return dummyNode.next

# Function to find the middle of a linked list
def findMiddle(head):
    # If the list is empty or has only one node
    # the middle is the head itself
    if head is None or head.next is None:
        return head

    # Initializing slow and fast pointers
    slow = head
    fast = head.next

    # Move the fast pointer twice as
    # fast as the slow pointer

    while fast is not None and fast.next is not None:
        slow = slow.next
        fast = fast.next.next
        
    # When the fast pointer reaches the end,
    # the slow pointer will be at the middle

    return slow

# Function to perform merge sort on a linked list
def sortLL(head):
    # Base case: if the list is empty
    # or has only one node it is already 
    # sorted, so return the head
    if head is None or head.next is None:
        return head

    # Find the middle of the list
    # using the findMiddle function
    middle = findMiddle(head)

    # Divide the list into two halves
    right = middle.next
    middle.next = None
    left = head

    # Recursively sort the left and right halves
    left = sortLL(left)
    right = sortLL(right)

    # Merge the sorted halves using
    # the mergeTwoSortedLinkedLists function
    return mergeTwoSortedLinkedLists(left, right)

# Function to print the linked list
def printLinkedList(head):
    temp = head
    while temp is not None:
        # Print the data of the current node
        print(temp.data, end=" ")
        # Move to the next node
        temp = temp.next
    print()

# Linked List: 3 2 5 4 1
head = Node(3)
head.next = Node(2)
head.next.next = Node(5)
head.next.next.next = Node(4)
head.next.next.next.next = Node(1)

print("Original Linked List: ", end="")
printLinkedList(head)

# Sort the linked list
head = sortLL(head)

print("Sorted Linked List: ", end="")
printLinkedList(head)

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
 // Node class represents a node in a linked list
class Node {
    constructor(data, nextNode = null) {
        this.data = data;
        this.next = nextNode;
    }
}

// Function to merge two sorted linked lists
function mergeTwoSortedLinkedLists(list1, list2) {
    // Create a dummy node to serve
    // as the head of the merged list
    let dummyNode = new Node(-1);
    let temp = dummyNode;

    // Traverse both lists simultaneously
    while (list1 !== null &amp;&amp; list2 !== null) {
        // Compare elements of both lists and
        // link the smaller node to the merged list
        if (list1.data &lt;= list2.data) {
            temp.next = list1;
            list1 = list1.next;
        } else {
            temp.next = list2;
            list2 = list2.next;
        }
        // Move the temporary pointer to the next node
        temp = temp.next;
    }

    // If any list still has remaining elements,
    // append them to the merged list
    if (list1 !== null) {
        temp.next = list1;
    } else {
        temp.next = list2;
    }
    // Return the merged list starting
    // from the next of the dummy node
    return dummyNode.next;
}

// Function to find the middle of a linked list
function findMiddle(head) {
    // If the list is empty or has only one node,
    // the middle is the head itself
    if (head === null || head.next === null) {
        return head;
    }

    // Initializing slow and fast pointers
    let slow = head;
    let fast = head.next;

    // Move the fast pointer twice
    // as fast as the slow pointer
    
    while (fast !== null &amp;&amp; fast.next !== null) {
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // When the fast pointer reaches the end,
    // the slow pointer will be at the middle
    return slow;
}

// Function to perform merge sort on a linked list
function sortLL(head) {
    // Base case: if the list is empty or has only
    // one node, it is already sorted, so return the head
    if (head === null || head.next === null) {
        return head;
    }

    // Find the middle of the list
    // using the findMiddle function
    let middle = findMiddle(head);

    // Divide the list into two halves
    let right = middle.next;
    middle.next = null;
    let left = head;

    // Recursively sort the left and right halves
    left = sortLL(left);
    right = sortLL(right);

    // Merge the sorted halves using
    // the mergeTwoSortedLinkedLists function
    return mergeTwoSortedLinkedLists(left, right);
}

// Function to print the linked list
function printLinkedList(head) {
    let temp = head;
    while (temp !== null) {
        // Print the data of the current node
        console.log(temp.data + " ");
        // Move to the next node
        temp = temp.next;
    }
    console.log("\n");
}

// Creating and sorting the linked list in JavaScript
let head = new Node(3);
head.next = new Node(2);
head.next.next = new Node(5);
head.next.next.next = new Node(4);
head.next.next.next.next = new Node(1);

console.log("Original Linked List: ");
printLinkedList(head);

// Sort the linked list
head = sortLL(head);

console.log("Sorted Linked List: ");
printLinkedList(head);

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Original Linked List: 3 2 5 4 1 </p>
<p>Sorted Linked List: 1 2 3 4 5 
</p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p>
<p><strong>Time Complexity: O(N log N)</strong>where N is the number of nodes in the linked list. Finding the middle node of the linked list requires traversing it linearly taking O(N) time complexity and to reach the individual nodes of the list, it has to be split log N times (continuously halve the list until we have individual elements).</p>
<p><strong>Space Complexity : O(1)</strong> as no additional data structures or space is allocated for storage during the merging process. However, space proportional to O(log N) stack space is required for the recursive calls. THe maximum recursion depth of log N height is occupied on the call stack.
</p>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/8ocB7a_c-Cc?si=0Oe5J6V6egH6bHxH" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>
