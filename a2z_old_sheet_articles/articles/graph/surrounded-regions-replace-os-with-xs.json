{
    "dislikes": 0,
    "video": "BtdgAys4yMk",
    "publishedOn": "Sun Mar 24 2024 22:11:40 GMT+0530 (India Standard Time)",
    "slug": "surrounded-regions-replace-os-with-xs",
    "aid": "2133",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/surrounded-regions",
    "title": "Surrounded Regions | Replace O\u2019s with X\u2019s",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "category_tag": "graph",
    "likes": 65,
    "preview": "Problem Statement: Given a matrix mat of size N x M where every element is either \u2018O\u2019 or \u2018X\u2019. Replace all \u2018O\u2019 with \u2018X\u2019 that is surrounded by \u2018X\u2019. An \u2018O\u2019 (or a set of \u2018O\u2019) is considered to be surrou...",
    "content": "<!-- wp:paragraph -->\n<p><strong>Problem Statement: </strong>Given a matrix mat of size N x M where every element is either \u2018O\u2019 or \u2018X\u2019. Replace all \u2018O\u2019 with \u2018X\u2019 that is surrounded by \u2018X\u2019.  An \u2018O\u2019 (or a set of \u2018O\u2019) is considered to be surrounded by \u2018X\u2019 if there are \u2018X\u2019 at locations just below, just above just left, and just right of it.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Examples:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 1:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong> n = 5, m = 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6557,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/09/image-4.png\" alt=\"\" class=\"wp-image-6557\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6558,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/09/image-5.png\" alt=\"\" class=\"wp-image-6558\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Input:</strong> n = 5, m = 4</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6559,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/09/image-6.png\" alt=\"\" class=\"wp-image-6559\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":6560,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2022/09/image-7.png\" alt=\"\" class=\"wp-image-6560\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Solution</strong></h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first.</em></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Intuition:</strong>.</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>The boundary elements in the matrix cannot be replaced with \u2018X\u2019 as they are not surrounded by \u2018X\u2019 from all 4 directions. This means if \u2018O\u2019 (or a set of \u2018O\u2019) is connected to a boundary \u2018O\u2019 then it can\u2019t be replaced with \u2018X\u2019.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The intuition is that we start from boundary elements having \u2018O\u2019 and go through its neighboring Os in 4 directions and mark them as visited to avoid replacing them with \u2018X\u2019.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:heading {\"level\":3} -->\n<h3><strong>Approach</strong>:</h3>\n<!-- /wp:heading -->\n\n<!-- wp:paragraph -->\n<p>We can follow either of the traversal techniques as long as we are starting with a boundary element and marking all those Os connected to it. We will be solving it using DFS traversal, but you can apply BFS traversal as well.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>DFS is a traversal technique that involves the idea of recursion.. DFS goes in-depth, i.e., traverses all nodes by going ahead, and when there are no further nodes to traverse in the current path, then it backtracks on the same path and traverses other unvisited nodes.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The algorithm steps are as follows:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Create a corresponding visited matrix and initialize it to 0.</li><li>Start with boundary elements, once \u2018O\u2019 is found, call the DFS function for that element and mark it as visited. In order to traverse for boundary elements, you can traverse through the first row, last row, first column, and last column.&nbsp;</li><li>DFS function call will run through all the unvisited neighboring \u2018O\u2019s in all 4 directions and mark them as visited so that they are not converted to \u2018X\u2019 in the future. The DFS function will not be called for the already visited elements to save time, as they have already been traversed.&nbsp;</li><li>When all the boundaries are traversed and corresponding sets of \u2018O\u2019s are marked as visited, they cannot be replaced with \u2018X\u2019. All the other remaining unvisited \u2018O\u2019s are replaced with \u2018X\u2019. This can be done in the same input matrix as the problem talks about replacing the values, otherwise tampering with data is not advised.&nbsp;</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Consider the following illustration to understand how DFS traverses the matrix and replaces O\u2019s with X\u2019s.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><img width=\"691.9532554257096\" height=\"363\" src=\"https://lh3.googleusercontent.com/daXUgweC8ZRxHl-ZWn9JnL0J3FM0xybehV-OALmuWXYcOzdA9VbbvPNOQXaU19alDS-r7jca0wdJlCf6PlGQ_WUgl1DoB6GBqLNfJ0D2LaM5bs4c1nKIIyQBkbRFIxulVoUvl8fdRZ2fDFcz17kszBk35LzqdO_EEa7QcIsJIcQllCauemekLQ686g\"></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>How do set boundaries for 4 directions?</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>The 4 neighbors will have the following indexes:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong><img width=\"318\" height=\"118\" src=\"https://lh5.googleusercontent.com/EISVW8-EsOeN1K7XkzXsPEfhFdAcs3vFSL1TG4cokmrkOp7yPeI3ifKcSw6mBG6r5cICySt_rEV8RDRI3GYDPy_UtrcMryfZ20oquH8PQE_5wuANrmaHeh7Xk9Fj702beclMt3GU8MbtSkYhxvO1ZJmCRvHJID52KsvHDTUeI3LTckkGjUC1ra6m-Q\"></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Now, either we can apply 4 conditions or follow the following method.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>From the above image, it is clear that the delta change in the row is -1, +0, +1, +0. Similarly, the delta change in the column is 0, +1, +0, -1.&nbsp; So we can apply the same logic to find the neighbors of a particular pixel (&lt;row, column&gt;).&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution{\nprivate:\n    void dfs(int row, int col, vector&lt;vector&lt;int&gt;&gt; &amp;vis, \n    vector&lt;vector&lt;char&gt;&gt; &amp;mat, int delrow[], int delcol[]) {\n        vis[row][col] = 1; \n        int n = mat.size();\n        int m = mat[0].size();\n        \n        // check for top, right, bottom, left \n        for(int i = 0;i&lt;4;i++) {\n            int nrow = row + delrow[i];\n            int ncol = col + delcol[i]; \n            // check for valid coordinates and unvisited Os\n            if(nrow &gt;=0 &amp;&amp; nrow &lt;n &amp;&amp; ncol &gt;= 0 &amp;&amp; ncol &lt; m \n            &amp;&amp; !vis[nrow][ncol] &amp;&amp; mat[nrow][ncol] == 'O') {\n                dfs(nrow, ncol, vis, mat, delrow, delcol); \n            }\n        }\n    }\npublic:\n    vector&lt;vector&lt;char&gt;&gt; fill(int n, int m, \n    vector&lt;vector&lt;char&gt;&gt; mat)\n    {\n        int delrow[] = {-1, 0, +1, 0};\n        int delcol[] = {0, 1, 0, -1}; \n        vector&lt;vector&lt;int&gt;&gt; vis(n, vector&lt;int&gt;(m,0)); \n        // traverse first row and last row \n        for(int j = 0 ; j&lt;m;j++) {\n            // check for unvisited Os in the boundary rows\n            // first row \n            if(!vis[0][j] &amp;&amp; mat[0][j] == 'O') {\n                dfs(0, j, vis, mat, delrow, delcol); \n            }\n            \n            // last row \n            if(!vis[n-1][j] &amp;&amp; mat[n-1][j] == 'O') {\n                dfs(n-1,j,vis,mat, delrow, delcol); \n            }\n        }\n        \n        for(int i = 0;i&lt;n;i++) {\n            // check for unvisited Os in the boundary columns\n            // first column \n            if(!vis[i][0] &amp;&amp; mat[i][0] == 'O') {\n                dfs(i, 0, vis, mat, delrow, delcol); \n            }\n            \n            // last column\n            if(!vis[i][m-1] &amp;&amp; mat[i][m-1] == 'O') {\n                dfs(i, m-1, vis, mat, delrow, delcol); \n            }\n        }\n        \n        // if unvisited O then convert to X\n        for(int i = 0;i&lt;n;i++) {\n            for(int j= 0 ;j&lt;m;j++) {\n                if(!vis[i][j] &amp;&amp; mat[i][j] == 'O') \n                    mat[i][j] = 'X'; \n            }\n        }\n        \n        return mat; \n    }\n};\n\nint main(){\n    \n    vector&lt;vector&lt;char&gt;&gt; mat{\n        {'X', 'X', 'X', 'X'}, \n        {'X', 'O', 'X', 'X'}, \n        {'X', 'O', 'O', 'X'}, \n        {'X', 'O', 'X', 'X'}, \n        {'X', 'X', 'O', 'O'}\n    };\n    \n    Solution ob;\n    // n = 5, m = 4\n    vector&lt;vector&lt;char&gt;&gt; ans = ob.fill(5, 4, mat);\n    for(int i = 0;i &lt; 5;i++) {\n        for(int j = 0;j &lt; 4;j++) {\n            cout&lt;&lt;ans[i][j]&lt;&lt;\" \";\n        }\n        cout&lt;&lt;\"\\n\";\n    }\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>X X X X<br>X X X X<br>X X X X<br>X X X X<br>X X O O</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N) + O(M) + O(NxMx4) ~ O(N x M), For the worst case, every element will be marked as \u2018O\u2019 in the matrix, and the DFS function will be called for (N x M) nodes and for every node, we are traversing for 4 neighbors, so it will take O(N x M x 4) time. Also, we are running loops for boundary elements so it will take O(N) + O(M).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity ~</strong> O(N x M), O(N x M) for the visited array, and auxiliary stack space takes up N x M locations at max.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"java\" class=\"language-java\">import java.util.*;\n\nclass Solution{\n    static void dfs(int row, int col,int vis[][], \n    char mat[][], int delrow[], int delcol[]) {\n        vis[row][col] = 1; \n        int n = mat.length;\n        int m = mat[0].length;\n        \n        // check for top, right, bottom, left \n        for(int i = 0;i&lt;4;i++) {\n            int nrow = row + delrow[i];\n            int ncol = col + delcol[i]; \n            // check for valid coordinates and unvisited Os\n            if(nrow &gt;=0 &amp;&amp; nrow &lt;n &amp;&amp; ncol &gt;= 0 &amp;&amp; ncol &lt; m \n            &amp;&amp; vis[nrow][ncol] == 0 &amp;&amp; mat[nrow][ncol] == 'O') {\n                dfs(nrow, ncol, vis, mat, delrow, delcol); \n            }\n        }\n    }\n\n    static char[][] fill(int n, int m, char mat[][])\n    {\n        int delrow[] = {-1, 0, +1, 0};\n        int delcol[] = {0, 1, 0, -1}; \n        int vis[][] = new int[n][m]; \n        // traverse first row and last row \n        for(int j = 0 ; j&lt;m;j++) {\n            // check for unvisited Os in the boundary rws\n            // first row \n            if(vis[0][j] == 0 &amp;&amp; mat[0][j] == 'O') {\n                dfs(0, j, vis, mat, delrow, delcol); \n            }\n            \n            // last row \n            if(vis[n-1][j] == 0 &amp;&amp; mat[n-1][j] == 'O') {\n                dfs(n-1,j,vis,mat, delrow, delcol); \n            }\n        }\n        \n        for(int i = 0;i&lt;n;i++) {\n            // check for unvisited Os in the boundary columns\n            // first column \n            if(vis[i][0] == 0 &amp;&amp; mat[i][0] == 'O') {\n                dfs(i, 0, vis, mat, delrow, delcol); \n            }\n            \n            // last column\n            if(vis[i][m-1] == 0 &amp;&amp; mat[i][m-1] == 'O') {\n                dfs(i, m-1, vis, mat, delrow, delcol); \n            }\n        }\n        \n        // if unvisited O then convert to X\n        for(int i = 0;i&lt;n;i++) {\n            for(int j= 0 ;j&lt;m;j++) {\n                if(vis[i][j] == 0 &amp;&amp; mat[i][j] == 'O') \n                    mat[i][j] = 'X'; \n            }\n        }\n        \n        return mat;\n    }\n     public static void main(String[] args)\n    {\n        char mat[][] = {\n        {'X', 'X', 'X', 'X'}, \n        {'X', 'O', 'X', 'X'}, \n        {'X', 'O', 'O', 'X'}, \n        {'X', 'O', 'X', 'X'}, \n        {'X', 'X', 'O', 'O'}};\n\n        // n = 5, m = 4\n        Solution ob = new Solution();\n        char[][] ans = ob.fill(5, 4, mat);\n        for(int i = 0;i &lt; 5;i++) {\n            for(int j = 0;j &lt; 4;j++) {\n                System.out.print(ans[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>X X X X<br>X X X X<br>X X X X<br>X X X X<br>X X O O</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity: </strong>O(N) + O(M) + O(NxMx4) ~ O(N x M), For the worst case, every element will be marked as \u2018O\u2019 in the matrix, and the DFS function will be called for (N x M) nodes and for every node, we are traversing for 4 neighbors, so it will take O(N x M x 4) time. Also, we are running loops for boundary elements so it will take O(N) + O(M).</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity ~</strong> O(N x M), O(N x M) for the visited array, and auxiliary stack space takes up N x M locations at max.&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/vanshika-singh-ba6b15157\" target=\"_blank\" rel=\"noreferrer noopener\">Vanshika Singh Gour</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}