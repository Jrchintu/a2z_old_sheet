{
    "dislikes": 6,
    "video": "_BvEJ3VIDWw",
    "publishedOn": "Sun Mar 24 2024 22:11:52 GMT+0530 (India Standard Time)",
    "slug": "g-39-minimum-multiplications-to-reach-end",
    "aid": "2181",
    "tuf_plus": "https://takeuforward.org/plus/dsa/problems/minimum-multiplications-to-reach-end",
    "title": "G-39: Minimum Multiplications to Reach End",
    "topics": [
        {
            "topic-id": "data-structure",
            "topic-title": "Data Structures"
        },
        {
            "topic-id": "graph",
            "topic-title": "Graph"
        }
    ],
    "likes": 35,
    "category_tag": "graph",
    "preview": "Given start, end, and an array arr of n numbers. At each step, the start is multiplied by any number in the array and then a mod operation with 100000 is done to get the new start. Your task is to...",
    "content": "<!-- wp:paragraph -->\n<p>Given <strong>start, end,</strong> and an array<strong> arr</strong> of <strong>n</strong> numbers. At each step, the <strong>start</strong> is multiplied by any number in the array and then a mod operation with <strong>100000</strong> is done to get the new start.<br>Your task is to find the minimum steps in which t<strong>he end</strong> can be achieved starting from<strong> the start</strong>. If it is not possible to reach the <strong>end</strong>, then return<strong> -1</strong>.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Input:</strong>\narr[] = {2, 5, 7}\nstart = 3\nend = 30\n<strong>Output:</strong>\n2\n<strong>Explanation:</strong> \nStep 1: 3*2 = 6 % 100000 = 6 \nStep 2: 6*5 = 30 % 100000 = 30\nTherefore, in minimum 2 multiplications we reach the \nend number which is treated as a destination \nnode of a graph here.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p><strong>Example 2</strong>:</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:preformatted -->\n<pre class=\"wp-block-preformatted\"><strong>Input</strong>:\narr[] = {3, 4, 65}\nstart = 7\nend = 66175\n<strong>Output</strong>:\n4\n<strong>Explanation</strong>: \nStep 1: 7*3 = 21 % 100000 = 21 \nStep 2: 21*3 = 6 % 100000 = 63 \nStep 3: 63*65 = 4095 % 100000 = 4095 \nStep 4: 4095*65 = 266175 % 100000 = 66175\nTherefore, in minimum 4 multiplications we reach the end number which is treated as a destination node of a graph here.</pre>\n<!-- /wp:preformatted -->\n\n<!-- wp:paragraph -->\n<p><strong>Solution</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph {\"textColor\":\"accent\"} -->\n<p class=\"has-accent-color has-text-color\"><strong><em>Disclaimer</em></strong><strong>: </strong><strong><em>Don\u2019t jump directly to the solution, try it out yourself first.</em></strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><a href=\"https://practice.geeksforgeeks.org/problems/minimum-multiplications-to-reach-end/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=minimum-multiplications-to-reach-end\"><strong><em>Problem Link</em></strong></a></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Note: In case any image/dry run is not clear please refer to the video attached at the bottom.&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Intuition:</strong> Since we need to find the <strong>minimum</strong> number of multiplications in order to attain the end number from the start number, the one standard algorithm that we can think of for finding the shortest/minimum paths is of course Dijkstra\u2019s Algorithm. But a question may arise in our minds: how can we depict this problem in the form of a graph? So let us understand this through an illustration :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7206,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-145731.png\" alt=\"\" class=\"wp-image-7206\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p>As per the above image, we can clearly make out that the numbers after multiplication with the start number can be considered as nodes of a graph ranging from 0 to 99999 and the edges from each node will be the size of the given array i.e. the number of ways in which we can multiply a number. We update the distance array whenever we find a lesser number of multiplications in order to reach a node. In this way, whenever we reach the end number, the multiplications needed to reach it would always be <strong>minimum.</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Approach:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>This problem can be visualized as a graph problem as we need to find the minimum number of steps to reach an end number from the start following a number of multiplications. We would be solving it using Dijkstra's Algorithm.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Initial configuration:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li><strong>Queue: </strong>Define a Queue which would contain pairs of the type {steps, num }, where \u2018steps\u2019 indicates the currently updated value of no. of steps taken to reach from source to the current \u2018num\u2019.</li><li><strong>Distance Array: </strong>Define a distance array that would contain the minimum no. of multiplications/distance from the start number to the current number. If a cell is marked as \u2018infinity\u2019 then it is treated as unreachable/unattained.</li><li><strong>Start and End: </strong>Define the start and the end value which we have to reach through a series of multiplications.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>The Algorithm consists of the following steps :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:list -->\n<ul><li>Start by creating a queue that stores the step-num pairs in the form {steps, num} and a dist array with each node initialized with a very large number ( to indicate that they\u2019ve not been attained initially). The size of the \u2018dist\u2019 array is set to 100000 because it is the maximum number of distinct numbers that can be generated.</li><li>We push the start number to the queue along with its steps marked as \u20180\u2019 initially because we\u2019ve just started the algorithm.</li><li>Pop the element from the front of the queue and look out for its adjacent nodes (here, adjacent nodes can be regarded as the numbers which we get when we multiply the start number by each element from the arr).</li><li>If the current dist value for a number is better than the previous distance indicated by the distance array, we update the distance/steps in the array and push it to the queue.</li><li>We repeat the above three steps until the queue becomes empty or we reach the end number.</li><li>Return the calculated number of steps after we reach the end number. If the queue becomes empty and we don\u2019t encounter the required number, return \u2018-1\u2019 indicating that the following number is unattainable by multiplying the start number any number of times.</li></ul>\n<!-- /wp:list -->\n\n<!-- wp:paragraph -->\n<p>Here\u2019s a quick demonstration of the Algorithm\u2019s 1st iteration for <strong>example 1</strong> stated above ( all the further iterations would be done in a similar way ) :</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:image {\"id\":7207,\"sizeSlug\":\"full\",\"linkDestination\":\"none\"} -->\n<figure class=\"wp-block-image size-full\"><img src=\"https://static.takeuforward.org/wp/uploads/2023/01/Screenshot-2023-01-08-145952.png\" alt=\"\" class=\"wp-image-7207\"/></figure>\n<!-- /wp:image -->\n\n<!-- wp:paragraph -->\n<p><strong><em>Note: If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></strong>&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Code:</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    <div class=\"code-section secondary-details\">\n    <div class=\"code-tabs\">\n    <button class=\"code-tab dsa_article_code_active\" data-lang=\"cpp\">C++</button>\n    <button class=\"code-tab\" data-lang=\"java\">Java</button>\n    \n    \n    <svg width=\"17\" class=\"copy-btn\" height=\"20\" viewBox=\"0 0 17 20\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z\">\n    </path>\n    </svg>\n    </div>\n    <div class=\"code-content\">\n    <div class=\"code-block dsa_article_code_active\" data-lang=\"cpp\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code lang=\"cpp\" class=\"language-cpp\">#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Solution\n{\npublic:\n    int minimumMultiplications(vector&lt;int&gt; &amp;arr,\n                               int start, int end)\n    {\n        // Create a queue for storing the numbers as a result of multiplication\n        // of the numbers in the array and the start number.\n        queue&lt;pair&lt;int, int&gt;&gt; q;\n        q.push({start, 0});\n\n        // Create a dist array to store the no. of multiplications to reach\n        // a particular number from the start number.\n        vector&lt;int&gt; dist(100000, 1e9);\n        dist[start] = 0;\n        int mod = 100000;\n\n        // Multiply the start no. with each of numbers in the arr\n        // until we get the end no.\n        while (!q.empty())\n        {\n            int node = q.front().first;\n            int steps = q.front().second;\n            q.pop();\n\n            for (auto it : arr)\n            {\n                int num = (it * node) % mod;\n\n                // If the no. of multiplications are less than before\n                // in order to reach a number, we update the dist array.\n                if (steps + 1 &lt; dist[num])\n                {\n                    dist[num] = steps + 1;\n\n                    // Whenever we reach the end number\n                    // return the calculated steps\n                    if (num == end)\n                        return steps + 1;\n                    q.push({num, steps + 1});\n                }\n            }\n        }\n        // If the end no. is unattainable.\n        return -1;\n    }\n};\n\nint main()\n{\n    // Driver Code.\n    int start = 3, end = 30;\n\n    vector&lt;int&gt; arr = {2, 5, 7};\n\n    Solution obj;\n\n    int ans = obj.minimumMultiplications(arr, start, end);\n\n    cout &lt;&lt; ans;\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output</strong> <strong>:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>2</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity :</strong> O(100000 * N)&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where \u2018100000\u2019 are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity :</strong>&nbsp; O(100000 * N)&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where \u2018100000\u2019 are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied. 100000 * N is the max possible queue size. The space complexity of the dist array is constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    <div class=\"code-block \" data-lang=\"java\">\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:code -->\n<pre class=\"wp-block-code\"><code class=\"\">import java.util.*;\n\nclass Pair {\n    int first, second; \n    Pair(int first, int second) {\n        this.first = first;\n        this.second = second; \n    }\n}\nclass Solution {\n    int minimumMultiplications(int[] arr, \n    int start, int end) {\n\n        // Create a queue for storing the numbers as a result of multiplication\n        // of the numbers in the array and the start number.\n        Queue&lt;Pair&gt; q = new LinkedList&lt;&gt;(); \n        q.add(new Pair(start, 0)); \n\n        // Create a dist array to store the no. of multiplications to reach\n        // a particular number from the start number.\n        int[] dist = new int[100000]; \n        for(int i = 0;i&lt;100000;i++) dist[i] = (int)(1e9);\n        dist[start] = 0; \n        int mod = 100000;\n        int n = arr.length; \n        // O(100000 * N) \n\n        // Multiply the start no. with each of numbers in the arr\n        // until we get the end no.\n        while(!q.isEmpty()) {\n            int node = q.peek().first; \n            int steps = q.peek().second;\n            q.remove(); \n            \n            for(int i = 0;i &lt; n; i++) {\n                int num = (arr[i] * node) % mod; \n\n                // If the no. of multiplications are less than before\n                // in order to reach a number, we update the dist array.\n                if(steps + 1 &lt; dist[num]) {\n                    dist[num] = steps + 1; \n\n                    // Whenever we reach the end number\n                    // return the calculated steps\n                    if(num == end) return steps + 1; \n                    q.add(new Pair(num, steps + 1)); \n                }\n            }\n        }\n        // If the end no. is unattainable.\n        return -1; \n    }\n}\n\nclass tuf {\n\n    public static void main(String[] args) {\n       \n        int start=3, end=30;\n        int[] arr = {2,5,7};\n\n        Solution obj = new Solution();\n        int ans = obj.minimumMultiplications(arr,start,end);\n        \n        System.out.print(ans);\n        System.out.println();\n    }\n}\n</code></pre>\n<!-- /wp:code -->\n\n<!-- wp:paragraph -->\n<p><strong>Output</strong> <strong>:&nbsp;</strong></p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>2</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Time Complexity :</strong> O(100000 * N)&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where \u2018100000\u2019 are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p><strong>Space Complexity :</strong>&nbsp; O(100000 * N)&nbsp;</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n<p>Where \u2018100000\u2019 are the total possible numbers generated by multiplication (hypothetical) and N = size of the array with numbers of which each node could be multiplied. 100000 * N is the max possible queue size. The space complexity of the dist array is constant.</p>\n<!-- /wp:paragraph -->\n\n<!-- wp:paragraph -->\n\n    </div>\n    </div>\n    </div>\n    \n<!-- /wp:paragraph -->\n\n<!-- wp:quote -->\n<blockquote class=\"wp-block-quote\"><p><em>Special thanks to&nbsp;<strong><a href=\"https://www.linkedin.com/in/priyanshi-goel-7b6a42210/\" target=\"_blank\" rel=\"noreferrer noopener\">Priyanshi Goel</a></strong>&nbsp;for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,&nbsp;</em><a href=\"https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/\" target=\"_blank\" rel=\"noreferrer noopener\">please check out this article</a>.&nbsp;<em>If you want to suggest any improvement/correction in this article please mail us at&nbsp;write4tuf@gmail.com</em></p></blockquote>\n<!-- /wp:quote -->"
}