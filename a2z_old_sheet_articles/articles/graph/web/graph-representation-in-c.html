<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Graph Representation in C++</title>
<link href="assets/34bd07407ad1de576cba1f67651fa31a" rel="stylesheet"/>
<style>
        /* ==========================================================================
           1. CSS Variables (Theme) - Utilitarian Modern
           ========================================================================== */
        :root {
            /* Default to Light Theme */
            --primary-color: #3b82f6; /* Blue 500 */
            --primary-hover: #2563eb; /* Blue 600 */
            
            --bg-body: #f8fafc; /* Slate 50 */
            --bg-surface: #ffffff; /* White */
            --bg-subtle: #f1f5f9; /* Slate 100 */
            
            --border-color: #e2e8f0; /* Slate 200 */
            
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #334155; /* Slate 700 */
            --text-muted: #64748b; /* Slate 500 */
            
            --link-color: #2563eb; /* Blue 600 */
            --link-hover: #3b82f6; /* Blue 500 */

            --code-bg: #f1f5f9; /* Slate 100 */
            --code-text: #0f172a; /* Slate 900 */

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 0 25px -5px rgba(59, 130, 246, 0.25);
            
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
        }

        /* Dark Theme Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f172a; /* Slate 900 */
                --bg-surface: #1e293b; /* Slate 800 */
                --bg-subtle: #334155; /* Slate 700 */
                
                --border-color: #334155;
                
                --text-primary: #f8fafc; /* Slate 50 */
                --text-secondary: #cbd5e1; /* Slate 300 */
                --text-muted: #94a3b8; /* Slate 400 */
                
                --link-color: #60a5fa; /* Blue 400 */
                --link-hover: #93c5fd; /* Blue 300 */

                --code-bg: #020617; /* Slate 950 */
                --code-text: #f8fafc;
            }
        }

        /* ==========================================================================
           2. Base & Reset
           ========================================================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-body);
            margin: 0;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ==========================================================================
           3. Layout
           ========================================================================== */
        .container {
            max-width: 800px; /* Optimal reading width */
            margin: 0 auto;
            padding: 2rem;
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        /* Enhanced hover for desktop only */
        @media (hover: hover) and (pointer: fine) {
            .container:hover {
                transform: translateY(-4px);
                border-color: var(--primary-color);
                box-shadow: var(--shadow-hover);
            }
        }

        /* ==========================================================================
           4. Typography
           ========================================================================== */
        h1 {
            color: var(--text-primary);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.025em;
        }
        
        h2, h3, h4 {
            color: var(--text-secondary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.25em;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* ==========================================================================
           5. Media
           ========================================================================== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            margin: 1.5rem auto;
        }

        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            margin: 1.5rem 0;
            border-radius: var(--radius-md);
            background-color: var(--bg-subtle);
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ==========================================================================
           6. Code Blocks
           ========================================================================== */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            overflow-x: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        code {
            font-family: inherit;
        }

        /* ==========================================================================
           7. Code Tabs
           ========================================================================== */
        .code-section {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .code-tabs {
            display: flex;
            background-color: var(--bg-subtle);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .code-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .code-tab:hover {
            color: var(--text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .copy-btn {
            margin-left: auto;
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .copy-btn svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
        }
        
        .copy-btn:hover svg {
            fill: var(--text-primary);
        }

        .code-content {
            background-color: var(--code-bg);
        }
        
        .code-content pre {
            margin: 0;
            border-radius: 0;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ==========================================================================
           8. Accordions / Details
           ========================================================================== */
        details {
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: var(--bg-surface);
            transition: box-shadow 0.2s;
        }
        
        details:hover {
            box-shadow: var(--shadow-sm);
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: 1rem;
            background-color: var(--bg-subtle);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: #475569; /* Slate 600 */
        }
        
        /* Arrow icon rotation */
        summary .arrow-svg {
            transition: transform 0.3s ease;
            width: 20px;
            height: 20px;
            fill: var(--text-muted);
        }
        
        details[open] > summary .arrow-svg {
            transform: rotate(180deg);
            fill: var(--primary-color);
        }

        .common-drops,
        .atricle_example_content,
        details > :not(summary) {
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-surface);
        }

        /* Nested details */
        .secondary-details {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        .secondary-summary {
            background-color: rgba(51, 65, 85, 0.3); /* Semi-transparent slate-700 */
            font-size: 0.95rem;
        }
        
        .secondary-summary:hover {
            background-color: var(--bg-subtle);
        }
        
        .opacity-75 {
            opacity: 0.75;
        }

        /* ==========================================================================
           9. Practice & Disclaimer
           ========================================================================== */
        .practice, .new-disclaimer {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: var(--bg-subtle);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .problem-buttons a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        
        .problem-buttons a:hover {
            background-color: var(--primary-hover);
            text-decoration: none;
        }

        /* ==========================================================================
           10. Utilities
           ========================================================================== */
        .problem-buttons img,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article,
        .has-text-align-center {
            display: none;
        }
        
        .arrow-svg {
            display: inline-block; /* Ensure arrows are visible */
        }

        /* ==========================================================================
           11. Responsive (Full Page Mobile)
           ========================================================================== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border: none;
                border-radius: 0;
                box-shadow: none;
                padding: 1rem;
                max-width: 100%;
            }

            h1 {
                font-size: 1.5rem;
                text-align: left;
            }

            .code-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 2px; /* Space for scrollbar */
            }
            
            .code-tab {
                flex-shrink: 0;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Graph Representation in C++</h1>
</header>
<article>
<!-- wp:paragraph -->
<p>In this article, we are going to study the different ways of representing a graph in memory, but before that first, let us understand how to take the input of the graph.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Input Format </strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>In the question, they will mention whether it is a directed or undirected graph. The first line contains two space-separated integers n and m denoting the number of nodes and the number of edges respectively. Next m lines contain two integers u and v representing an edge between u and v. In the case of an undirected graph if there is an edge between u and v, it means there is an edge between v and u as well. Now the question arises if there is any boundation on the number of edges, i.e., the value of m? The answer is NO. If we add more edges, then the value of m will increase.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Graph Representations</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>After understanding the input format, let us try to understand how the graph can be stored. The two most commonly used representations for graphs are</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li>Adjacency Matrix</li><li>Adjacency Lists</li></ol>
<!-- /wp:list -->
<!-- wp:heading {"level":3} -->
<h3><strong>Adjacency Matrix</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>An adjacency matrix of a graph is a two-dimensional array of size n x n, where n is the number of nodes in the graph, with the property that a[ i ][ j ] = 1 if the edge (vᵢ, vⱼ) is in the set of edges, and a[ i ][ j ] = 0 if there is no such edge.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Consider the example of the following undirected graph,</p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Input:
</strong>5 6
1 2
1 3
2 4
3 4 
3 5 
4 5

<strong>Explanation</strong>:
Number of nodes, n = 5
Number of edges, m = 6
Next m lines represent the edges.


<img height="236.4481180143297" src="assets/91372dad00e8d59e1449125b6fdb3c98" width="305"/></pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p>We need to store these edges so that future algorithms can be performed. Are the nodes zero-based or one-based? In this case, the nodes follow one-based indexing as the last node is 5 and the total number of nodes is also 5. Now, define an adjacency matrix of size (n+1) x (n+1), i.e., adj[n+1][n+1]. If there is an edge between 1 and 2, mark 1 at (1,2) and (2,1) as there is an edge between 2 and 1 as well (in the case of an undirected graph). Similarly, follow for other edges.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><img height="331" src="assets/a09e7f0e7df9f29616832ab015e50376" width="602"/></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>All the edges are marked in the adjacency matrix, remaining spaces in the matrix are marked as zero or left as it is.<img height="201" src="assets/912031e17f5bdd5b4bda842a864c4190" width="256"/></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>This matrix will tell if there is an edge between two particular nodes. For example, there is an edge between 5 and 3 as 1 is at (5,3) but there is no edge between 5 and 1 as the space is empty (or can be filled with 0) at position (5,1) in the adjacency matrix.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The space needed to represent a graph using its adjacency matrix is n² locations. Space complexity = (n*n), It is a costly method as n² locations are consumed.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">using namespace std;

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    // adjacency matrix for undirected graph
    // time complexity: O(n)
    int adj[n+1][n+1];
    for(int i = 0; i &lt; m; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u][v] = 1;
        adj[v][u] = 1  // this statement will be removed in case of directed graph
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Adjacency Lists</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>In the previous storing method, we saw it was taking n² space to store the graph, this is where the adjacency list comes into the picture, it takes a very less amount of space.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>This is a node-based representation. In this representation, we associate with each node a list of nodes adjacent to it. Normally an array is used to store the nodes. The array provides random access to the adjacency list for any particular node.<br/>Consider the example of the following <strong>undirected graph</strong>,</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><img height="219.979094869053" src="assets/91372dad00e8d59e1449125b6fdb3c98" width="284"/></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>To create an adjacency list, we will create an array of size n+1 where n is the number of nodes. This array will contain a list, so in C++ list is nothing but the vector of integers.</p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">vector &lt;int&gt; adj[n+1];</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p>Now every index is containing an empty vector/ list. With respect to the example, 6 indexes contain empty vectors.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><em><strong>What is the motive of the list?</strong></em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>In the example, we can clearly see that node 4 has nodes 2, 3, and 5 as its adjacent neighbors. So, to store its immediate neighbors in any order, we use the list.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><img height="441" src="assets/a36b62fbbfc963a025df40309936b542" width="602"/></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Hence, we stored all the neighbors in the particular indexes. In this representation, for an undirected graph, each edge data appears twice. For example, nodes 1 and 2 are adjacent hence node 2 appears in the list of node 1, and node 1 appears in the list of node 2. So, the space needed to represent an undirected graph using its adjacency list is 2 x E locations, where E denotes the number of edges.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Space complexity = O(2xE)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>This representation is much better than the adjacency matrix, as matrix representation consumes n² locations, and most of them are unused.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    // adjacency list for undirected graph
    // time complexity: O(2E)
    vector&lt;int&gt; adj[n+1];
    for(int i = 0; i &lt; m; i++)
    {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>For<strong> directed graphs</strong>, if there is an edge between u and v it means the edge only goes from u to v, i.e., v is the neighbor of u, but vice versa is not true. The space needed to represent a directed graph using its adjacency list is E locations, where E denotes the number of edges, as here each edge data appears only once.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Space complexity = O(E)</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;iostream&gt;

using namespace std;

int main()
{
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    // adjacency list for directed graph
    // time complexity: O(E)
    vector&lt;int&gt; adj[n+1];
    for(int i = 0; i &lt; m; i++)
    {
        int u, v;
        // u —&gt; v
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].push_back(v);
    }
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Weighted Graph Representation</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>As of now, we were considering graphs with unit weight edges (i.e., if there is an edge between two nodes then the weight on the edge is unit weight ), now what if there are weights on its edges as shown in the following example?</p>
<!-- /wp:paragraph -->
<!-- wp:image {"width":250,"height":198} -->
<figure class="wp-block-image is-resized"><img alt="" height="198" src="assets/f421204b006d53705c4cd2ec0e808e46" width="250"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>For the <strong>adjacency matrix,</strong> it is much simpler.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"width":380,"height":135} -->
<figure class="wp-block-image is-resized"><img alt="" height="135" src="assets/9a7dcf90aba4849ce719edfee11a3e50" width="380"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>But how are we going to implement it in the <strong>adjacency list</strong>?</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Earlier in the adjacency list, we were storing a list of integers in each index, but for weighted graphs, we will store pairs (node, edge weight) in it.</p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted">vector&lt; pair &lt;int,int&gt; &gt; adjList[n+1];</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph -->
<p><strong><img height="131" src="assets/fd7d3fb8b44ab7e937dd269015fb83b3" width="287"/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/vanshika-singh-ba6b15157" rel="noreferrer noopener" target="_blank">Vanshika Singh Gour</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
<!-- wp:embed {"url":"https://www.youtube.com/watch?v=3oI-34aPMWM","type":"video","providerNameSlug":"youtube","responsive":true,"className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed is-type-video is-provider-youtube wp-block-embed-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://www.youtube.com/watch?v=3oI-34aPMWM
</div></figure>
<!-- /wp:embed -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>