<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>G-30 : Word Ladder-II</title>
<link href="assets/34bd07407ad1de576cba1f67651fa31a" rel="stylesheet"/>
<style>
        /* ==========================================================================
           1. CSS Variables (Theme) - Utilitarian Modern
           ========================================================================== */
        :root {
            /* Default to Light Theme */
            --primary-color: #3b82f6; /* Blue 500 */
            --primary-hover: #2563eb; /* Blue 600 */
            
            --bg-body: #f8fafc; /* Slate 50 */
            --bg-surface: #ffffff; /* White */
            --bg-subtle: #f1f5f9; /* Slate 100 */
            
            --border-color: #e2e8f0; /* Slate 200 */
            
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #334155; /* Slate 700 */
            --text-muted: #64748b; /* Slate 500 */
            
            --link-color: #2563eb; /* Blue 600 */
            --link-hover: #3b82f6; /* Blue 500 */

            --code-bg: #f1f5f9; /* Slate 100 */
            --code-text: #0f172a; /* Slate 900 */

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 0 25px -5px rgba(59, 130, 246, 0.25);
            
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
        }

        /* Dark Theme Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f172a; /* Slate 900 */
                --bg-surface: #1e293b; /* Slate 800 */
                --bg-subtle: #334155; /* Slate 700 */
                
                --border-color: #334155;
                
                --text-primary: #f8fafc; /* Slate 50 */
                --text-secondary: #cbd5e1; /* Slate 300 */
                --text-muted: #94a3b8; /* Slate 400 */
                
                --link-color: #60a5fa; /* Blue 400 */
                --link-hover: #93c5fd; /* Blue 300 */

                --code-bg: #020617; /* Slate 950 */
                --code-text: #f8fafc;
            }
        }

        /* ==========================================================================
           2. Base & Reset
           ========================================================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-body);
            margin: 0;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ==========================================================================
           3. Layout
           ========================================================================== */
        .container {
            max-width: 800px; /* Optimal reading width */
            margin: 0 auto;
            padding: 2rem;
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        /* Enhanced hover for desktop only */
        @media (hover: hover) and (pointer: fine) {
            .container:hover {
                transform: translateY(-4px);
                border-color: var(--primary-color);
                box-shadow: var(--shadow-hover);
            }
        }

        /* ==========================================================================
           4. Typography
           ========================================================================== */
        h1 {
            color: var(--text-primary);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.025em;
        }
        
        h2, h3, h4 {
            color: var(--text-secondary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.25em;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* ==========================================================================
           5. Media
           ========================================================================== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            margin: 1.5rem auto;
        }

        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            margin: 1.5rem 0;
            border-radius: var(--radius-md);
            background-color: var(--bg-subtle);
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ==========================================================================
           6. Code Blocks
           ========================================================================== */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            overflow-x: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        code {
            font-family: inherit;
        }

        /* ==========================================================================
           7. Code Tabs
           ========================================================================== */
        .code-section {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .code-tabs {
            display: flex;
            background-color: var(--bg-subtle);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .code-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .code-tab:hover {
            color: var(--text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .copy-btn {
            margin-left: auto;
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .copy-btn svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
        }
        
        .copy-btn:hover svg {
            fill: var(--text-primary);
        }

        .code-content {
            background-color: var(--code-bg);
        }
        
        .code-content pre {
            margin: 0;
            border-radius: 0;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ==========================================================================
           8. Accordions / Details
           ========================================================================== */
        details {
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: var(--bg-surface);
            transition: box-shadow 0.2s;
        }
        
        details:hover {
            box-shadow: var(--shadow-sm);
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: 1rem;
            background-color: var(--bg-subtle);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: #475569; /* Slate 600 */
        }
        
        /* Arrow icon rotation */
        summary .arrow-svg {
            transition: transform 0.3s ease;
            width: 20px;
            height: 20px;
            fill: var(--text-muted);
            flex-shrink: 0;
            transform-origin: center;
        }
        
        /* Only rotate the arrow of the *active* details element */
        details[open] > summary .arrow-svg {
            transform: rotate(90deg);
            fill: var(--primary-color);
        }

        .common-drops,
        .atricle_example_content,
        details > :not(summary) {
            padding: 0 0.5rem;
            background-color: var(--bg-surface);
        }

        /* Nested details */
        .secondary-details {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        .secondary-summary {
            background-color: rgba(51, 65, 85, 0.3); /* Semi-transparent slate-700 */
            font-size: 0.95rem;
        }
        
        .secondary-summary:hover {
            background-color: var(--bg-subtle);
        }
        
        .opacity-75 {
            opacity: 0.75;
        }

        /* ==========================================================================
           9. Practice & Disclaimer
           ========================================================================== */
        .practice, .new-disclaimer {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: var(--bg-subtle);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .problem-buttons a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        
        .problem-buttons a:hover {
            background-color: var(--primary-hover);
            text-decoration: none;
        }

        /* ==========================================================================
           10. Utilities
           ========================================================================== */
        .problem-buttons img,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article,
        .has-text-align-center {
            display: none;
        }
        
        .arrow-svg {
            display: inline-block; /* Ensure arrows are visible */
        }

        /* ==========================================================================
           11. Responsive (Full Page Mobile)
           ========================================================================== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border: none;
                border-radius: 0;
                box-shadow: none;
                padding: 0.5rem;
                max-width: 100%;
            }

            h1 {
                font-size: 1.5rem;
                text-align: left;
            }

            .code-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 2px; /* Space for scrollbar */
            }
            
            .code-tab {
                flex-shrink: 0;
            }

            .code-content pre {
                padding: 0.2rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>G-30 : Word Ladder-II</h1>
</header>
<article>
<!-- wp:paragraph -->
<p>Given two distinct words <strong>startWord</strong> and <strong>targetWord</strong>, and a list denoting wordList of unique words of equal lengths. Find all shortest transformation sequence(s) from startWord to targetWord. You can return them in any order possible.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>In this problem statement, we need to keep the following conditions in mind:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>A word can only consist of lowercase characters.</li><li>Only one letter can be changed in each transformation.</li><li>Each transformed word must exist in the wordList including the targetWord.</li><li>startWord may or may not be part of the wordList.</li><li>Return an empty list if there is no such transformation sequence.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note: </strong>Please watch the <a href="https://www.youtube.com/watch?v=tRPda0rcf8E&amp;list=PLgUwDviBIf0oE3gA41TKO2H5bHpPd7fzn&amp;index=29" rel="noopener" target="_blank" title="">previous video</a> of this series before moving on to this particular problem as this is just an extension of the problem <a href="https://practice.geeksforgeeks.org/problems/word-ladder/1" rel="noopener" target="_blank" title="">Word Ladder-I</a> that is being discussed previously. The approach used for this problem would be similar to the approach used in that question.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Examples:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:preformatted -->
<pre class="wp-block-preformatted"><strong>Example 1:</strong>
<strong>Input:</strong>
startWord = "der", targetWord = "dfs",
wordList = {"des","der","dfr","dgt","dfs"}
<strong>Output:</strong>
[ [ “der”, “dfr”, “dfs” ], [ “der”, “des”, “dfs”] ]
<strong>Explanation:</strong> 
The length of the smallest transformation sequence here is 3.
Following are the only two shortest ways to get to the targetWord from the startWord :
"der" -&gt; ( replace ‘r’ by ‘s’ ) -&gt; "des" -&gt; ( replace ‘e’ by ‘f’ ) -&gt; "dfs".
"der" -&gt; ( replace ‘e’ by ‘f’ ) -&gt; "dfr" -&gt; ( replace ‘r’ by ‘s’ ) -&gt; "dfs".

<strong>Example 2:</strong>
<strong>Input:</strong>
startWord = "gedk", targetWord= "geek"
wordList = {"geek", "gefk"}
<strong>Output:</strong>
[ [ “gedk”, “geek” ] ]
<strong>Explanation:</strong> 
The length of the smallest transformation sequence here is 2.
Following is the only shortest way to get to the targetWord from the startWord :
"gedk" -&gt; ( replace ‘d’ by ‘e’ ) -&gt; "geek".</pre>
<!-- /wp:preformatted -->
<!-- wp:paragraph {"textColor":"accent"} -->
<p class="has-accent-color has-text-color"><strong><em>Disclaimer</em>: </strong><em>Don’t jump directly to the solution, try it out yourself first.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: In case any image/dry run is not clear please refer to the video attached at the bottom. </p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Intuition:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>The intuition behind using the BFS traversal technique for these kinds of problems is that if we notice carefully, we go on replacing the characters one by one which seems just like we’re moving level-wise in order to reach the destination i.e. the targetWord. Here, in the example below we can notice there are two possible paths in order to reach the targetWord.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":6912,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-6912" src="assets/b8d048e26676d4a0ca41ec499cbd3ebc.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Contrary to the previous problem, here we do not stop the traversal on the first occurrence of the targetWord, but rather continue it for as many occurrences of the word as possible as we need <strong>all</strong> the shortest possible sequences in order to reach the destination word. The only trick here is that we <strong>do not </strong>have to delete a particular word immediately from the wordList even if during the replacement of characters it matches with the transformed word. Instead, we delete it after the traversal for a particular level when completed which allows us to explore all possible paths. This allows us to discover multiple sequences in order to reach the targetWord involving similar words. </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>From the above figure, we can configure that there can be 2 shortest possible sequences in order to reach the word ‘cog’.</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":3} -->
<h3><strong>Approach:</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>This problem uses the<a href="https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/"> BFS traversal</a> technique for finding out all the shortest possible transformation sequences by exploring all possible ways in which we can reach the targetWord.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Initial configuration:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li><strong>Queue: </strong>Define a queue data structure to store the level-wise formed sequences. The queue will be storing a List of strings, which will be representing the path till now. The last word in the list will be the last converted word. </li><li><strong>Hash set: </strong>Create a hash set to store the elements present in the word list to carry out the search and delete operations in O(1) time. </li><li><strong>Vector: </strong>Define a 1D vector ‘usedOnLevel’ to store the words which are currently being used for transformation on a particular level and a 2D vector ‘ans’ for storing all the shortest sequences of transformation.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>The Algorithm for this problem involves the following steps:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>Firstly, we start by creating a hash set to store all the elements present in the wordList which would make the search and delete operations faster for us to implement.</li><li>Next, we create a Queue data structure for storing the successive sequences/ path in the form of a vector which on transformation would lead us to the target word.</li><li>Now, we add the startWord to the queue as a List and also push it into the usedOnLevel vector to denote that this word is currently being used for transformation in this particular level.</li><li>Pop the first element out of the queue and carry out the <a href="https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/">BFS traversal</a>, where for each word that popped out from the back of the sequence present at the top of the queue, we check for all of its characters by replacing them with ‘a’ - ‘z’ if they are present in the wordList or not. In case a word is present in the wordList, we simply first push it onto the usedOnLevel vector and do not delete it from the wordList immediately.</li><li>Now, push that word into the vector containing the previous sequence and add it to the queue. So we will get a new path, but we need to explore other paths as well, so pop the word out of the list to explore other paths.</li><li>After completion of traversal on a particular level, we can now delete all the words that were currently being used on that level from the usedOnLevel vector which ensures that these words won’t be used again in the future, as using them in the later stages will mean that it won’t be the shortest path anymore.</li><li>If at any point in time we find out that the last word in the sequence present at the top of the queue is equal to the target word, we simply push the sequence into the resultant vector if the resultant vector ‘ans’ is empty.</li><li>If the vector is not empty, we check if the current sequence length is equal to the first element added in the ans vector or not. This has to be checked because we need the shortest possible transformation sequences.</li><li>In case, there is no transformation sequence possible, we return an empty 2D vector.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong><em>Note: If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em></strong> </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Code:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

class Solution
{
public:
    vector&lt;vector&lt;string&gt;&gt; findSequences(string beginWord, string endWord,
                                         vector&lt;string&gt; &amp;wordList)
    {
        // Push all values of wordList into a set
        // to make deletion from it easier and in less time complexity.
        unordered_set&lt;string&gt; st(wordList.begin(), wordList.end());
        
        // Creating a queue ds which stores the words in a sequence which is
        // required to reach the targetWord after successive transformations.
        queue&lt;vector&lt;string&gt;&gt; q;

        // BFS traversal with pushing the new formed sequence in queue 
        // when after a transformation, a word is found in wordList.

        q.push({beginWord});

        // A vector defined to store the words being currently used
        // on a level during BFS.
        vector&lt;string&gt; usedOnLevel;
        usedOnLevel.push_back(beginWord);
        int level = 0;
       
        // A vector to store the resultant transformation sequence.
        vector&lt;vector&lt;string&gt;&gt; ans;
        while (!q.empty())
        {
            vector&lt;string&gt; vec = q.front();
            q.pop();

            // Now, erase all words that have been
            // used in the previous levels to transform
            if (vec.size() &gt; level)
            {
                level++;
                for (auto it : usedOnLevel)
                {
                    st.erase(it);
                }
            }

            string word = vec.back();

            // store the answers if the end word matches with targetWord.
            if (word == endWord)
            {
                // the first sequence where we reached end
                if (ans.size() == 0)
                {
                    ans.push_back(vec);
                }
                else if (ans[0].size() == vec.size())
                {
                    ans.push_back(vec);
                }
            }
            for (int i = 0; i &lt; word.size(); i++)
            {   
                // Now, replace each character of ‘word’ with char
                // from a-z then check if ‘word’ exists in wordList.
                char original = word[i];
                for (char c = 'a'; c &lt;= 'z'; c++)
                {
                    word[i] = c;
                    if (st.count(word) &gt; 0)
                    { 
                        // Check if the word is present in the wordList and
                        // push the word along with the new sequence in the queue.
                        vec.push_back(word);
                        q.push(vec);
                        // mark as visited on the level
                        usedOnLevel.push_back(word);
                        vec.pop_back();
                    }
                }
                word[i] = original;
            }
        }
        return ans;
    }
};

// A comparator function to sort the answer.
bool comp(vector&lt;string&gt; a, vector&lt;string&gt; b)
{
    string x = "", y = "";
    for (string i : a)
        x += i;
    for (string i : b)
        y += i;

    return x &lt; y;
}

int main()
{

    vector&lt;string&gt; wordList = {"des", "der", "dfr", "dgt", "dfs"};
    string startWord = "der", targetWord = "dfs";
    Solution obj;
    vector&lt;vector&lt;string&gt;&gt; ans = obj.findSequences(startWord, targetWord, wordList);
    
    // If no transformation sequence is possible.
    if (ans.size() == 0)
        cout &lt;&lt; -1 &lt;&lt; endl;
    else
    {
        sort(ans.begin(), ans.end(), comp);
        for (int i = 0; i &lt; ans.size(); i++)
        {
            for (int j = 0; j &lt; ans[i].size(); j++)
            {
                cout &lt;&lt; ans[i][j] &lt;&lt; " ";
            }
            cout &lt;&lt; endl;
        }
    }

    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>der des dfs </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>der dfr dfs</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity and Space Complexity: </strong>It cannot be predicted for this particular algorithm because there can be multiple sequences of transformation from startWord to targetWord depending upon the example, so we cannot define a fixed range of time or space in which this program would run for all the test cases.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: This approach/code will give TLE when solved on the Leetcode platform due to the strict time constraints being put up there. So, you need to optimize it to a greater extent in order to pass all the test cases for LeetCode.For the optimized approach to this question please check out the <a href="https://www.youtube.com/watch?v=AD4SFl7tu7I" rel="noopener" target="_blank" title="">next video.</a></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.util.*;
import java.lang.*;
import java.io.*;

// A comparator function to sort the answer.
class comp implements Comparator &lt; ArrayList &lt; String &gt;&gt; {

    public int compare(ArrayList &lt; String &gt; a, ArrayList &lt; String &gt; b) {
        String x = "";
        String y = "";
        for (int i = 0; i &lt; a.size(); i++)
            x += a.get(i);
        for (int i = 0; i &lt; b.size(); i++)
            y += b.get(i);
        return x.compareTo(y);
    }
}

public class Main {

    public static void main(String[] args) throws IOException {
        String startWord = "der", targetWord = "dfs";
        String[] wordList = {
            "des",
            "der",
            "dfr",
            "dgt",
            "dfs"
        };

        Solution obj = new Solution();
        ArrayList &lt; ArrayList &lt; String &gt;&gt; ans = obj.findSequences(startWord, targetWord, wordList);
        
        // If no transformation sequence is possible.
        if (ans.size() == 0)
            System.out.println(-1);
        else {

            Collections.sort(ans, new comp());
            for (int i = 0; i &lt; ans.size(); i++) {
                for (int j = 0; j &lt; ans.get(i).size(); j++) {
                    System.out.print(ans.get(i).get(j) + " ");
                }
                System.out.println();
            }
        }
    }
}

class Solution {
    public ArrayList &lt; ArrayList &lt; String &gt;&gt; findSequences(String startWord, String targetWord,
        String[] wordList) {

        // Push all values of wordList into a set
        // to make deletion from it easier and in less time complexity.
        Set &lt; String &gt; st = new HashSet &lt; String &gt; ();
        int len = wordList.length;
        for (int i = 0; i &lt; len; i++) {
            st.add(wordList[i]);
        }

        // Creating a queue ds which stores the words in a sequence which is
        // required to reach the targetWord after successive transformations.
        Queue &lt; ArrayList &lt; String &gt;&gt; q = new LinkedList &lt; &gt; ();
        ArrayList &lt; String &gt; ls = new ArrayList &lt; &gt; ();
        ls.add(startWord);
        q.add(ls);
        ArrayList &lt; String &gt; usedOnLevel = new ArrayList &lt; &gt; ();
        usedOnLevel.add(startWord);
        int level = 0;

        // A vector to store the resultant transformation sequence.
        ArrayList &lt; ArrayList &lt; String &gt;&gt; ans = new ArrayList &lt; &gt; ();
        int cnt = 0;

        // BFS traversal with pushing the new formed sequence in queue 
        // when after a transformation, a word is found in wordList.
        while (!q.isEmpty()) {
            cnt++;
            ArrayList &lt; String &gt; vec = q.peek();
            q.remove();

             // Now, erase all words that have been
             // used in the previous levels to transform
             if (vec.size() &gt; level) {
                level++;
                for (String it: usedOnLevel) {
                    st.remove(it);
                }
            }

            String word = vec.get(vec.size() - 1);

            // store the answers if the end word matches with targetWord.
            if (word.equals(targetWord)) {
                // the first sequence where we reached the end.
                if (ans.size() == 0) {
                    ans.add(vec);
                } else if (ans.get(0).size() == vec.size()) {
                    ans.add(vec);
                }
            }
            for (int i = 0; i &lt; word.length(); i++) {

                // Now, replace each character of ‘word’ with char
                // from a-z then check if ‘word’ exists in wordList.
                for (char c = 'a'; c &lt;= 'z'; c++) {
                    char replacedCharArray[] = word.toCharArray();
                    replacedCharArray[i] = c;
                    String replacedWord = new String(replacedCharArray);
                    if (st.contains(replacedWord) == true) {
                        vec.add(replacedWord);
                        // Java works by reference, so enter the copy of vec
                        // otherwise if you remove word from vec in next lines, it will 
                        // remove from everywhere 
                        ArrayList &lt; String &gt; temp = new ArrayList &lt; &gt; (vec);
                        q.add(temp);
                        // mark as visited on the level 
                        usedOnLevel.add(replacedWord);
                        vec.remove(vec.size() - 1);
                    }
                }

            }
        }
        return ans;
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>der des dfs </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>der dfr dfs</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity and Space Complexity: </strong>It cannot be predicted for this particular algorithm because there can be multiple sequences of transformation from startWord to targetWord depending upon the example, so we cannot define a fixed range of time or space in which this program would run for all the test cases.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: This approach/code will give TLE when solved on the Leetcode platform due to the strict time constraints being put up there. So, you need to optimize it to a greater extent in order to pass all the test cases for LeetCode.For the optimized approach to this question please check out the <a href="https://www.youtube.com/watch?v=AD4SFl7tu7I" rel="noopener" target="_blank" title="">next video.</a></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/priyanshi-goel-7b6a42210/" rel="noreferrer noopener" target="_blank">Priyanshi Goel</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/" rel="noreferrer noopener" target="_blank">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>