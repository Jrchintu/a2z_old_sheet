<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Strongly Connected Components - Kosaraju's Algorithm: G-54</title>
<style>
        /* A clean, modern, and responsive base style for the articles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #fdfdfd;
            margin: 0;
            padding: 0;
        }

        /* Main container for the article content */
        .container {
            margin: 5px;
            /* Replaced '20px auto' to add margin on all sides */
            padding: 10px;
            background-color: #fff;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Main article title */
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 0.5em;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 0.5em;
            text-align: center;
        }

        /* Make images responsive and centered */
        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            display: block;
            /* To allow auto margins to work */
            margin: 1em auto;
            /* Adds some vertical spacing and centers horizontally */
        }

        /* Center figures which often wrap images */
        figure {
            text-align: center;
            margin: 1.5em 0;
        }

        /* Center and style YouTube video wrapper for responsiveness */
        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%;
            /* 16:9 Aspect Ratio */
            margin: 1.5em auto;
            /* Center block element */
            border-radius: 8px;
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* Basic code block styling */
        pre {
            background-color: #2d2d2d;
            /* A common dark background for code */
            color: #f8f8f2;
            padding: 10px;
            margin: 0px;
            border-radius: 5px;
            overflow-x: auto;
            /* Allow horizontal scrolling for long code lines */
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
            font-size: 0.9em;
        }

        code {
            font-family: "Fira Code", "Consolas", "Monaco", monospace;
        }

        /* Improve styling for links */
        a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.2s ease-in-out;
        }

        a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        /* --- Code Section Tabs Styling --- */
        .code-tabs {
            display: flex;
            border-bottom: 1px solid #e7e7e7;
            margin-bottom: 1em;
            align-items: center;
        }

        .code-tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            font-size: 1em;
            color: #555;
            transition: all 0.2s ease-in-out;
        }

        .code-tab:hover {
            background-color: #f9f9f9;
            color: #333;
        }

        .code-tab.dsa_article_code_active {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
        }

        .copy-btn {
            margin-left: auto;
            cursor: pointer;
            padding: 10px;
        }

        .copy-btn path {
            fill: #aaa;
            transition: fill 0.2s;
        }

        .copy-btn:hover path {
            fill: #333;
        }

        .copy-btn.dsa_article_code_active path {
            fill: #3498db;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* Practice */
        .practice,
        .new-disclaimer {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
        }

        .new-disclaimer {
            justify-content: center;
        }

        /* --- End Code Section Tabs Styling --- */

        /* --- Accordion/Dropdown Styling --- */
        details {
            margin-bottom: 1em;
            border: 1px solid #e7e7e7;
            border-radius: 6px;
            overflow: hidden;
            /* Keeps content within rounded corners */
            padding: 0;
            /* Reset any default padding */
        }

        summary {
            list-style: none;
            /* Hide the default marker */
            cursor: pointer;
            padding: 15px 20px;
            background-color: #f9f9f9;
            font-weight: 500;
            color: #2c3e50;
            transition: background-color 0.2s ease-in-out;
        }

        summary::-webkit-details-marker {
            display: none;
            /* Hide default marker for Chrome/Safari */
        }

        summary:hover {
            background-color: #f1f1f1;
        }

        /* Content inside the dropdowns */
        .common-drops,
        .atricle_example_content {
            padding: 10px 10px 0;
            border-bottom: 10px;
            background-color: #fff;
            border-top: 1px solid #e7e7e7;
        }

        /* Full padding for example */
        .atricle_example_content {
            padding: 10px;
        }

        /* Additional padding for details content that doesn't have specific classes */
        details> :not(summary) {
            padding-left: 10px;
            padding-right: 10px;
        }

        .dsa_article_youtube_video .yt-video-wrapper {
            padding-top: 56.25%;
            margin: 0;
            border-radius: 0;
            padding-left: 0;
            padding-right: 0;
        }

        /* Nested dropdown summaries */
        .secondary-summary {
            background-color: #fafafa;
            padding: 12px 20px;
            font-weight: normal;
        }

        .secondary-summary:hover {
            background-color: #f0f0f0;
        }

        /* --- End Accordion/Dropdown Styling --- */

        /* Hide specific UI elements based on user request */
        .problem-buttons img,
        .arrow-svg,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article {
            display: none;
        }

        /* Responsive adjustments */
        @media (min-width: 769px) {
            .container {
                max-width: 960px;
                margin: 20px auto;
            }
        }

        @media (max-width: 768px) {
            .container {
                margin: 0;
                padding: 10px;
            }

            h1 {
                font-size: 2em;
            }

            .code-tabs {
                flex-wrap: wrap;
                /* Allow tabs to wrap on small screens */
            }

            /* Reduce padding on mobile for details sections */
            details> :not(summary) {
                padding-left: 10px;
                padding-right: 10px;
            }

            .common-drops,
            .atricle_example_content {
                padding: 10px 10px 0;
            }

            .atricle_example_content {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Strongly Connected Components - Kosaraju's Algorithm: G-54</h1>
</header>
<article>
<!-- wp:paragraph -->
<p><strong>Problem Statement:</strong> Given a Directed Graph with V vertices (Numbered from 0 to V-1) and E edges, Find the number of strongly connected components in the graph.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Pre-requisite: </strong><a href="https://takeuforward.org/data-structure/depth-first-search-dfs/" rel="noopener" target="_blank" title=""><strong>DFS algorithm</strong></a></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Example 1</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<pre>
<b>Input Format:</b>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7129" src="assets/cfe447c8a6b9f5ea92ee1353216fc0f1.png"/></figure>
<b>Result:</b> 3
<b>Explanation:</b> Three strongly connected components are marked below:
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7130" src="assets/3f65a2ca78081e741a605f6e54adeb67.png"/></figure>
</pre>
<!-- /wp:html -->
<!-- wp:paragraph -->
<p><strong>Example 2</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:html -->
<pre>
<b>Input Format:</b>
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7131" src="assets/4d77837c8dfca28f0ea5b1c1003b1139.png"/></figure>
<b>Result:</b> 4
<b>Explanation:</b> Four strongly connected components are marked below:
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7132" src="assets/0f9f039b2876e69118b19eb3245f7a2d.png"/></figure>
</pre>
<!-- /wp:html -->
<!-- wp:heading {"level":3} -->
<h3><strong>Solution</strong></h3>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p><strong><em>Disclaimer</em></strong>: <em>Don't jump directly to the solution, try it out yourself first. </em><a href="https://practice.geeksforgeeks.org/problems/strongly-connected-components-kosarajus-algo/1?utm_source=youtube&amp;utm_medium=collab_striver_ytdescription&amp;utm_campaign=strongly-connected-components-kosarajus-algo"><em>Problem Link</em></a><em>.</em></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Solution:</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>In this article, we are going to discuss strongly connected components(SCC) and Kosaraju’s algorithm. In an interview, we can expect two types of questions from this topic:</p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li><strong><em>Find the number of strongly connected components of a given graph.</em></strong></li><li><strong><em>Print the strongly connected components of a given graph.</em></strong></li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p>In this article, we are going to discuss the logic part in detail and once the logic part is clear, these two types of questions can be easily solved.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong><em>Strongly connected components(SCC) are only valid for directed graphs.</em></strong> </p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Strongly Connected Component(SCC):</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>A component is called a Strongly Connected Component(SCC) only if for every possible pair of vertices (u, v) inside that component, u is reachable from v and v is reachable from u.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>In the following directed graph, the SCCs have been marked:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7133,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7133" src="assets/17595900ef23fef2ca0ffb41b04d55f1.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>If we take 1st SCC in the above graph, we can observe that each node is reachable from any of the other nodes. For example, if take the pair (0, 1) from the 1st SCC, we can see that 0 is reachable from 1 and 1 is also reachable from 0. Similarly, this is true for all other pairs of nodes in the SCC like (0,2), and (1,2). But if we take node 3 with the component, we can notice that for pair (2,3) 3 is reachable from 3 but 2 is not reachable from 3. So, the first SCC only includes vertices 0, 1, and 2.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>By definition, <strong><em>a component containing a single vertex is always a strongly connected component</em></strong>. For that vertex 3 in the above graph is itself a strongly connected component.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>By applying this logic, we can conclude that the above graph contains 4 strongly connected components like (0,1,2), (3), (4,5,6), and (7).</p>
<!-- /wp:paragraph -->
<!-- wp:heading {"level":4} -->
<h4><strong>Kosaraju’s Algorithm:</strong></h4>
<!-- /wp:heading -->
<!-- wp:paragraph -->
<p>To find the strongly connected components of a given directed graph, we are going to use Kosaraju’s Algorithm.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Before understanding the algorithm, we are going to discuss the thought process behind it. If we start DFS from node 0 for the following graph, we will end up visiting all the nodes. So, it is impossible to differentiate between different SCCs.</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7134,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7134" src="assets/2c4ba2d1a64e8ac9791130a41d39ae1b.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Now, we need to think in a different way. We can convert the above graph into the following illustration:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7135,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7135" src="assets/674ae3cf9257e9c59d2a35992affe71e.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>By definition, within each SCC, every node is reachable. So, if we start DFS from a node of SCC1 we can visit all the nodes in SCC1 and via edge e1 we can reach SCC2. Similarly, we can travel from SCC2 to SCC3 via e2 and SCC3 to SCC4 via e3. Thus all the nodes of the graph become reachable.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>But if we reverse the edges e1, e2, and e3, the graph will look like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7136,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7136" src="assets/c3f5ae7b68f619da1e82c740d328c5d8.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>Now in this graph, if we start DFS from node 0 it will visit only the nodes of SCC1. Similarly, if we start from node 3 it will visit only the nodes of SCC2. Thus, by reversing the SCC-connecting edges, the adjacent SCCs become unreachable. Now, the DFS will work in such a way, that in one DFS call we can only visit the nodes of a particular SCC. So,<strong><em> the number of DFS calls will represent the number of SCCs</em></strong>.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Until now, we have successfully found out the process of getting the number of SCCs. But here, comes a new problem i.e. if we do not know the SCCs, how the edges will be reversed? To solve this problem, we will simply try to reverse all the edges of the graph like the following:</p>
<!-- /wp:paragraph -->
<!-- wp:image {"id":7138,"sizeSlug":"full","linkDestination":"none"} -->
<figure class="wp-block-image size-full"><img alt="" class="wp-image-7138" src="assets/32821672b47fc1c38b00febcbfc70e62.png"/></figure>
<!-- /wp:image -->
<!-- wp:paragraph -->
<p>If we carefully observe, the nodes within an SCC are reachable from each one to everyone even if we reverse the edges of the SCC. So, the SCCs will have no effect on reversing the edges. Thus we can fulfill our intention of reversing the SCC-connecting edge without affecting the SCCs.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now, the question might be like, if node 0 is located in SCC4 and we start DFS from node 0, again we will visit all the SCCs at once even after reversing the edges. This is where <strong><em>the</em></strong> <strong><em>starting time and the finishing time</em></strong> concept will come in.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>Now, we have a clear intuition about reversing edges before we move on to the starting and the finishing time concept in the algorithm part.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Algorithm</strong>: </p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p>The algorithm steps are as follows:</p>
<!-- /wp:paragraph -->
<!-- wp:list {"ordered":true} -->
<ol><li><strong><em>Sort all the nodes according to their finishing time:</em></strong><strong><em><br/></em></strong>To sort all the nodes according to their finishing time, we will start DFS from node 0 and while backtracking in the DFS call we will store the nodes in a stack data structure. The nodes in the last SCC will finish first and will be stored in the last of the stack. After the DFS gets completed for all the nodes, the stack will be storing all the nodes in the sorted order of their finishing time.<br/></li><li><strong><em>Reverse all the edges of the entire graph:</em></strong><strong><em><br/></em></strong>Now, we will create another adjacency list and store the information of the graph in a reversed manner.<br/></li><li><strong><em>Perform the DFS and count the no. of different DFS calls to get the no. of SCC:</em></strong><strong><em><br/></em></strong>Now, we will start DFS from the node which is on the top of the stack and continue until the stack becomes empty. For each individual DFS call, we will increment the counter variable by 1. We will get the number of SCCs by just counting the number of individual DFS calls as in each individual DFS call, all the nodes of a particular SCC get visited.<br/></li><li>Finally, we will get the number of SCCs in the counter variable. If we want to store the SCCs as well, we need to store the nodes in some array during each individual DFS call in step 3.</li></ol>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note: </strong></p>
<!-- /wp:paragraph -->
<!-- wp:list -->
<ul><li>The first step is to know, from which node we should start the DFS call.</li><li>The second step is to make adjacent SCCs unreachable and to limit the DFS traversal in such a way, that in each DFS call, all the nodes of a particular SCC get visited.</li><li>The third step is to get the numbers of the SCCs. In this step, we can also store the nodes of each SCC if we want to do so.</li></ul>
<!-- /wp:list -->
<!-- wp:paragraph -->
<p><strong>Note: </strong><em>The sorting of the nodes according to their finishing time is very important. By performing this step, we will get to know where we should start our DFS calls. The top-most element of the stack will finish last and it will surely belong to the SCC1. So, the sorting step is important for the algorithm. </em><strong><br/></strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Note</strong>: <em>If you wish to see the dry run of the above approach, you can watch the video attached to this article.</em><br/><strong>Code</strong>:</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<div class="code-section secondary-details">
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-cpp" lang="cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;




class Solution
{
private:
    void dfs(int node, vector&lt;int&gt; &amp;vis, vector&lt;int&gt; adj[],
             stack&lt;int&gt; &amp;st) {
        vis[node] = 1;
        for (auto it : adj[node]) {
            if (!vis[it]) {
                dfs(it, vis, adj, st);
            }
        }

        st.push(node);
    }
private:
    void dfs3(int node, vector&lt;int&gt; &amp;vis, vector&lt;int&gt; adjT[]) {
        vis[node] = 1;
        for (auto it : adjT[node]) {
            if (!vis[it]) {
                dfs3(it, vis, adjT);
            }
        }
    }
public:
    //Function to find number of strongly connected components in the graph.
    int kosaraju(int V, vector&lt;int&gt; adj[])
    {
        vector&lt;int&gt; vis(V, 0);
        stack&lt;int&gt; st;
        for (int i = 0; i &lt; V; i++) {
            if (!vis[i]) {
                dfs(i, vis, adj, st);
            }
        }

        vector&lt;int&gt; adjT[V];
        for (int i = 0; i &lt; V; i++) {
            vis[i] = 0;
            for (auto it : adj[i]) {
                // i -&gt; it
                // it -&gt; i
                adjT[it].push_back(i);
            }
        }
        int scc = 0;
        while (!st.empty()) {
            int node = st.top();
            st.pop();
            if (!vis[node]) {
                scc++;
                dfs3(node, vis, adjT);
            }
        }
        return scc;
    }
};

int main() {

    int n = 5;
    int edges[5][2] = {
        {1, 0}, {0, 2},
        {2, 1}, {0, 3},
        {3, 4}
    };
    vector&lt;int&gt; adj[n];
    for (int i = 0; i &lt; n; i++) {
        adj[edges[i][0]].push_back(edges[i][1]);
    }
    Solution obj;
    int ans = obj.kosaraju(n, adj);
    cout &lt;&lt; "The number of strongly connected components is: " &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: The number of strongly connected components is: 3 (For example 1)</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(V+E) + O(V+E) + O(V+E) ~ O(V+E) , where V = no. of vertices, E = no. of edges. The first step is a simple DFS, so the first term is O(V+E). The second step of reversing the graph and the third step, containing DFS again, will take O(V+E) each.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(V)+O(V)+O(V+E), where V = no. of vertices, E = no. of edges. Two O(V) for the visited array and the stack we have used. O(V+E) space for the reversed adjacent list.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
<div class="code-block" data-lang="java">
<!-- /wp:paragraph -->
<!-- wp:code -->
<pre class="wp-block-code"><code class="language-java" lang="java">import java.io.*;
import java.util.*;



//User function Template for Java


class Solution {
    private void dfs(int node, int []vis, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj,
                     Stack&lt;Integer&gt; st) {
        vis[node] = 1;
        for (Integer it : adj.get(node)) {
            if (vis[it] == 0) {
                dfs(it, vis, adj, st);
            }
        }
        st.push(node);
    }
    private void dfs3(int node, int[] vis, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjT) {
        vis[node] = 1;
        for (Integer it : adjT.get(node)) {
            if (vis[it] == 0) {
                dfs3(it, vis, adjT);
            }
        }
    }
    //Function to find number of strongly connected components in the graph.
    public int kosaraju(int V, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj) {
        int[] vis = new int[V];
        Stack&lt;Integer&gt; st = new Stack&lt;Integer&gt;();
        for (int i = 0; i &lt; V; i++) {
            if (vis[i] == 0) {
                dfs(i, vis, adj, st);
            }
        }

        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adjT = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();
        for (int i = 0; i &lt; V; i++) {
            adjT.add(new ArrayList&lt;Integer&gt;());
        }
        for (int i = 0; i &lt; V; i++) {
            vis[i] = 0;
            for (Integer it : adj.get(i)) {
                // i -&gt; it
                // it -&gt; i
                adjT.get(it).add(i);
            }
        }
        int scc = 0;
        while (!st.isEmpty()) {
            int node = st.peek();
            st.pop();
            if (vis[node] == 0) {
                scc++;
                dfs3(node, vis, adjT);
            }
        }
        return scc;
    }
}

class Main {
    public static void main (String[] args) {
        int n = 5;
        int[][] edges = {
            {1, 0}, {0, 2},
            {2, 1}, {0, 3},
            {3, 4}
        };
        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) {
            adj.add(new ArrayList&lt;Integer&gt;());
        }
        for (int i = 0; i &lt; n; i++) {
            adj.get(edges[i][0]).add(edges[i][1]);
        }
        Solution obj = new Solution();
        int ans = obj.kosaraju(n, adj);
        System.out.println("The number of strongly connected components is: " + ans);
    }
}
</code></pre>
<!-- /wp:code -->
<!-- wp:paragraph -->
<p><strong>Output: The number of strongly connected components is: 3 (For example 1)</strong></p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Time Complexity: </strong>O(V+E) + O(V+E) + O(V+E) ~ O(V+E) , where V = no. of vertices, E = no. of edges. The first step is a simple DFS, so the first term is O(V+E). The second step of reversing the graph and the third step, containing DFS again, will take O(V+E) each.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
<p><strong>Space Complexity: </strong>O(V)+O(V)+O(V+E), where V = no. of vertices, E = no. of edges. Two O(V) for the visited array and the stack we have used. O(V+E) space for the reversed adjacent list.</p>
<!-- /wp:paragraph -->
<!-- wp:paragraph -->
</div>
</div>
</div>
<!-- /wp:paragraph -->
<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>Special thanks to <strong><a href="https://www.linkedin.com/in/kriti39/" rel="noreferrer noopener" target="_blank"><strong>KRITIDIPTA GHOSH</strong></a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam, </em><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/">please check out this article</a>. <em>If you want to suggest any improvement/correction in this article please mail us at write4tuf@gmail.com</em></p></blockquote>
<!-- /wp:quote -->
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (active.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>