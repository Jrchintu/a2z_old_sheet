<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Count Number of Nodes in a Binary Tree</title>
<link href="assets/34bd07407ad1de576cba1f67651fa31a" rel="stylesheet"/>
<style>
        /* ==========================================================================
           1. CSS Variables (Theme) - Utilitarian Modern
           ========================================================================== */
        :root {
            /* Default to Light Theme */
            --primary-color: #3b82f6; /* Blue 500 */
            --primary-hover: #2563eb; /* Blue 600 */
            
            --bg-body: #f8fafc; /* Slate 50 */
            --bg-surface: #ffffff; /* White */
            --bg-subtle: #f1f5f9; /* Slate 100 */
            
            --border-color: #e2e8f0; /* Slate 200 */
            
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #334155; /* Slate 700 */
            --text-muted: #64748b; /* Slate 500 */
            
            --link-color: #2563eb; /* Blue 600 */
            --link-hover: #3b82f6; /* Blue 500 */

            --code-bg: #f1f5f9; /* Slate 100 */
            --code-text: #0f172a; /* Slate 900 */

            --radius-sm: 4px;
            --radius-md: 6px;
            --radius-lg: 8px;
            
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 0 25px -5px rgba(59, 130, 246, 0.25);
            
            --spacing-sm: 0.5rem;
            --spacing-md: 1rem;
            --spacing-lg: 1.5rem;
        }

        /* Dark Theme Support */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg-body: #0f172a; /* Slate 900 */
                --bg-surface: #1e293b; /* Slate 800 */
                --bg-subtle: #334155; /* Slate 700 */
                
                --border-color: #334155;
                
                --text-primary: #f8fafc; /* Slate 50 */
                --text-secondary: #cbd5e1; /* Slate 300 */
                --text-muted: #94a3b8; /* Slate 400 */
                
                --link-color: #60a5fa; /* Blue 400 */
                --link-hover: #93c5fd; /* Blue 300 */

                --code-bg: #020617; /* Slate 950 */
                --code-text: #f8fafc;
            }
        }

        /* ==========================================================================
           2. Base & Reset
           ========================================================================== */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-primary);
            background-color: var(--bg-body);
            margin: 0;
            padding: 2rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ==========================================================================
           3. Layout
           ========================================================================== */
        .container {
            max-width: 800px; /* Optimal reading width */
            margin: 0 auto;
            padding: 2rem;
            background-color: var(--bg-surface);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        /* Enhanced hover for desktop only */
        @media (hover: hover) and (pointer: fine) {
            .container:hover {
                transform: translateY(-4px);
                border-color: var(--primary-color);
                box-shadow: var(--shadow-hover);
            }
        }

        /* ==========================================================================
           4. Typography
           ========================================================================== */
        h1 {
            color: var(--text-primary);
            font-size: 2rem;
            margin-top: 0;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.025em;
        }
        
        h2, h3, h4 {
            color: var(--text-secondary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        p {
            margin-bottom: 1.25em;
        }

        a {
            color: var(--link-color);
            text-decoration: none;
            font-weight: 500;
        }

        a:hover {
            color: var(--link-hover);
            text-decoration: underline;
        }

        /* ==========================================================================
           5. Media
           ========================================================================== */
        img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            display: block;
            margin: 1.5rem auto;
        }

        .yt-video-wrapper {
            position: relative;
            overflow: hidden;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            margin: 1.5rem 0;
            border-radius: var(--radius-md);
            background-color: var(--bg-subtle);
        }

        .yt-video-wrapper iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        /* ==========================================================================
           6. Code Blocks
           ========================================================================== */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: var(--radius-md);
            overflow-x: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        code {
            font-family: inherit;
        }

        /* ==========================================================================
           7. Code Tabs
           ========================================================================== */
        .code-section {
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .code-tabs {
            display: flex;
            background-color: var(--bg-subtle);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .code-tab {
            padding: 0.75rem 1rem;
            cursor: pointer;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-muted);
            white-space: nowrap;
        }

        .code-tab:hover {
            color: var(--text-primary);
        }

        .code-tab.dsa_article_code_active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
        }

        .copy-btn {
            margin-left: auto;
            padding: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
        }
        
        .copy-btn svg {
            width: 16px;
            height: 16px;
            fill: var(--text-muted);
        }
        
        .copy-btn:hover svg {
            fill: var(--text-primary);
        }

        .code-content {
            background-color: var(--code-bg);
        }
        
        .code-content pre {
            margin: 0;
            border-radius: 0;
        }

        .code-block {
            display: none;
        }

        .code-block.dsa_article_code_active {
            display: block;
        }

        /* ==========================================================================
           8. Accordions / Details
           ========================================================================== */
        details {
            margin-bottom: 1rem;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            overflow: hidden;
            background-color: var(--bg-surface);
            transition: box-shadow 0.2s;
        }
        
        details:hover {
            box-shadow: var(--shadow-sm);
        }

        summary {
            list-style: none;
            cursor: pointer;
            padding: 1rem;
            background-color: var(--bg-subtle);
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: background-color 0.2s;
            user-select: none;
        }

        summary::-webkit-details-marker {
            display: none;
        }

        summary:hover {
            background-color: #475569; /* Slate 600 */
        }
        
        /* Arrow icon rotation */
        summary .arrow-svg {
            transition: transform 0.3s ease;
            width: 20px;
            height: 20px;
            fill: var(--text-muted);
            flex-shrink: 0;
            transform-origin: center;
        }
        
        /* Only rotate the arrow of the *active* details element */
        details[open] > summary .arrow-svg {
            transform: rotate(90deg);
            fill: var(--primary-color);
        }

        .common-drops,
        .atricle_example_content,
        details > :not(summary) {
            padding: 0.5rem;
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-surface);
        }

        /* Nested details */
        .secondary-details {
            margin: 1rem 0;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-sm);
        }
        
        .secondary-summary {
            background-color: rgba(51, 65, 85, 0.3); /* Semi-transparent slate-700 */
            font-size: 0.95rem;
        }
        
        .secondary-summary:hover {
            background-color: var(--bg-subtle);
        }
        
        .opacity-75 {
            opacity: 0.75;
        }

        /* ==========================================================================
           9. Practice & Disclaimer
           ========================================================================== */
        .practice, .new-disclaimer {
            margin: 2rem 0;
            padding: 1.5rem;
            background-color: var(--bg-subtle);
            border-radius: var(--radius-md);
            text-align: center;
        }
        
        .problem-buttons a {
            display: inline-block;
            margin-top: 0.5rem;
            padding: 0.5rem 1rem;
            background-color: var(--primary-color);
            color: white;
            border-radius: var(--radius-sm);
            font-weight: 600;
        }
        
        .problem-buttons a:hover {
            background-color: var(--primary-hover);
            text-decoration: none;
        }

        /* ==========================================================================
           10. Utilities
           ========================================================================== */
        .problem-buttons img,
        .box-e.tooltip,
        .three-boxes.box-d svg,
        .horizontal_navbar_dsa_article,
        .has-text-align-center {
            display: none;
        }
        
        .arrow-svg {
            display: inline-block; /* Ensure arrows are visible */
        }

        /* ==========================================================================
           11. Responsive (Full Page Mobile)
           ========================================================================== */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border: none;
                border-radius: 0;
                box-shadow: none;
                padding: 0.5rem;
                max-width: 100%;
            }

            h1 {
                font-size: 1.5rem;
                text-align: left;
            }

            .code-tabs {
                overflow-x: auto;
                justify-content: flex-start;
                padding-bottom: 2px; /* Space for scrollbar */
            }
            
            .code-tab {
                flex-shrink: 0;
            }

            .code-content pre {
                padding: 0.2rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
<header>
<h1>Count Number of Nodes in a Binary Tree</h1>
</header>
<article>
<p><strong>Problem Statement: </strong> Given a Complete Binary Tree, count and return the number of nodes in the given tree.
A Complete Binary Tree is a binary tree in which all levels are completely filled, except possibly for the last level, and all nodes are as left as possible.
</p>
<!-- This is Examples Drop-Down -->
<div id="article_examples">
<details class="article_example_details">
<summary class="article_example_summary">
<span><strong>
                    Examples
                </strong>
</span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="atricle_example_content">
<pre class="wp-block-preformatted">
                <span><strong>Example 1:</strong></span>
                <span><strong>Input:</strong> Binary Tree: 1 2 3 4 5 6</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/1661f6cbd421a03c5d2dcf922fad0649" width="439"/></figure>
                <span><strong>Output:</strong> 6</span>
                <span><strong>Explanation: </strong>There are 6 nodes in this Binary Tree.</span>
                <figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/c155fe884207858065ee07d363a4381a" width="439"/></figure>
                <span><strong>Example 2:</strong></span>
                <span><strong>Input:</strong> Binary Tree: 2 4 3 5 9 8 7 1 6
                </span>
                <!--<figure class="wp-block-image size-full is-resized"><img src="https://static.takeuforward.org/content/lca-tree-image2-kwG05v8u" alt="" class="wp-image-8107" width="439" height="286"/></figure>-->
                <span><strong>Output :</strong> 9</span>
                <span><strong>Explanation: </strong>There are 9 nodes in this Binary Tree.</span>
                <!--<figure class="wp-block-image size-full is-resized"><img src="https://static.takeuforward.org/content/lca-tree-image4-sSf-8mj-" alt="" class="wp-image-8107" width="439" height="286"/></figure>-->

            </pre>
</div>
</details>
</div>
<!-- This is Practice Section-->
<div class="practice">
<span><strong>Practice: </strong></span>
<div class="problem-buttons">
<!-- Add Problem Link inside href -->
<a href="https://www.codingninjas.com/studio/problems/nodes-in-complete-binary-tree_1281151?utm_source=striver&amp;utm_medium=website&amp;utm_campaign=a_zcoursetuf" rel="noopener" target="_blank">
<span>Solve Problem</span>
<img alt="code-studio" src="assets/20f60e7969e701b07a63accd93ffe638"/>
</a>
</div>
</div>
<p class="new-disclaimer"><strong><em>Disclaimer</em></strong>: <em>Don’t jump directly to the solution, try it out yourself first. </em></p>
<!-- This is Approaches Drop-Down -->
<div class="dsa_article_dropdown_approachs">
<!-- Approach - 1 Starts from here -->
<div id="brute-force-approach">
<details>
<summary class="main-summary">
<span>
<!-- Change Name Here -->
                   Brute Force Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>Complete Binary Tree: A complete binary tree is a binary tree where all levels, except possibly the last one, are completely filled, and the nodes in the last level are as left as possible. Read more about it here: <a href="https://takeuforward.org/binary-tree/introduction-to-trees/"> Introduction to Trees</a></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/f6ebe1fc14e9cdbd65d57656d31c9330" width="439"/></figure>
<p>A brute force approach would be to traverse the tree using inorder (or any) traversal and count the number of nodes as we are traversing the tree. In Inorder traversal, we visit the left subtree first, then the current node, and finally the right subtree. By incrementing the counter for each visited node, we effectively count all nodes in the binary tree.</p>
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1:</strong> Start by initialising a variable to count (initial value 0) the number of nodes in the binary tree</p>
<p><strong>Step 2:</strong>Define a recursive inorder function:</p>
<p>Base Case: If the current node is null, return from the void function.</p>
<p>Recursive Call: If the current node is not null, call the function for its left child.
                        <ol><li>Increment the counter by 1 for each node.</li><li>Recursively call the function on the right child of the current node as well.</li></ol></p>
<p><strong>Step 3:</strong>   Start the inorder traversal from the root of the Binary Tree by calling the recursive function on the root node with initial count to 0.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/f3f9278176945b03f4775a67ea48bd27" width="439"/></figure>
<p><strong>Step 4:</strong> Return the final value of the count variable after the traversal representing the total number of nodes.</p>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

// TreeNode structure
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};


class Solution {
public:
    // Function to perform inorder
    // traversal and count nodes
    void inorder(TreeNode* root, int &amp;count) {
        // Base case: If the current
        // node is NULL, return
        if (root == NULL) {
            return;
        }

        // Increment count
        // for the current node
        count++;

        // Recursively call inorder
        // on the left subtree
        inorder(root-&gt;left, count);

        // Recursively call inorder
        // on the right subtree
        inorder(root-&gt;right, count);
    }

    // Function to count nodes in the binary tree
    int countNodes(TreeNode* root) {
        // Base case: If the root is NULL,
        // the tree is empty, return 0
        if (root == NULL) {
            return 0;
        }

        // Initialize count variable to
        // store the number of nodes
        int count = 0;

        // Call the inorder traversal
        // function to count nodes
        inorder(root, count);

        // Return the final count of
        // nodes in the binary tree
        return count;
    }
};




int main() {
    // Create the binary tree
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;left = new TreeNode(6);

    Solution sol;

    // Call the countNodes function
    int totalNodes = sol.countNodes(root);

    // Print the result
    cout &lt;&lt; "Total number of nodes in the Complete Binary Tree: "
            &lt;&lt; totalNodes &lt;&lt; endl;



    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.*;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to perform inorder
    // traversal and count nodes
    public void inorder(TreeNode root, int[] count) {
        // Base case: If the current
        // node is null, return
        if (root == null) {
            return;
        }

        // Increment count
        // for the current node
        count[0]++;

        // Recursively call inorder
        // on the left subtree
        inorder(root.left, count);

        // Recursively call inorder
        // on the right subtree
        inorder(root.right, count);
    }

    // Function to count nodes in the binary tree
    public int countNodes(TreeNode root) {
        // Base case: If the root is null,
        // the tree is empty, return 0
        if (root == null) {
            return 0;
        }

        // Initialize count variable to
        // store the number of nodes
        int[] count = {0};

        // Call the inorder traversal
        // function to count nodes
        inorder(root, count);

        // Return the final count of
        // nodes in the binary tree
        return count[0];
    }

    public static void main(String[] args) {
        // Create the binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);

        Solution sol = new Solution();

        // Call the countNodes function
        int totalNodes = sol.countNodes(root);

        // Print the result
        System.out.println("Total number of nodes in the Complete Binary Tree: " + totalNodes);
    }
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
# TreeNode class definition
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def inorder(self, root, count):
        """
        Function to perform inorder traversal and count nodes
        """
        # Base case: If the current node is None, return
        if root is None:
            return

        # Increment count for the current node
        count[0] += 1

        # Recursively call inorder on the left subtree
        self.inorder(root.left, count)

        # Recursively call inorder on the right subtree
        self.inorder(root.right, count)

    def countNodes(self, root):
        """
        Function to count nodes in the binary tree
        """
        # Base case: If the root is None, the tree is empty, return 0
        if root is None:
            return 0

        # Initialize count variable to store the number of nodes
        count = [0]

        # Call the inorder traversal function to count nodes
        self.inorder(root, count)

        # Return the final count of nodes in the binary tree
        return count[0]


# Main function
if __name__ == "__main__":
    # Create the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)

    sol = Solution()

    # Call the countNodes function
    totalNodes = sol.countNodes(root)

    # Print the result
    print("Total number of nodes in the Complete Binary Tree:", totalNodes)
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// TreeNode structure
class TreeNode {
    constructor(x) {
        this.val = x;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to perform inorder
    // traversal and count nodes
    inorder(root, count) {
        // Base case: If the current
        // node is null, return
        if (root === null) {
            return;
        }

        // Increment count
        // for the current node
        count++;

        // Recursively call inorder
        // on the left subtree
        this.inorder(root.left, count);

        // Recursively call inorder
        // on the right subtree
        this.inorder(root.right, count);
    }

    // Function to count nodes in the binary tree
    countNodes(root) {
        // Base case: If the root is null,
        // the tree is empty, return 0
        if (root === null) {
            return 0;
        }

        // Initialize count variable to
        // store the number of nodes
        let count = 0;

        // Call the inorder traversal
        // function to count nodes
        this.inorder(root, count);

        // Return the final count of
        // nodes in the binary tree
        return count;
    }
}

// Create the binary tree
let root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.left = new TreeNode(6);

let sol = new Solution();

// Call the countNodes function
let totalNodes = sol.countNodes(root);

// Print the result
console.log("Total number of nodes in the Complete Binary Tree: " + totalNodes);

                            </code>
                        </pre>
</div>
<p>
<strong>Output: </strong>Total number of nodes in the Complete Binary Tree: 6
                        </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p><strong>Time Complexity: O(N)</strong> where N is the number of nodes in the binary tree as each node of the binary tree is visited exactly once.</p>
<p><strong>Space Complexity : O(N)</strong> where N is the number of nodes in the binary tree. This is because the recursive stack uses an auxiliary space which can potentially hold all nodes in the tree when dealing with a skewed tree (all nodes have only one child), consuming space proportional to the number of nodes.
                        In the average case or for a balanced tree, the maximum number of nodes that could be in the stack at any given time would be roughly the height of the tree hence O(log2N).

                    </p>
</details>
</div>
</details>
</div>
<!-- Approach - 1 Ends here -->
<!-- Approach - 2 Starts from here -->
<div id="optimal-approach">
<details>
<summary class="main-summary">
<span>
                    Optimal Approach 
                </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="common-drops">
<details class="secondary-details" open="">
<summary class="secondary-summary">
<span>
                            Algorithm / Intuition
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="approach-algorithm">
<p>Given that the binary is a complete binary tree, we can exploit its properties to optimise the algorithm and achieve a better time complexity.
                        In a complete binary tree, the last level may not be completely filled, but the nodes are positioned from left to right. This property allows us to determine the number of nodes using just the height.
                        The relationship between the height of the binary tree (h) and the maximum number of nodes it can have, denoted by the formula: 
                        Maximum Number of Nodes: 2^h-1</p>
<!--<figure class="wp-block-image size-full is-resized"><img src="https://static.takeuforward.org/content/lca-tree-image7-rLcRwzU1" alt="" class="wp-image-8107" width="439" height="286"/></figure>-->
<p>If the last level of a binary tree is perfectly filled, known as a perfect binary tree, the count of nodes can be determined by the formula: 2h-1, where h is the height. To check if the last level of the Binary Tree is filled or not we can compare the left and right heights of the tree.</p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="286" src="assets/ef69258a8711d6449721f8f4dbc4764a" width="439"/></figure>
<p><ol><li>If the left height equals right height, it indicates that the last level is completely filled.</li><li>If the left height does not equal right height, the last level is not completely filled.</li></ol>
                        In the case where left height and right height differ, we can employ a recursive approach. We recursively calculate the number of nodes in the left subtree and in the right subtree , and then return the total count as 1 + leftNodes + rightNodes.
                        If the height of the left subtree is equal to the height of the right subtree, we can directly calculate using the 2h-1 formula.</p>
<p><strong>Algorithm:</strong></p>
<p><strong>Step 1: Base Case</strong>  If the given node is null, we return 0 as there are no nodes to count.</p>
<p><strong>Step 2: Recursive Calls: </strong>  Recursively find the left height and right height of the Binary Tree. </p>
<p><strong>Step 3: Comparison: </strong>   If the left height is equal to the right height implies that the tree’s last level is completely filled. Return the count of nodes using the formula: return (1 &lt;&lt; lh) - 1, where &lt;&lt; represents the left shift operator and represents the power of 2. </p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/d57d0568eaab444bb31ae2fb4dc98251" width="600"/></figure>
<p><strong>Step 4: </strong>If the left height is not equal to the right height implies that the tree’s last level is not completely filled.
                        Recursively call the function to the left and right subtree and return the final number of nodes as
                        1 + countNodes(root-&gt;left) + countNodes(root-&gt;right)</p>
<p><strong>Step 5: </strong>  Implement the find left height and right height functions.
                        <ol><li>Start with the variable height set to 0.</li><li>Use a while loop to traverse the left/right side of the tree incrementing the height until reaching a leaf node.</li><li>Return the calculated height.</li></ol></p>
<figure class="wp-block-image size-full is-resized"><img alt="" class="wp-image-8107" height="1000" src="assets/f3d072d04dcef6ecfef6a296fcf9c081" width="600"/></figure>
</div>
</details>
<details class="code-section secondary-details">
<summary class="secondary-summary">
<span>
                            Code
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<div class="code-tabs">
<button class="code-tab dsa_article_code_active" data-lang="cpp">C++</button>
<button class="code-tab" data-lang="java">Java</button>
<button class="code-tab" data-lang="python">Python</button>
<button class="code-tab" data-lang="javascript">JavaScript</button>
<svg class="copy-btn" fill="none" height="20" viewbox="0 0 17 20" width="17" xmlns="http://www.w3.org/2000/svg">
<path d="M2 20C1.45 20 0.979002 19.804 0.587002 19.412C0.195002 19.02 -0.000664969 18.5493 1.69779e-06 18V4H2V18H13V20H2ZM6 16C5.45 16 4.979 15.804 4.587 15.412C4.195 15.02 3.99934 14.5493 4 14V2C4 1.45 4.196 0.979002 4.588 0.587002C4.98 0.195002 5.45067 -0.000664969 6 1.69779e-06H15C15.55 1.69779e-06 16.021 0.196002 16.413 0.588002C16.805 0.980002 17.0007 1.45067 17 2V14C17 14.55 16.804 15.021 16.412 15.413C16.02 15.805 15.5493 16.0007 15 16H6ZM6 14H15V2H6V14Z">
</path>
</svg>
</div>
<div class="code-content">
<div class="code-block dsa_article_code_active" data-lang="cpp">
<pre class="wp-block-code">
                                <code class="language-cpp" lang="cpp">
#include &lt;iostream&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

// TreeNode structure
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};



class Solution {
public:
    // Function to count nodes
    // in a binary tree
    int countNodes(TreeNode* root) {
        // Base case: If the root
        // is NULL, there are no nodes
        if (root == NULL) {
            return 0;
        }
        
        // Find the left height and
        // right height of the tree
        int lh = findHeightLeft(root);
        int rh = findHeightRight(root);
        
        // Check if the last level
        // is completely filled
        if (lh == rh) {
            // If so, use the formula for
            // total nodes in a perfect
            // binary tree ie. 2^h - 1
            return (1 &lt;&lt; lh) - 1; 
        }
        
        // If the last level is not completely
        // filled, recursively count nodes in
        // left and right subtrees
        return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right);
    }
    
    // Function to find the left height of a tree
    int findHeightLeft(TreeNode* node) {
        int height = 0;
        // Traverse left child until
        // reaching the leftmost leaf
        while (node) {
            height++;
            node = node-&gt;left;
        }
        return height;
    }
    
    // Function to find the right height of a tree
    int findHeightRight(TreeNode* node) {
        int height = 0;
        // Traverse right child until
        // reaching the rightmost leaf
        while (node) {
            height++;
            node = node-&gt;right;
        }
        return height;
    }
};



int main() {
    // Create the binary tree
    TreeNode* root = new TreeNode(1);
    root-&gt;left = new TreeNode(2);
    root-&gt;right = new TreeNode(3);
    root-&gt;left-&gt;left = new TreeNode(4);
    root-&gt;left-&gt;right = new TreeNode(5);
    root-&gt;right-&gt;left = new TreeNode(6);

    Solution sol;

    // Call the countNodes function
    int totalNodes = sol.countNodes(root);

    // Print the result
    cout &lt;&lt; "Total number of nodes in the Complete Binary Tree: "
            &lt;&lt; totalNodes &lt;&lt; endl;



    return 0;
}
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="java">
<pre class="wp-block-code">
                                <code class="language-java" lang="java">
import java.util.LinkedList;
import java.util.Queue;

// TreeNode structure
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    public TreeNode(int x) {
        val = x;
        left = null;
        right = null;
    }
}

public class Solution {
    // Function to count the total number
    // of nodes in a Complete Binary Tree
    public int countNodes(TreeNode root) {
        // Check if the tree is empty
        if (root == null) {
            return 0;
        }

        // Find the height of the left subtree
        int lh = findHeightLeft(root);
        // Find the height of the right subtree
        int rh = findHeightRight(root);

        // If the heights are equal, the tree
        // is a full binary tree, and we can
        // calculate the total nodes
        if (lh == rh) {
            return (1 &lt;&lt; lh) - 1;
        }

        // If the heights are not equal,
        // recursively count nodes in the
        // left and right subtrees
        return 1 + countNodes(root.left) + countNodes(root.right);
    }

    // Function to find the
    // height of the left subtree
    private int findHeightLeft(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }

    // Function to find the
    // height of the right subtree
    private int findHeightRight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.right;
        }
        return height;
    }

    public static void main(String[] args) {
        // Create the binary tree
        TreeNode root = new TreeNode(1);
        root.left = new TreeNode(2);
        root.right = new TreeNode(3);
        root.left.left = new TreeNode(4);
        root.left.right = new TreeNode(5);
        root.right.left = new TreeNode(6);

        Solution sol = new Solution();

        // Call the countNodes function
        int totalNodes = sol.countNodes(root);

        // Print the result
        System.out.println("Total number of nodes in the Complete Binary Tree: " + totalNodes);
    }
}           

                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="python">
<pre class="wp-block-code">
                                <code class="language-python" lang="python">
                     
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution:
    def countNodes(self, root):
        """
        Count the total number of nodes in the Complete Binary Tree.

        :param root: TreeNode, the root of the binary tree
        :return: int, total number of nodes in the binary tree
        """
        if not root:
            return 0

        lh = self.findHeightLeft(root)
        rh = self.findHeightRight(root)

        if lh == rh:
            return (1 &lt;&lt; lh) - 1
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)

    def findHeightLeft(self, node):
        """
        Find the height of the left subtree.

        :param node: TreeNode, the root of the subtree
        :return: int, height of the left subtree
        """
        hght = 0
        while node:
            hght += 1
            node = node.left
        return hght

    def findHeightRight(self, node):
        """
        Find the height of the right subtree.

        :param node: TreeNode, the root of the subtree
        :return: int, height of the right subtree
        """
        hght = 0
        while node:
            hght += 1
            node = node.right
        return hght


if __name__ == "__main__":
    # Create the binary tree
    root = TreeNode(1)
    root.left = TreeNode(2)
    root.right = TreeNode(3)
    root.left.left = TreeNode(4)
    root.left.right = TreeNode(5)
    root.right.left = TreeNode(6)

    sol = Solution()

    # Call the countNodes function
    totalNodes = sol.countNodes(root)

    # Print the result
    print(f"Total number of nodes in the Complete Binary Tree: {totalNodes}")
                                </code>
                            </pre>
</div>
<div class="code-block" data-lang="javascript">
<pre class="wp-block-code">
                            <code class="language-javascript" lang="javascript">
// TreeNode structure
class TreeNode {
    constructor(x) {
        this.val = x;
        this.left = null;
        this.right = null;
    }
}

class Solution {
    // Function to count nodes
    // in a complete binary tree
    countNodes(root) {
        if (root === null) {
            return 0;
        }

        // Find height of left and right subtrees
        const lh = this.findHeightLeft(root);
        const rh = this.findHeightRight(root);

        // If height of left and right subtrees
        // is the same, the tree is a perfect binary tree
        if (lh === rh) {
            return (1 &amp;lt;&amp;lt; lh) - 1;
        }

        // Recursive call for
        // left and right subtrees
        return 1 + this.countNodes(root.left) + this.countNodes(root.right);
    }

    // Function to find the
    // height of the left subtree
    findHeightLeft(node) {
        let height = 0;
        while (node) {
            height++;
            node = node.left;
        }
        return height;
    }

    // Function to find the
    // height of the right subtree
    findHeightRight(node) {
        let height = 0;
        while (node) {
            height++;
            node = node.right;
        }
        return height;
    }
}

// Main function
function main() {
    // Create the binary tree
    const root = new TreeNode(1);
    root.left = new TreeNode(2);
    root.right = new TreeNode(3);
    root.left.left = new TreeNode(4);
    root.left.right = new TreeNode(5);
    root.right.left = new TreeNode(6);

    const sol = new Solution();

    // Call the countNodes function
    const totalNodes = sol.countNodes(root);

    // Print the result
    console.log(&amp;quot;Total number of nodes in the Complete Binary Tree: &amp;quot; + totalNodes);
}

// Execute the main function
main();
                    
                            </code>
                        </pre>
</div>
<p>
<strong>Output:</strong> Total number of nodes in the Complete Binary Tree: 6
                        </p>
</div>
</details>
<details class="secondary-details">
<summary class="secondary-summary">
<span>
                            Complexity Analysis
                        </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z">
</path>
</svg>
</summary>
<p><strong>Time Complexity: O(log N * log N)</strong> where N is the number of nodes in the Binary Tree.
                        <ol><li>The calculation of leftHeight and rightHeight takes O(log N) time.</li><li>In the worst case, when encountering the second case (leftHeight != rightHeight), the recursive calls are made at most log N times (the height of the tree).</li><li>Therefore, the total time complexity is O(log N * log N).</li></ol></p>
<p><strong>Space Complexity : O(H) ~ O(N)</strong>  where N is the number of nodes in the Binary Tree.
                        <ol><li>The space complexity is determined by the maximum depth of the recursion stack, which is equal to the height of the binary tree.</li><li>Since the given tree is a complete binary tree, the height will always be log N.</li><li>Therefore, the space complexity is O(log N).</li></ol>
</p>
</details>
</div>
</details>
</div>
</div>
<!-- This is Video Explination Drop-Down -->
<div class="dsa_article_youtube_video" id="dsa_article_video_explanation">
<details>
<summary class="main-summary">
<span>
                Video Explanation
            </span>
<svg class="arrow-svg opacity-75" viewbox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
<path d="M12.95 10.707l.707-.707L8 4.343 6.586 5.757 10.828 10l-4.242 4.243L8 15.657l4.95-4.95z"></path>
</svg>
</summary>
<div class="yt-video-wrapper">
<iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/u-yWemKGWO0?si=nO32uyNwtXm7YXUf" title="YouTube video player" width="560"></iframe>
</div>
</details>
</div>
<script src="https://takeuforward.org/UXApproachDropDowns/2ApproachJSScript.js"></script>
<blockquote class="wp-block-quote">
    Special thanks to <strong><a href="https://www.linkedin.com/in/gauri-tomar-005048268">Gauri Tomar</a></strong> for contributing to this article on takeUforward. If you also wish to share your knowledge with the takeUforward fam,<strong><a href="https://takeuforward.org/interviews/paid-work-from-home-internship-at-takeuforward/"> please check out this article</a></strong>
</blockquote>
<script>

    const codeSections = document.querySelectorAll('.code-section');

    // Get last selected language from localStorage or set default value
    let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

    codeSections.forEach((section, sectionIndex) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');
        const copyBtn = section.querySelector('.copy-btn');

        codeTabs.forEach((tab) => {
            tab.addEventListener('click', () => {
                codeTabs.forEach((t) => {
                    t.classList.remove('dsa_article_code_active');
                });
                tab.classList.add('dsa_article_code_active');

                const lang = tab.dataset.lang;
                const activeBlock = section.querySelector(`.code-block[data-lang="${lang}"]`);
                codeBlocks.forEach((block) => {
                    if (block === activeBlock) {
                        block.classList.add('dsa_article_code_active');
                    } else {
                        block.classList.remove('dsa_article_code_active');
                    }
                });

                // Update last selected language for all sections and store in localStorage
                lastSelectedLanguage = lang;
                localStorage.setItem('lastSelectedLanguage', lang);
                codeSections.forEach((otherSection, otherIndex) => {
                    if (otherIndex !== sectionIndex) {
                        const otherTabs = otherSection.querySelectorAll('.code-tab');
                        otherTabs.forEach((otherTab) => {
                            if (otherTab.dataset.lang === lang) {
                                otherTab.classList.add('dsa_article_code_active');
                            } else {
                                otherTab.classList.remove('dsa_article_code_active');
                            }
                        });
                        const otherActiveBlock = otherSection.querySelector(`.code-block[data-lang="${lang}"]`);
                        const otherCodeBlocks = otherSection.querySelectorAll('.code-block');
                        otherCodeBlocks.forEach((block) => {
                            if (block === otherActiveBlock) {
                                block.classList.add('dsa_article_code_active');
                            } else {
                                block.classList.remove('dsa_article_code_active');
                            }
                        });
                    }
                });
            });
        });

        // Handle copy button click event
        copyBtn.addEventListener('click', () => {
            const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
            navigator.clipboard.writeText(activeBlock.innerText);
            copyBtn.classList.add('dsa_article_code_active');
            setTimeout(() => {
                copyBtn.classList.remove('dsa_article_code_active');
            }, 1000);
        });
    });

    // Set initial state of the tabs
    codeSections.forEach((section) => {
        const codeTabs = section.querySelectorAll('.code-tab');
        const codeBlocks = section.querySelectorAll('.code-block');

        codeTabs.forEach((tab) => {
            if (tab.dataset.lang === lastSelectedLanguage) {
                tab.classList.add('dsa_article_code_active');
            } else {
                tab.classList.remove('dsa_article_code_active');
            }
        });

        codeBlocks.forEach((block) => {
            if (block.dataset.lang === lastSelectedLanguage) {
                block.classList.add('dsa_article_code_active');
            } else {
                block.classList.remove('dsa_article_code_active');
            }
        });
    });
</script>
<link href="assets/4237ffca7ce6aadb438c457e0a675b12.css" rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>
<script src="index.js"></script>
<script>hljs.highlightAll();</script>
</article>
</div>
<script>
        document.addEventListener('DOMContentLoaded', function () {
            // This script fixes the functionality of the code language switcher tabs
            // that are injected from the JSON content. It uses event delegation for efficiency.

            const codeSections = document.querySelectorAll('.code-section');
            let lastSelectedLanguage = localStorage.getItem('lastSelectedLanguage') || 'cpp';

            function updateCodeSection(section, language) {
                const tabs = section.querySelectorAll('.code-tab');
                const blocks = section.querySelectorAll('.code-block');

                tabs.forEach(tab => {
                    tab.classList.toggle('dsa_article_code_active', tab.dataset.lang === language);
                });

                blocks.forEach(block => {
                    block.classList.toggle('dsa_article_code_active', block.dataset.lang === language);
                });
            }

            function updateAllSections(language) {
                lastSelectedLanguage = language;
                localStorage.setItem('lastSelectedLanguage', language);
                codeSections.forEach(section => {
                    updateCodeSection(section, language);
                });
            }

            codeSections.forEach(section => {
                const tabsContainer = section.querySelector('.code-tabs');
                if (!tabsContainer) return;

                // Use event delegation on the container to handle clicks
                tabsContainer.addEventListener('click', (event) => {
                    const tabTarget = event.target.closest('.code-tab');
                    const copyTarget = event.target.closest('.copy-btn');

                    // Handle tab clicks
                    if (tabTarget) {
                        const lang = tabTarget.dataset.lang;
                        if (lang) {
                            updateAllSections(lang);
                        }
                    }

                    // Handle copy button clicks
                    if (copyTarget) {
                        const activeBlock = section.querySelector('.code-block.dsa_article_code_active code');
                        if (activeBlock && activeBlock.innerText) {
                            // Use the Clipboard API for modern browsers
                            navigator.clipboard.writeText(activeBlock.innerText).then(() => {
                                copyTarget.classList.add('dsa_article_code_active');
                                setTimeout(() => {
                                    copyTarget.classList.remove('dsa_article_code_active');
                                }, 1500);
                            }).catch(err => {
                                console.error('Failed to copy text: ', err);
                            });
                        }
                    }
                });
            });

            // Set the initial state for all sections on page load
            if (codeSections.length > 0) {
                updateAllSections(lastSelectedLanguage);
            }
        });
    </script>
</body>
</html>